// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0 effective-5.10 (swiftlang-6.0.0.9.10 clang-1600.0.26.2)
// swift-module-flags: -target arm64-apple-ios14.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name LensCustomerSDK
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import ARKit
import AVFoundation
import AVKit
import CallKit
import Combine
import CommonCrypto
import Compression
import CoreData
import CoreFoundation
import CoreGraphics
import CoreImage
import CoreMedia
import CoreText
import CoreVideo
import DeveloperToolsSupport
import Foundation
@_exported import LensCustomerSDK
import Metal
import Photos
import QuartzCore
import SceneKit
import Security
import SnapKit
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import UniformTypeIdentifiers
import UserNotifications
import UserNotificationsUI
import Vision
import WebKit
import WebRTC
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import zlib
public enum SessionValidationResponse {
  case validTechnician(any LensCustomerSDK.TechnicianSessionParams)
  case validCustomer(any LensCustomerSDK.CustomerSessionParams)
  case error((any Swift.Error)?)
  public enum SessionValidationError : Swift.Error {
    case invalidKey
    case invalidLicence
    case sessionExpired
    case unknowError
    case internalError
    case invalidOrgAcess
    case differentOrg
    case appUpgrade
    case customer_already_active_in_session
    case parameterMissing
    case unauthorized
    case userActionNotAllowed
    public static func == (a: LensCustomerSDK.SessionValidationResponse.SessionValidationError, b: LensCustomerSDK.SessionValidationResponse.SessionValidationError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public enum Edition : Swift.String {
  case FREE, STANDARD, PROFESSIONAL
  public var features: [LensCustomerSDK.Features] {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum Features : Swift.String {
  case INSTANT_CHAT, ANNOTATION_CUSTOMER, USER_MANAGEMENT, ZOOM, ACTION_LOG_VIEWER, SESSION_NOTES, CAPTURE_SCREEN_SHOT, SMS_INVITATION, ANNOTATION_TECHNICIAN, FREEZE_CAMERA_STREAM, DEPARTMENT
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AssisLensStates {
  case socketConnected, localPeerHandShakeInitated, localPeerHandShakeDone, remotePeerHandshakeInitated, remotePeerHandshakeDone, connectionCompleted, localIceCandidatesConnectionFailure, remoteIceCandidatesConnectionFailure
  case disconnected((any Swift.Error)?)
  public enum AssistLensDisconnectState : Swift.Error {
    case noInternet, customerEndSession, technicianEndSession, timeout, invalid_client, invalid_key, session_expired, localPeerHandShakeError, remotePeerHandShakeError, serverEndedSession, openedInDifferentLocation, customer_already_active_in_session, secTechEntryRejected
    public static func == (a: LensCustomerSDK.AssisLensStates.AssistLensDisconnectState, b: LensCustomerSDK.AssisLensStates.AssistLensDisconnectState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var debugDescription: Swift.String {
    get
  }
}
public enum SessionValidation : Swift.String {
  case valid_session, invalid_session, invalid_client, session_expired, duplicate_client
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ConnectionProcessType : Swift.String {
  case REINIT, INIT, RESTART
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum TechnicianAction : Swift.String {
  case snapshot_taken, video_pause, video_play, audio_muted, audio_unmuted
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum RecodingStatus : Swift.String {
  case ENABLED, STORAGE_FULL, NOT_CONFIGURED, NOT_AVAILABLE
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum RecordingControlMode : Swift.String {
  case FULL_SESSION_REC, IN_SESSION_REC
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CustomerAction : Swift.String {
  case muteAudio
  case muteVideo
  case unmuteAudio
  case unmuteVideo
  case appResignActive
  case appBecomeActive
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ConferenceType : Swift.String {
  case smart_conference, peer_to_peer
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum LensOpreationError : Swift.Error {
  case featureNotExist, messageNotSent, scopeError, dataCorrupted
  public static func == (a: LensCustomerSDK.LensOpreationError, b: LensCustomerSDK.LensOpreationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ShareCameraActionType : Swift.String {
  case request
  case response
  case videoOff
  case cameraStreamChange
  case cameraStreamRemoved
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ShareCameraTechAction : Swift.String {
  case cameraStreamChange, cameraStreamRemoved, RequestApproved, RequestRejected, RequestWaiting
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum SnapShotAction : Swift.String, Swift.Codable {
  case freeze, freeze_request, unfreeze, unfreeze_request
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ScanType : Swift.String {
  case OCR
  case QR
  case BARCODE
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum RoleEnum : Swift.String {
  case Customer
  case PrimaryTechnician
  case SecondaryTechnician
  case ExternalTechnician
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ScanRequestType : Swift.Equatable {
  case LOCAL
  case REMOTE(trigger_id: Swift.String)
  public static func == (a: LensCustomerSDK.ScanRequestType, b: LensCustomerSDK.ScanRequestType) -> Swift.Bool
}
public enum ScanState {
  case REQUESTED(scanType: LensCustomerSDK.ScanType, scanRequestType: LensCustomerSDK.ScanRequestType)
  case COMPLETED(model: LensCustomerSDK.ScanModel)
  case ERROR(scanError: LensCustomerSDK.ScanError)
}
public enum ScanModel {
  case OCR(ocrText: Swift.String, confidence: Swift.String)
  case QR(qrText: Swift.String)
  case BARCODE(barcodeText: Swift.String)
}
public struct ScanError : Swift.Error {
  public let scanType: LensCustomerSDK.ScanType
  public let scanRequestType: LensCustomerSDK.ScanRequestType
  public let errorMessage: Swift.String
}
public enum MonitorActionEnum : Swift.String {
  case OPEN, UPDATE, SELECT, DESELECT, DELETE, TURN_ON, TURN_OFF, ARROW, PENCIL, RECTANGLE, ELLIPSE, MEASUREMENT, POINTER_3D, TYPE_ERROR
  public static func convertLensAnnotationType(typeString: Swift.String) -> LensCustomerSDK.MonitorActionEnum
  public static func convertLensAnnotationType(type: LensCustomerSDK.LensAnnotationType) -> LensCustomerSDK.MonitorActionEnum
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MonitorFeatureEnum {
  case AR_NOTES, OCR, QR, FLASH, ANNOTATE(triggerId: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum AnnotationObjectType : Swift.String {
  case pencil, ellipse, rectangle, arrow, pointer
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ClearAction : Swift.String {
  case clear_ar, clearall_ar, clearall_2d, clearall, add_ar
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AnnotationSelection : Swift.String {
  case ar_selected, ar_deselected
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AR_TrackingState {
  case normal, excessiveMotion, initializing, relocalizing, insufficientFeatures, notAvailable
  public static func == (a: LensCustomerSDK.AR_TrackingState, b: LensCustomerSDK.AR_TrackingState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum SupportedTools : Swift.String {
  case ARROW, PENCIL, RECTANGLE, ELLIPSE, AR_MEASURE, AR_NOTES, POINTER, FLASH, SELECT
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc @_Concurrency.MainActor @preconcurrency open class ChatletViewController : UIKit.UIViewController, WebKit.WKDownloadDelegate, WebKit.WKNavigationDelegate, WebKit.WKUIDelegate {
  @_Concurrency.MainActor @preconcurrency public var new_chat_notification: LensCustomerSDK.LensBind<Swift.Bool>
  @_Concurrency.MainActor @preconcurrency public var chat_open_request: LensCustomerSDK.LensBind<Swift.Bool>
  @_Concurrency.MainActor @preconcurrency public init(connection_param: any LensCustomerSDK.CommonConnectionParams)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency public func load_chatlet_if_not_loaded_already()
  @_Concurrency.MainActor @preconcurrency public func logout_user()
  @objc deinit
}
extension LensCustomerSDK.ChatletViewController {
  @_Concurrency.MainActor @preconcurrency public func send_chat(_ chat_text: Swift.String)
}
extension LensCustomerSDK.ChatletViewController {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didCommit navigation: WebKit.WKNavigation!)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didStartProvisionalNavigation navigation: WebKit.WKNavigation!)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation!)
  @available(iOS 13.0, *)
  @_Concurrency.MainActor @preconcurrency public func webView(_ webView: WebKit.WKWebView, navigationAction: WebKit.WKNavigationAction, preferences: WebKit.WKWebpagePreferences, decisionHandler: @escaping (WebKit.WKNavigationActionPolicy, WebKit.WKWebpagePreferences) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationResponse: WebKit.WKNavigationResponse, decisionHandler: @escaping (WebKit.WKNavigationResponsePolicy) -> Swift.Void)
}
extension LensCustomerSDK.ChatletViewController : WebKit.WKScriptMessageHandler {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func userContentController(_ userContentController: WebKit.WKUserContentController, didReceive message: WebKit.WKScriptMessage)
}
extension LensCustomerSDK.ChatletViewController {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, createWebViewWith configuration: WebKit.WKWebViewConfiguration, for navigationAction: WebKit.WKNavigationAction, windowFeatures: WebKit.WKWindowFeatures) -> WebKit.WKWebView?
  @available(iOS 14.5, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, navigationAction: WebKit.WKNavigationAction, didBecome download: WebKit.WKDownload)
  @available(iOS 14.5, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func download(_ download: WebKit.WKDownload, decideDestinationUsing response: Foundation.URLResponse, suggestedFilename: Swift.String, completionHandler: @escaping (Foundation.URL?) -> Swift.Void)
  @available(iOS 14.5, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func downloadDidFinish(_ download: WebKit.WKDownload)
  @available(iOS 14.5, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func download(_ download: WebKit.WKDownload, didFailWithError error: any Swift.Error, resumeData: Foundation.Data?)
}
@objc @_hasMissingDesignatedInitializers public class Chat : LensCustomerSDK.BaseParser {
  public var clientID: Foundation.NSNumber?
  final public let message: Swift.String?
  public var participant: LensCustomerSDK.Participant?
  final public let date: Foundation.Date
  public init(with chatMsg: Swift.String?)
  @objc deinit
}
public struct LensSessionContent {
  public enum Session : Swift.String {
    case Invite
    case noChat
    case invalid_client
    case invalid_key
    case Nointernet
    case oopsWrong
    case sessionExpired
    case timeout
    case leaveSession
    case planError
    case customerJoined
    case customerLeft
    case exitWarning
    case clearAnnotaionConfirmation
    case diffLocation
    case inviteTechnician
    case inviteTechnicianDescription
    case inviteInternalTechnicianDescription
    case inviteExternalTechnicianDescription
    case shareCopyInviteTechnician
    case share
    case copy
    case customer_already_active_join_as_technician
    case customer_already_active_signin_as_technician
    case secTechEntryRequestTitle
    case secTechEntryRequestDesc
    case secTechEntryRequestAccept
    case secTechEntryRequestReject
    case emailInviteFailedTitle
    case emailInviteFailedDesc
    case inviteeNotInOrgTitle
    case inviteeNotInOrgDesc
    case inviteSentSuccess
    case shareSessionLink
    case sessionLinkCopied
    public var localized: Swift.String {
      get
    }
    public enum Scan : Swift.String {
      case scanError
      public var localized: Swift.String {
        get
      }
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Chat : Swift.String {
    case placeHolder
    case title
    case loading_chat
    case download_completed
    case downloaded_files_can_be_viewed_in_FilesApp
    case starting_download
    case wait_until_previous_download_finishes
    case download_failed
    case download_error_description
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum InviteUser : Swift.String {
    case inviteCustomerTitle
    case inviteTechnicianTitle
    case enterCustomerid
    case inviteCustomerDescription
    case linkDescription
    case invitationSentToCustomer
    case copiedInviteLink
    public var localized: Swift.String {
      get
    }
    public enum Error : Swift.String {
      case failed
      public var localized: Swift.String {
        get
      }
      public static func invalidEmail() -> Swift.String
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ErrorMsg : Swift.String {
    case accessDeniedMsgForPhotos
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Notes : Swift.String {
    case noteUpdate
    case noteUpdateFailed
    case noteFetchFailed
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Common : Swift.String {
    case loading
    case connecting
    case joining
    case deleting
    case invalidEmail
    case guest
    case exit
    case cancel
    case end
    case reply
    case send
    case ok
    case settings
    case capturing
    case wait
    case yes
    case no
    case customer
    case deny
    case allow
    case view_now
    case refresh
    case close
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ARErroMessage : Swift.String {
    case excessiveMotion
    case insufficientFeatures
    case notAvailable
    case relocalizing
    case initializing
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Snapshot : Swift.String {
    case failure
    case success
    case deleteSuccess
    case deleteFailure
    case deleteConfirmation
    case freezeSuccess
    case freezeInprogress
    case unfreezed
    case streamPaused
    case recodingEnabled
    case recordingStopped
    case storageExceeded
    case recordingNotEnabled
    case selectAll
    case view
    case clear
    case screenshotDownloadFailed
    case freezeAlert
    case freezeAlertHeader
    case freezeAnnotateDownstreamer
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum CustomerActionContent : Swift.String {
    case muteAudio
    case unmuteAudio
    case pauseVideo
    case resumeVideo
    case lockDevice
    case unlockDevice
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ShareCamera : Swift.String {
    case share
    case shareMsgDescription
    case shareMsgDescByPrimaryTech
    case stopShareCamera
    case stopShareCameraDescription
    case shareCameraTechRequestTitle
    case shareCameraTechRequestDesc
    case noneSharing
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Flash : Swift.String {
    case flash_title
    case flash_light_on
    case flash_light_off
    case flash_light_on_failed
    case flash_light_off_failed
    public var localized: Swift.String {
      get
    }
    public static func flash_light_on(by_participant: Swift.String) -> Swift.String
    public static func flash_light_off(by_participant: Swift.String) -> Swift.String
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension Foundation.Data {
  public var utf8String: Swift.String? {
    get
  }
  public var asciiString: Swift.String? {
    get
  }
  public var isoLatin1: Swift.String? {
    get
  }
  public var jsonData: LensCustomerSDK.JSON? {
    get
  }
  public func getInt64(startIndex: Swift.Int) -> Swift.Int64
  public func getInt32(startIndex: Swift.Int) -> Swift.Int32
  public func getInt16(startIndex: Swift.Int) -> Swift.Int16
  public func getInt8(startIndex: Swift.Int) -> Swift.Int8
  public func getString(startIndex: Swift.Int, length: Swift.Int) -> Swift.String?
  public func get<T>(startIndex: Swift.Int, _: T.Type) -> T
  public mutating func appendValue<T>(_ value: T)
  public mutating func appendValue(_ value: Swift.String)
}
extension Swift.Dictionary {
  public var jsonData: Foundation.Data? {
    get
  }
}
extension Swift.String {
  public static let EMPTY: Swift.String
  public static let SPACE: Swift.String
  public static let ZERO: Swift.String
  public static let ONE: Swift.String
  public static let MINUS_ONE: Swift.String!
  public static let UNDERSCORE: Swift.String!
  public static let HASH: Swift.String!
  public static let NEW_LINE: Swift.String!
  public static let LESS_THAN: Swift.String!
  public static let GREATER_THAN: Swift.String!
  public static let EQUALS: Swift.String!
  public static let PLUS: Swift.String!
  public static let HYPHEN: Swift.String!
  public static let COMMA: Swift.String!
  public static let COLON: Swift.String!
  public static let SEMI_COLON: Swift.String!
  public static let AMPERSAND: Swift.String!
  public static let ASTERISK: Swift.String!
  public static let DOT: Swift.String!
  public static let SINGLE_QUOTE: Swift.String
  public static let DOUBLE_QUOTE: Swift.String
  public static let FORWARD_SLASH: Swift.String
  public static let BACK_SLASH: Swift.String
  public static let HTML_AMPERSAND_1: Swift.String
  public static let HTML_AMPERSAND_2: Swift.String
  public static let HTML_LESS_THAN: Swift.String
  public static let HTML_GREATER_THAN: Swift.String
  public static let HTML_SINGLE_QUOTE_1: Swift.String
  public static let HTML_SINGLE_QUOTE_2: Swift.String
  public static let HTML_DOUBLE_QUOTE: Swift.String
  public static let HTML_NEW_LINE: Swift.String
  public static let BOOL_TRUE: Swift.String
  public static let BOOL_FALSE: Swift.String
  public static let ZST_ERROR_PLACEHOLDER: Swift.String
  public func jsonStringParse() -> Any?
  public func heightWithConstrainedWidth(width: CoreFoundation.CGFloat, font: UIKit.UIFont) -> CoreFoundation.CGFloat
}
public protocol LensSessionProtocolDelegate {
  func flash_change(is_supported: Swift.Bool?, current_flash_status: Swift.Bool)
  func flash_change_triggered(by_participant_name: Swift.String?, isOn: Swift.Bool)
  func flash_change_failed(error_message: Swift.String, isOn: Swift.Bool)
  func chatlet_feature_status(is_enabled: Swift.Bool)
}
public typealias JSON = [Swift.String : Any]
public typealias JSONKey = Swift.String
public struct JsonParser {
  public var json: LensCustomerSDK.JSON
  public init?(json: LensCustomerSDK.JSON?)
  public subscript<DataType>(key: LensCustomerSDK.JSONKey) -> DataType? {
    get
  }
  public func jsonParser(forKey key: LensCustomerSDK.JSONKey) -> LensCustomerSDK.JsonParser?
  public func jsonParsers(forKey key: LensCustomerSDK.JSONKey) -> [LensCustomerSDK.JsonParser]?
}
public class LensBind<T> {
  public typealias Listener = (T) -> Swift.Void
  public var value: T {
    get
    set
  }
  public init(_ value: T)
  public func bind(listener: LensCustomerSDK.LensBind<T>.Listener?)
  @objc deinit
}
public struct RoomCredential {
}
public struct TalkSettings {
}
public struct SessionDetails : Swift.Decodable {
  public var session_token: Swift.String?
  public let zsoid: Swift.String
  public let customer_join_link: Swift.String
  public let session_key: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public struct GatewayDetails : Swift.Decodable {
  public let web_socket_path: Swift.String
  public let group: Swift.String
  public let gateway_servers: [Swift.String]
  public init(from decoder: any Swift.Decoder) throws
}
public struct ClientDetails : Swift.Decodable {
  public let client_id: Swift.String
  public let client_role: Swift.Int
  public let client_token: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public protocol AudioSessionProtocol : AnyObject {
  func didChangeRoute(_ audioDescription: AVFAudio.AVAudioSessionRouteDescription, reason: AVFAudio.AVAudioSession.RouteChangeReason)
}
public protocol LensSignallingProtocol : AnyObject {
  func renderingView(_ view: UIKit.UIView?)
  func didChangeLensConnectionState(state: LensCustomerSDK.AssisLensStates)
  func didChange(_ participant: LensCustomerSDK.Participant)
  func refreshBottomMenu()
  func didChangeARState(tracking state: ARKit.ARCamera.TrackingState)
  func participantRejoined(clientId: Swift.String)
  func onScanSuccess(scanResult: LensCustomerSDK.ScanModel)
  func onScanFailure(scanError: LensCustomerSDK.ScanError)
  func onSessionValidationDone()
  func onTechnicianPerform(draw shape: LensCustomerSDK.DrawingInput.DrawShape)
  func conferenceReceived(type: LensCustomerSDK.ConferenceType)
  func newFreezeAcknowledgement()
  func unFreezeFinalAction()
  func showFreezedImage()
}
extension LensCustomerSDK.LensSignallingProtocol {
  public func onSessionValidationDone()
  public func onTechnicianPerform(draw shape: LensCustomerSDK.DrawingInput.DrawShape)
  public func conferenceReceived(type: LensCustomerSDK.ConferenceType)
  public func newFreezeAcknowledgement()
  public func unFreezeFinalAction()
  public func showFreezedImage()
  public func participantRejoined(clientId: Swift.String)
}
public protocol ChatProtocol : AnyObject {
  func didReceive(_ chat: LensCustomerSDK.Chat)
}
public protocol CommonConnectionParams {
  var key: Swift.String { get }
  var session_details: LensCustomerSDK.SessionDetails { get set }
  var gateway_details: LensCustomerSDK.GatewayDetails { get }
  var client_details: LensCustomerSDK.ClientDetails { get }
}
public protocol CustomerSessionParams : LensCustomerSDK.CommonConnectionParams {
}
public protocol TechnicianSessionParams : LensCustomerSDK.CommonConnectionParams {
  var isSessionHost: Swift.Bool { get }
}
public enum VariacType : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  case int(Swift.Int)
  case string(Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
public protocol ARProtocol : AnyObject {
  func onArCommentsReceived(annotationNode: LensCustomerSDK.AnnotationNotify)
  func onAnchorSelectionChanged(annotationId: Swift.String, state: LensCustomerSDK.AnnotationSelection, triggerId: Swift.String)
  func onAnchorPlaced(annotationId: Swift.String)
  func onAnchorRemoved(annotationId: Swift.String)
  var isARSupported: Swift.Bool { get }
}
public enum FreezeCurrentStatus {
  case freezeRunningStream(LensCustomerSDK.FreezeCurrentStatus.FreezeBy), freezeSnapshot(LensCustomerSDK.FreezeCurrentStatus.FreezeBy), unfreeze(LensCustomerSDK.FreezeCurrentStatus.FreezeBy)
  public enum FreezeBy {
    case me, other
    public static func == (a: LensCustomerSDK.FreezeCurrentStatus.FreezeBy, b: LensCustomerSDK.FreezeCurrentStatus.FreezeBy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var isFreeze: Swift.Bool {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class BaseParser : ObjectiveC.NSObject {
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
public enum SDKLensLottieType : LensCustomerSDK.LottieType {
  case loader
  public var lottie: LensCustomerSDK.LottieAnimationView {
    get
  }
  public var lottieName: Swift.String {
    get
  }
  public var message: Swift.String? {
    get
  }
  public var size: CoreFoundation.CGSize? {
    get
  }
  public static func == (a: LensCustomerSDK.SDKLensLottieType, b: LensCustomerSDK.SDKLensLottieType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class LensCustomer : LensCustomerSDK.Lens {
  weak public var otherActionDelegate: (any LensCustomerSDK.OtherActionProtocol)?
  public var getStreamType: LensCustomerSDK.StreamingType? {
    get
  }
  public init(connectionParam: any LensCustomerSDK.CustomerSessionParams, name: Swift.String, email: Swift.String, isARSupported: Swift.Bool = false)
  public func startSession()
  public static func validateSessionForSDK(sessionKey key: Swift.String, token: Swift.String, completion: @escaping (LensCustomerSDK.SessionValidationResponse) -> Swift.Void)
  @objc deinit
}
extension LensCustomerSDK.LensCustomer {
  @discardableResult
  public func muteAudio() -> Swift.Bool
  @discardableResult
  public func unmuteAudio() -> Swift.Bool
  @discardableResult
  public func muteVideo() -> Swift.Bool
  @discardableResult
  public func unmuteVideo() -> Swift.Bool
  public func speakerOn()
  public func speakerOff()
  public func closeRoom()
  public func shareCamera()
  public func stopCamera()
}
extension LensCustomerSDK.Lens : LensCustomerSDK.AudioSessionProtocol {
  public func didChangeRoute(_ audioDescription: AVFAudio.AVAudioSessionRouteDescription, reason: AVFAudio.AVAudioSession.RouteChangeReason)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class ImageScrollView : UIKit.UIScrollView, UIKit.UIScrollViewDelegate {
  public enum ContentMode : Swift.Int {
    case aspectFill
    case aspectFit
    case widthFill
    case heightFill
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum Offset : Swift.Int {
    case begining
    case center
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var isImageInZoomState: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency open var imageContentMode: LensCustomerSDK.ImageScrollView.ContentMode
  @_Concurrency.MainActor @preconcurrency open var initialOffset: LensCustomerSDK.ImageScrollView.Offset
  @_Concurrency.MainActor @preconcurrency weak public var zoomView: UIKit.UIView?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var frame: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency public func adjustFrameToCenter()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency open func display(image res: CoreFoundation.CGSize)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func removeFromSuperview()
  @_Concurrency.MainActor @preconcurrency @objc public func viewForZooming(in scrollView: UIKit.UIScrollView) -> UIKit.UIView?
  @_Concurrency.MainActor @preconcurrency @objc public func scrollViewDidZoom(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc public func scrollViewDidEndZooming(_ scrollView: UIKit.UIScrollView, with view: UIKit.UIView?, atScale scale: CoreFoundation.CGFloat)
}
public struct DrawingInput {
  public enum DrawShape : Swift.String {
    case ellipse, pencil, rectangle, arrow, pointer
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var id: Swift.String
  public var triggerId: Swift.String
  public var annotationType: LensCustomerSDK.DrawingInput.DrawShape
  public var storkeColor: UIKit.UIColor
  public var start: CoreFoundation.CGPoint!
  public var end: CoreFoundation.CGPoint!
  public var fillColor: UIKit.UIColor
  public var fadeOutDelay: Swift.Int
  public var name: Swift.String
  public enum FreeStyleState : Swift.String {
    case mouse_move, mouse_up
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var freeStyleState: LensCustomerSDK.DrawingInput.FreeStyleState?
  public var size: CoreFoundation.CGSize {
    get
  }
  public var frame: CoreFoundation.CGRect {
    get
    set
  }
  public var line_width: CoreFoundation.CGFloat
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func showNotificationBanner(message: Swift.String, show duration: Foundation.TimeInterval = 4, completion: (() -> Swift.Void)? = nil)
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func showLottie(lottie type: any LensCustomerSDK.LottieType, onTap: ((UIKit.UIButton) -> (() -> Swift.Void)?)? = nil, lottieBackgroundColor: UIKit.UIColor = UIColor.white, subViewIndex: Swift.Int = -1, tag: Swift.Int? = 43566534)
  @_Concurrency.MainActor @preconcurrency public func dismissLottieView()
  @_Concurrency.MainActor @preconcurrency public func at_showLoader(with size: CoreFoundation.CGSize = CGSize.init(width: 100, height: 100), overViewColor: UIKit.UIColor = UIColor.black.withAlphaComponent(0.5), text: Swift.String = "", textColor: UIKit.UIColor = .white)
  @_Concurrency.MainActor @preconcurrency public var at_isLoaderHidden: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func at_hideLoader()
}
extension ObjectiveC.NSObject {
  public func hapticMediumImpact()
  public func hapticWarningImpact()
  public func hapticSuccessImpact()
  public func hapticErrorImpact()
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AudioSessionHandler : ObjectiveC.NSObject {
  weak public var delegate: (any LensCustomerSDK.AudioSessionProtocol)?
  convenience public init(with delegate: any LensCustomerSDK.AudioSessionProtocol)
  public func set(_ port: AVFAudio.AVAudioSession.PortOverride, completion: @escaping (Swift.Bool) -> ())
  @objc deinit
}
extension LensCustomerSDK.AudioSessionHandler : WebRTC.RTCAudioSessionDelegate {
  @objc dynamic public func audioSessionDidChangeRoute(_ session: WebRTC.RTCAudioSession, reason: AVFAudio.AVAudioSession.RouteChangeReason, previousRoute: AVFAudio.AVAudioSessionRouteDescription)
}
public enum LensFlashError : Swift.String, Swift.Error {
  case unable_to_turn_on_the_flash
  case unable_to_turn_off_the_flash
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct LensFlashNotification {
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class LensFlashCoordinator : ObjectiveC.NSObject {
  public typealias FlashChangeNotification = (LensCustomerSDK.LensFlashNotification) -> ()
  public func reset_upstreamer_flash_info()
  public func update_upstreamer_flash_info(is_supported: Swift.Bool, is_On: Swift.Bool, notify_needed: Swift.Bool)
  public func force_stop_the_flashlight()
  public func current_device_has_flash(is_front_camera: Swift.Bool = false) -> Swift.Bool
  public func current_device_flash_status() -> Swift.Bool
  public func current_device_flash_toggle(trigger_Id: Foundation.NSNumber?)
  @objc deinit
}
public class DrawingShapes {
  final public let superShapeLayer: QuartzCore.CAShapeLayer
  weak public var view: UIKit.UIView?
  public init(with view: UIKit.UIView, within rect: CoreFoundation.CGRect)
  public func draw(with drawParm: LensCustomerSDK.DrawingInput, lineDashPattern: [Foundation.NSNumber]? = nil)
  public func clearPath(for id: Swift.String)
  public func clearAll()
  @objc deinit
}
extension LensCustomerSDK.Lens {
  public func requestOCR()
  public func requestQR(retryMode: LensCustomerSDK.QRRetryMode)
}
public protocol OtherActionProtocol : AnyObject {
  func onTechnicianPerform(action: LensCustomerSDK.TechnicianAction)
  var isCustomerVideoMuted: Swift.Bool { get }
  func onShareCameraResponse(action: LensCustomerSDK.ShareCameraTechAction, participant: LensCustomerSDK.Participant?)
  func showNotificationBanner(msg: Swift.String)
  func onVideoStateChanged(status: Swift.Bool)
  func onFreezeSuccess(fromUpstreamer: Swift.Bool)
  func onFreezeFailure()
  func onUnfreezed()
  func didReceiveAnnotation(input: LensCustomerSDK.DrawingInput?, isClear: Swift.Bool)
  func onCameraSwitch(isFront: Swift.Bool)
}
extension LensCustomerSDK.OtherActionProtocol {
  public func didReceiveAnnotation(input: LensCustomerSDK.DrawingInput?, isClear: Swift.Bool)
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class Node : SceneKit.SCNNode {
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_USER_ID: Swift.String {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func createOutlineNode() -> SceneKit.SCNNode
  @objc deinit
}
extension LensCustomerSDK.Node : Swift.Comparable {
  @_Concurrency.MainActor @preconcurrency public static func < (lhs: LensCustomerSDK.Node, rhs: LensCustomerSDK.Node) -> Swift.Bool
}
public protocol AnnotationSelectionListener : AnyObject {
  func onAnnotationSelected(id: Swift.String, triggerId: Swift.String)
  func onAnnotationDeselected(id: Swift.String, triggerId: Swift.String)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class LineNode : LensCustomerSDK.Node {
  @_Concurrency.MainActor @preconcurrency public static let LINE_NODE_NAME: Swift.String
  @_Concurrency.MainActor @preconcurrency public func reset()
  @_Concurrency.MainActor @preconcurrency public func getLineVertextCameraPoint(forIndex index: Swift.Int) -> SceneKit.SCNVector3
  @_Concurrency.MainActor @preconcurrency public func getLineVertexCameraNode(forIndex index: Swift.Int) -> SceneKit.SCNNode
  @_Concurrency.MainActor @preconcurrency public func addWorldPointAndCreateVertices(sceneView: ARKit.ARSCNView, worldPoint: SceneKit.SCNVector3, withInvertedTriangle isInvertedTriangle: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func addPointAndCreateVertices(sceneView: ARKit.ARSCNView, wx: Swift.Float, wy: Swift.Float, wz: Swift.Float, withInvertedTriangle isInvertedTriangle: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency override public func createOutlineNode() -> SceneKit.SCNNode
  @objc deinit
}
@_inheritsConvenienceInitializers @available(iOS 11.0, *)
@objc public class ViewAR : ObjectiveC.NSObject {
  @objc public static var orientation: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension LensCustomerSDK.ARRenderView {
  @_Concurrency.MainActor @preconcurrency public func measurement_Trigger_Action()
  @_Concurrency.MainActor @preconcurrency public func undoLastARMeaserment()
  @_Concurrency.MainActor @preconcurrency public func undoInprogressARMeasurement()
  @_Concurrency.MainActor @preconcurrency public func undoLastCustomerAnnotation()
}
@objc public enum ARInputViewOrientation : Swift.Int {
  case portrait = 1
  case landscapeLeft = 3
  case landscapeRight = 4
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum ARInputViewOrientationMode {
  case auto
  case all
  case manual(subviews: [UIKit.UIView])
  case disabled
}
public protocol AnchorStateListener {
  func onAnchorPlaced(annotationId: Swift.String, annotationColor: UIKit.UIColor, annotationType: Swift.String, annotationNumber: Swift.Int, triggerId: Swift.String, length: Swift.String?)
  func onAnchorRemoved(annotationId: Swift.String)
}
@available(iOS 11.0, *)
@objc public protocol RenderARDelegate {
  @objc func frame(didRender buffer: CoreVideo.CVPixelBuffer, with time: CoreMedia.CMTime, using rawBuffer: CoreVideo.CVPixelBuffer)
}
public class CustomCircularArray<E> {
  public init(ofSize size: Swift.Int)
  public func setOverwriteCallback(_ callback: ((E, Swift.Int) -> ())?)
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public func clear()
  public func get(index: Swift.Int) -> E?
  public var first: E? {
    get
  }
  public var last: E? {
    get
  }
  public func popLast() -> E?
  public func popFirst() -> E?
  public func push(element: E)
  public func remove(forWhich: (E) -> Swift.Bool) -> [E?]
  public func remove(index: Swift.Int)
  public func nextIndex() -> Swift.Int
  public func getMaxElementCount() -> Swift.Int
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class RemovePointerOperation : Foundation.Operation {
  @objc override dynamic public func cancel()
  @objc override dynamic public func main()
  @objc deinit
}
extension UIKit.UIImage {
  public static func getPointerTexture(color: UIKit.UIColor) -> UIKit.UIImage?
  public static func getPlaneTexture() -> UIKit.UIImage?
  public static func getBorderTexture() -> UIKit.UIImage?
  public static func getBorderLineTexture() -> UIKit.UIImage?
  public static func getCancelButtonTexture() -> UIKit.UIImage?
  public static func getARNotesButtonTexture() -> UIKit.UIImage?
}
public protocol ARViewDelegate : AnyObject {
  func didChange(tracking state: ARKit.ARCamera.TrackingState)
}
public protocol ARVideoDelegate : AnyObject {
  func didChanged(_ size: CoreFoundation.CGSize)
  func onVideoFrameUpdate(frameBuffer: CoreVideo.CVPixelBuffer, rotation: Swift.Int, timestamp: Swift.Int64)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class Pointer : LensCustomerSDK.Node {
  @_Concurrency.MainActor @preconcurrency public static let POINTER_NODE_NAME: Swift.String
  @_Concurrency.MainActor @preconcurrency public static let DEFAULT_BOX_HEIGHT: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public static let DEFAULT_BOX_WIDTH: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public static let DEFAULT_FADE_OUT_DELAY: Swift.Int
  @_Concurrency.MainActor @preconcurrency public static let DEFAULT_FADE_OUT_DURATION: Swift.Int
  @_Concurrency.MainActor @preconcurrency public static let DEFAULT_POINTER_SCALE: Swift.Float
  @_Concurrency.MainActor @preconcurrency public var fadeOutDelay: Swift.Int
  @_Concurrency.MainActor @preconcurrency public var fadeOutDuration: Swift.Int
  @_Concurrency.MainActor @preconcurrency public var currentDefaultScale: Swift.Float
  @_Concurrency.MainActor @preconcurrency final public let pointerColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public func updateScaleRelativeToCamera(camera: ARKit.ARCamera)
  @_Concurrency.MainActor @preconcurrency public func updateScaleRelativeToCamera(distanceToCamera distance: Swift.Float)
  @_Concurrency.MainActor @preconcurrency public static func constructPointerName(withId id: Swift.String) -> Swift.String
  @objc deinit
}
public protocol NodeStateChangeCallback {
  func onNodeDeleteRequested(node: LensCustomerSDK.Node)
}
extension LensCustomerSDK.LottieColor : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public enum ReducedMotionOption {
  case specific(LensCustomerSDK.ReducedMotionMode)
  case dynamic(any LensCustomerSDK.ReducedMotionOptionProvider, dataID: Swift.AnyHashable)
}
extension LensCustomerSDK.ReducedMotionOption {
  public static var standardMotion: LensCustomerSDK.ReducedMotionOption {
    get
  }
  public static var reducedMotion: LensCustomerSDK.ReducedMotionOption {
    get
  }
  public static var systemReducedMotionToggle: LensCustomerSDK.ReducedMotionOption {
    get
  }
}
extension LensCustomerSDK.ReducedMotionOption {
  public var currentReducedMotionMode: LensCustomerSDK.ReducedMotionMode {
    get
  }
}
extension LensCustomerSDK.ReducedMotionOption : Swift.Hashable {
  public static func == (lhs: LensCustomerSDK.ReducedMotionOption, rhs: LensCustomerSDK.ReducedMotionOption) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ReducedMotionMode : Swift.Hashable {
  case standardMotion
  case reducedMotion
  public static func == (a: LensCustomerSDK.ReducedMotionMode, b: LensCustomerSDK.ReducedMotionMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ReducedMotionOptionProvider {
  var currentReducedMotionMode: LensCustomerSDK.ReducedMotionMode { get }
}
public struct SystemReducedMotionOptionProvider : LensCustomerSDK.ReducedMotionOptionProvider {
  public init()
  public var currentReducedMotionMode: LensCustomerSDK.ReducedMotionMode {
    get
  }
}
public enum VMHTTPMethod : Swift.String {
  case post, get, put, delete
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum VMSessionError : Swift.String, Swift.Error {
  case invalidURLString, sessionNotConfigured
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum VMResponseType {
  case data, dictionary
  public static func == (a: LensCustomerSDK.VMResponseType, b: LensCustomerSDK.VMResponseType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class VMSessionManager {
  final public let requestSerialization: LensCustomerSDK.VMRequestSerialization
  final public let responseSerialization: LensCustomerSDK.VMResponseSerialization
  public typealias ApiSuccess = (_ data: Foundation.Data?, _ dictionary: [Swift.String : Any]?, _ response: Foundation.HTTPURLResponse) -> Swift.Void
  public typealias ApiFailure = ((any Swift.Error)?) -> Swift.Void
  public var session: LensCustomerSDK.VMSession {
    get
    set
  }
  public static var manager: LensCustomerSDK.VMSessionManager {
    get
  }
  public init(reqSer: LensCustomerSDK.VMRequestSerialization = VMRequestSerialization(), respSer: LensCustomerSDK.VMResponseSerialization = VMResponseSerialization(), config: Foundation.URLSessionConfiguration = .default)
  public func GET(API: Swift.String, requestSerialization: LensCustomerSDK.VMRequestSerialization? = nil, params: [Swift.String : Swift.String] = [:], success: @escaping LensCustomerSDK.VMSessionManager.ApiSuccess, failure: @escaping LensCustomerSDK.VMSessionManager.ApiFailure)
  public func PUT(API: Swift.String, requestSerialization: LensCustomerSDK.VMRequestSerialization? = nil, params: [Swift.String : Swift.String] = [:], success: @escaping LensCustomerSDK.VMSessionManager.ApiSuccess, failure: @escaping LensCustomerSDK.VMSessionManager.ApiFailure)
  public func DELETE(API: Swift.String, requestSerialization: LensCustomerSDK.VMRequestSerialization? = nil, params: [Swift.String : Swift.String] = [:], success: @escaping LensCustomerSDK.VMSessionManager.ApiSuccess, failure: @escaping LensCustomerSDK.VMSessionManager.ApiFailure)
  public func POST(API: Swift.String, requestSerialization: LensCustomerSDK.VMRequestSerialization? = nil, params: [Swift.String : Any] = [:], success: @escaping LensCustomerSDK.VMSessionManager.ApiSuccess, failure: @escaping LensCustomerSDK.VMSessionManager.ApiFailure)
  public func hitAPI(_ method: LensCustomerSDK.VMHTTPMethod, _ API: Swift.String, _ requestSerialization: LensCustomerSDK.VMRequestSerialization? = nil, _ params: [Swift.String : Any] = [:], _ success: @escaping LensCustomerSDK.VMSessionManager.ApiSuccess, _ failure: @escaping LensCustomerSDK.VMSessionManager.ApiFailure, _ requestConfiguration: ((Foundation.URLRequest) -> Swift.Void)? = nil)
  public func hitUploadAPI(_ method: LensCustomerSDK.VMHTTPMethod, httpBodyData: Foundation.Data, _ API: Swift.String, _ requestSerialization: LensCustomerSDK.VMRequestSerialization? = nil, _ params: [Swift.String : Any] = [:], _ success: @escaping LensCustomerSDK.VMSessionManager.ApiSuccess, _ failure: @escaping LensCustomerSDK.VMSessionManager.ApiFailure, _ requestConfiguration: ((Foundation.URLRequest) -> Swift.Void)? = nil)
  public func invalidCancelSession()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Asset : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  final public let id: Swift.String
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
extension LensCustomerSDK.Asset : @unchecked Swift.Sendable {
}
public enum LayerType : Swift.Int, Swift.Codable {
  case precomp
  case solid
  case image
  case null
  case shape
  case text
  case unknown
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum MatteType : Swift.Int, Swift.Codable {
  case none
  case add
  case invert
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum BlendMode : Swift.Int, Swift.Codable {
  case normal
  case multiply
  case screen
  case overlay
  case darken
  case lighten
  case colorDodge
  case colorBurn
  case hardLight
  case softLight
  case difference
  case exclusion
  case hue
  case saturation
  case color
  case luminosity
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension UIKit.UIColor {
  public var lottieColorValue: LensCustomerSDK.LottieColor {
    get
  }
}
extension UIKit.UITextField {
  @_Concurrency.MainActor @preconcurrency public var leftPading: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var placeHolderColor: UIKit.UIColor {
    get
    set
  }
}
extension QuartzCore.CALayer {
  @nonobjc public func logLayerTree(withIndent: Swift.Int = 0)
}
public class VMSession {
  public typealias dataSuccess = ((_ data: Foundation.Data, _ response: Foundation.HTTPURLResponse) -> Swift.Void)
  public typealias datafailure = (((any Swift.Error)?) -> Swift.Void)
  public init(config: Foundation.URLSessionConfiguration)
  public func invalidateAndCancel()
  public func dataTask(_ request: Foundation.URLRequest, success: @escaping LensCustomerSDK.VMSession.dataSuccess, failure: @escaping LensCustomerSDK.VMSession.datafailure)
  public func uploadTask()
  public func downloadTask(url: Foundation.URL)
  @objc deinit
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func adjustTableViewHeaderFrameIfNeeded()
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func scrollToLastIndexPath()
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public var isTableEmpty: Swift.Bool {
    get
  }
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func addNoDataView(noDataView: UIKit.UIView)
  @_Concurrency.MainActor @preconcurrency public func removenoDataView()
}
extension UIKit.UIImage {
  convenience public init?(color: UIKit.UIColor, size: CoreFoundation.CGSize = CGSize(width: 1, height: 1))
}
extension LensCustomerSDK.LottieAnimation {
  public typealias DownloadClosure = (LensCustomerSDK.LottieAnimation?) -> Swift.Void
  final public var duration: Foundation.TimeInterval {
    get
  }
  final public var bounds: CoreFoundation.CGRect {
    get
  }
  final public var size: CoreFoundation.CGSize {
    get
  }
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared) -> LensCustomerSDK.LottieAnimation?
  public static func filepath(_ filepath: Swift.String, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared) -> LensCustomerSDK.LottieAnimation?
  public static func asset(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared) -> LensCustomerSDK.LottieAnimation?
  public static func from(data: Foundation.Data, strategy: LensCustomerSDK.DecodingStrategy = LottieConfiguration.shared.decodingStrategy) throws -> LensCustomerSDK.LottieAnimation
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared) async -> LensCustomerSDK.LottieAnimation?
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, closure: @escaping LensCustomerSDK.LottieAnimation.DownloadClosure, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared)
  final public func progressTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationProgressTime?
  final public func frameTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationFrameTime?
  final public func durationFrameTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationFrameTime?
  final public func progressTime(forFrame frameTime: LensCustomerSDK.AnimationFrameTime, clamped: Swift.Bool = true) -> LensCustomerSDK.AnimationProgressTime
  final public func frameTime(forProgress progressTime: LensCustomerSDK.AnimationProgressTime) -> LensCustomerSDK.AnimationFrameTime
  final public func time(forFrame frameTime: LensCustomerSDK.AnimationFrameTime) -> Foundation.TimeInterval
  final public func frameTime(forTime time: Foundation.TimeInterval) -> LensCustomerSDK.AnimationFrameTime
}
extension Foundation.Bundle : @unchecked Swift.Sendable {
}
extension Foundation.Date {
  public static func today() -> Foundation.Date
  public func next(_ weekday: Foundation.Date.Weekday, considerToday: Swift.Bool = false) -> Foundation.Date
  public func previous(_ weekday: Foundation.Date.Weekday, considerToday: Swift.Bool = false) -> Foundation.Date
  public func get(_ direction: Foundation.Date.SearchDirection, _ weekDay: Foundation.Date.Weekday, considerToday consider: Swift.Bool = false) -> Foundation.Date
}
extension Foundation.Date {
  public func getWeekDaysInEnglish() -> [Swift.String]
  public enum Weekday : Swift.String {
    case monday, tuesday, wednesday, thursday, friday, saturday, sunday
    public init?(rawValue: Swift.String)
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum SearchDirection {
    case Next
    case Previous
    public static func == (a: Foundation.Date.SearchDirection, b: Foundation.Date.SearchDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Foundation.Date {
  public static func string(for date: Foundation.Date, format: Swift.String? = nil) -> Swift.String
  public func string(format: Swift.String? = nil) -> Swift.String
  public static func date(for string: Swift.String, format: Swift.String) -> Foundation.Date?
}
extension Foundation.Date {
  public func getString(mode: UIKit.UIDatePicker.Mode = .date, timeZone: Foundation.TimeZone = TimeZone.current) -> Swift.String
  public func getString(format: Swift.String) -> Swift.String
  public func at_getLocalizedString(_ mode: UIKit.UIDatePicker.Mode = .date) -> Swift.String
}
extension Foundation.Date {
  public var millisecondsSince1970: Swift.Int {
    get
  }
  public var randomID: Swift.String {
    get
  }
}
extension Foundation.Date {
  public func isSmallerThanGivenDateByDay(_ date: Foundation.Date) -> Swift.Bool
  public func isEqualDay(_ date: Foundation.Date) -> Swift.Bool
  public func isSmallerThanByMinutes(_ date: Foundation.Date) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class LottieAnimationViewBase : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didMoveToWindow()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public enum CoordinateSpace : Swift.Int, Swift.Codable, Swift.Sendable {
  case type2d
  case type3d
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class LottieAnimation : Swift.Codable, Swift.Sendable {
  required public init(from decoder: any Swift.Decoder) throws
  public init(dictionary: [Swift.String : Any]) throws
  final public let startFrame: LensCustomerSDK.AnimationFrameTime
  final public let endFrame: LensCustomerSDK.AnimationFrameTime
  final public let framerate: Swift.Double
  final public var markerNames: [Swift.String] {
    get
  }
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
extension UIKit.UIButton {
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var disabledTitle: Swift.String {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var disabledTitleColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var paddingX: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var paddingY: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
}
extension UIKit.UIButton {
  @_Concurrency.MainActor @preconcurrency public func setDefaultTitle(_ title: Swift.String, controlState states: [UIKit.UIControl.State] = [.normal, .highlighted])
  @_Concurrency.MainActor @preconcurrency public func setDefaultAttributtedTitle(_ title: Foundation.NSAttributedString, controlState states: [UIKit.UIControl.State] = [.normal, .highlighted])
}
public typealias Email = Swift.String
extension UIKit.UINavigationController {
  @_Concurrency.MainActor @preconcurrency public var prefersLargeTitles: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func makeTransparantNavigationBar(_ flag: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func makeColorNavigationBar(color: UIKit.UIColor, hideShadowImage: Swift.Bool = true)
}
public typealias LottieCompletionBlock = (_ completed: Swift.Bool) -> Swift.Void
final public class LottieLogger {
  public init(assert: @escaping LensCustomerSDK.LottieLogger.Assert = { condition, message, file, line in
       
       
       
      Swift.assert(condition(), message(), file: file, line: line)
    }, assertionFailure: @escaping LensCustomerSDK.LottieLogger.AssertionFailure = { message, file, line in
       
       
       
       
      Swift.assertionFailure(message(), file: file, line: line)
    }, warn: @escaping LensCustomerSDK.LottieLogger.Warn = { message, _, _ in
    }, info: @escaping LensCustomerSDK.LottieLogger.Info = { message in
    })
  public typealias Assert = (_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias AssertionFailure = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Warn = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Info = (_ message: @autoclosure () -> Swift.String) -> Swift.Void
  public static var shared: LensCustomerSDK.LottieLogger
  final public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func assertionFailure(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func warn(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func info(_ message: @autoclosure () -> Swift.String = String())
  @objc deinit
}
extension LensCustomerSDK.LottieLogger {
  public static var printToConsole: LensCustomerSDK.LottieLogger {
    get
  }
}
extension ObjectiveC.NSObject {
  public static func performInMainThread(_ block: @escaping () -> Swift.Void)
  public func performInMainThread(_ block: @escaping () -> Swift.Void)
  public enum AssistImpactFeedbackStyle {
    case medium, high, low, success, warning, error
    public static func == (a: ObjectiveC.NSObject.AssistImpactFeedbackStyle, b: ObjectiveC.NSObject.AssistImpactFeedbackStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public func makeTapTick(_ style: ObjectiveC.NSObject.AssistImpactFeedbackStyle)
  public static func makeTapTick(_ style: ObjectiveC.NSObject.AssistImpactFeedbackStyle)
}
@objc @_Concurrency.MainActor @preconcurrency open class AnimatedControl : LensCustomerSDK.LottieControlType {
  @_Concurrency.MainActor @preconcurrency public init(animation: LensCustomerSDK.LottieAnimation?, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func continueTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency open func animationDidSet()
  @_Concurrency.MainActor @preconcurrency final public let animationView: LensCustomerSDK.LottieAnimationView
  @_Concurrency.MainActor @preconcurrency public var animation: LensCustomerSDK.LottieAnimation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func setLayer(named: Swift.String, forState: LensCustomerSDK.LottieControlState)
  @_Concurrency.MainActor @preconcurrency public func setValueProvider(_ valueProvider: any LensCustomerSDK.AnyValueProvider, keypath: LensCustomerSDK.AnimationKeypath)
  @objc deinit
}
public let WebsocketDidConnectNotification: Swift.String
public let WebsocketDidDisconnectNotification: Swift.String
public let WebsocketDisconnectionErrorKeyName: Swift.String
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum ErrorType : Swift.Error {
  case outputStreamWriteError
  case compressionError
  case invalidSSLError
  case writeTimeoutError
  case protocolError
  case upgradeError
  case closeError
  public static func == (a: LensCustomerSDK.ErrorType, b: LensCustomerSDK.ErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct WSError : Swift.Error {
  public let type: LensCustomerSDK.ErrorType
  public let message: Swift.String
  public let code: Swift.Int
}
public protocol WebSocketClient : AnyObject {
  var delegate: (any LensCustomerSDK.WebSocketDelegate)? { get set }
  var pongDelegate: (any LensCustomerSDK.WebSocketPongDelegate)? { get set }
  var disableSSLCertValidation: Swift.Bool { get set }
  var overrideTrustHostname: Swift.Bool { get set }
  var desiredTrustHostname: Swift.String? { get set }
  var sslClientCertificate: LensCustomerSDK.SSLClientCertificate? { get set }
  var security: (any LensCustomerSDK.SSLTrustValidator)? { get set }
  var enabledSSLCipherSuites: [Security.SSLCipherSuite]? { get set }
  var isConnected: Swift.Bool { get }
  func connect()
  func disconnect(forceTimeout: Foundation.TimeInterval?, closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension LensCustomerSDK.WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public struct SSLSettings {
  public let useSSL: Swift.Bool
  public let disableCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public let sslClientCertificate: LensCustomerSDK.SSLClientCertificate?
  public let cipherSuites: [Security.SSLCipherSuite]?
}
public protocol WSStreamDelegate : AnyObject {
  func newBytesInStream()
  func streamDidError(error: (any Swift.Error)?)
}
public protocol WSStream {
  var delegate: (any LensCustomerSDK.WSStreamDelegate)? { get set }
  func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: LensCustomerSDK.SSLSettings, completion: @escaping (((any Swift.Error)?) -> Swift.Void))
  func write(data: Foundation.Data) -> Swift.Int
  func read() -> Foundation.Data?
  func cleanup()
  func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
}
@objc @_inheritsConvenienceInitializers open class FoundationStream : ObjectiveC.NSObject, LensCustomerSDK.WSStream, Foundation.StreamDelegate {
  weak public var delegate: (any LensCustomerSDK.WSStreamDelegate)?
  public var enableSOCKSProxy: Swift.Bool
  public func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: LensCustomerSDK.SSLSettings, completion: @escaping (((any Swift.Error)?) -> Swift.Void))
  public func write(data: Foundation.Data) -> Swift.Int
  public func read() -> Foundation.Data?
  public func cleanup()
  public func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
  @objc override dynamic public init()
  @objc deinit
}
public protocol WebSocketDelegate : AnyObject {
  func websocketDidConnect(socket: any LensCustomerSDK.WebSocketClient)
  func websocketDidDisconnect(socket: any LensCustomerSDK.WebSocketClient, error: (any Swift.Error)?)
  func websocketDidReceiveMessage(socket: any LensCustomerSDK.WebSocketClient, text: Swift.String)
  func websocketDidReceiveData(socket: any LensCustomerSDK.WebSocketClient, data: Foundation.Data)
}
public protocol WebSocketPongDelegate : AnyObject {
  func websocketDidReceivePong(socket: any LensCustomerSDK.WebSocketClient, data: Foundation.Data?)
}
public protocol WebSocketAdvancedDelegate : AnyObject {
  func websocketDidConnect(socket: LensCustomerSDK.WebSocket)
  func websocketDidDisconnect(socket: LensCustomerSDK.WebSocket, error: (any Swift.Error)?)
  func websocketDidReceiveMessage(socket: LensCustomerSDK.WebSocket, text: Swift.String, response: LensCustomerSDK.WebSocket.WSResponse)
  func websocketDidReceiveData(socket: LensCustomerSDK.WebSocket, data: Foundation.Data, response: LensCustomerSDK.WebSocket.WSResponse)
  func websocketHttpUpgrade(socket: LensCustomerSDK.WebSocket, request: Swift.String)
  func websocketHttpUpgrade(socket: LensCustomerSDK.WebSocket, response: Swift.String)
}
@objc open class WebSocket : ObjectiveC.NSObject, Foundation.StreamDelegate, LensCustomerSDK.WebSocketClient, LensCustomerSDK.WSStreamDelegate {
  public enum OpCode : Swift.UInt8 {
    case continueFrame
    case textFrame
    case binaryFrame
    case connectionClose
    case ping
    case pong
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public static let ErrorDomain: Swift.String
  public var callbackQueue: Dispatch.DispatchQueue
  @_hasMissingDesignatedInitializers public class WSResponse {
    public var code: LensCustomerSDK.WebSocket.OpCode
    public var frameCount: Swift.Int
    public var buffer: Foundation.NSMutableData?
    final public let firstFrame: Foundation.Date
    @objc deinit
  }
  weak public var delegate: (any LensCustomerSDK.WebSocketDelegate)?
  weak public var advancedDelegate: (any LensCustomerSDK.WebSocketAdvancedDelegate)?
  weak public var pongDelegate: (any LensCustomerSDK.WebSocketPongDelegate)?
  public var onConnect: (() -> Swift.Void)?
  public var onDisconnect: (((any Swift.Error)?) -> Swift.Void)?
  public var onText: ((Swift.String) -> Swift.Void)?
  public var onData: ((Foundation.Data) -> Swift.Void)?
  public var onPong: ((Foundation.Data?) -> Swift.Void)?
  public var onHttpResponseHeaders: (([Swift.String : Swift.String]) -> Swift.Void)?
  public var disableSSLCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public var sslClientCertificate: LensCustomerSDK.SSLClientCertificate?
  public var enableCompression: Swift.Bool
  public var security: (any LensCustomerSDK.SSLTrustValidator)?
  public var enabledSSLCipherSuites: [Security.SSLCipherSuite]?
  public var isConnected: Swift.Bool {
    get
  }
  public var request: Foundation.URLRequest
  public var currentURL: Foundation.URL {
    get
  }
  public var respondToPingWithPong: Swift.Bool
  public init(request: Foundation.URLRequest, protocols: [Swift.String]? = nil, stream: any LensCustomerSDK.WSStream = FoundationStream())
  convenience public init(url: Foundation.URL, protocols: [Swift.String]? = nil)
  convenience public init(url: Foundation.URL, writeQueueQOS: Foundation.QualityOfService, protocols: [Swift.String]? = nil)
  open func connect()
  open func disconnect(forceTimeout: Foundation.TimeInterval? = nil, closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  open func write(string: Swift.String, completion: (() -> ())? = nil)
  open func write(data: Foundation.Data, completion: (() -> ())? = nil)
  open func write(ping: Foundation.Data, completion: (() -> ())? = nil)
  open func write(pong: Foundation.Data, completion: (() -> ())? = nil)
  public func newBytesInStream()
  public func streamDidError(error: (any Swift.Error)?)
  @objc deinit
}
public protocol AnimationKeypathTextProvider : AnyObject {
  func text(for keypath: LensCustomerSDK.AnimationKeypath, sourceText: Swift.String) -> Swift.String?
}
@available(*, deprecated, message: "`AnimationKeypathTextProvider` has been deprecated and renamed to `LegacyAnimationTextProvider`. Instead, conform to `AnimationKeypathTextProvider` instead or conform to `LegacyAnimationTextProvider` explicitly.")
public typealias AnimationTextProvider = LensCustomerSDK.LegacyAnimationTextProvider
public protocol LegacyAnimationTextProvider : LensCustomerSDK.AnimationKeypathTextProvider {
  func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
}
extension LensCustomerSDK.LegacyAnimationTextProvider {
  public func text(for _: LensCustomerSDK.AnimationKeypath, sourceText _: Swift.String) -> Swift.String?
}
final public class DictionaryTextProvider : LensCustomerSDK.AnimationKeypathTextProvider, LensCustomerSDK.LegacyAnimationTextProvider {
  public init(_ values: [Swift.String : Swift.String])
  final public func text(for keypath: LensCustomerSDK.AnimationKeypath, sourceText: Swift.String) -> Swift.String?
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
extension LensCustomerSDK.DictionaryTextProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.DictionaryTextProvider, rhs: LensCustomerSDK.DictionaryTextProvider) -> Swift.Bool
}
final public class DefaultTextProvider : LensCustomerSDK.AnimationKeypathTextProvider, LensCustomerSDK.LegacyAnimationTextProvider {
  public init()
  final public func textFor(keypathName _: Swift.String, sourceText: Swift.String) -> Swift.String
  final public func text(for _: LensCustomerSDK.AnimationKeypath, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
extension LensCustomerSDK.DefaultTextProvider : Swift.Equatable {
  public static func == (_: LensCustomerSDK.DefaultTextProvider, _: LensCustomerSDK.DefaultTextProvider) -> Swift.Bool
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func addBackgroundLottie(_ lottieType: any LensCustomerSDK.LottieType, customView: UIKit.UIView? = nil, actionButtonConfiguration: ((UIKit.UIButton) -> (() -> Swift.Void))? = nil)
  @_Concurrency.MainActor @preconcurrency public func updateBackgroundLottie()
  @_Concurrency.MainActor @preconcurrency public var isBackgroundLottiePlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func removeBackgroundLottie()
}
extension Foundation.FileManager {
  public static var documentDirURL: Foundation.URL? {
    get
  }
}
public struct LottieVector1D : Swift.Hashable, Swift.Sendable {
  public init(_ value: Swift.Double)
  public let value: Swift.Double
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.LottieVector1D, b: LensCustomerSDK.LottieVector1D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct LottieVector3D : Swift.Hashable, Swift.Sendable {
  public let x: Swift.Double
  public let y: Swift.Double
  public let z: Swift.Double
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.LottieVector3D, b: LensCustomerSDK.LottieVector3D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@objc final public class CompatibleAnimation : ObjectiveC.NSObject {
  @objc public init(name: Swift.String, subdirectory: Swift.String? = nil, bundle: Foundation.Bundle = Bundle.main)
  @objc deinit
}
@objc public enum CompatibleRenderingEngineOption : Swift.Int {
  case shared
  case defaultEngine
  case automatic
  case mainThread
  case coreAnimation
  public static func generateLottieConfiguration(_ configuration: LensCustomerSDK.CompatibleRenderingEngineOption) -> LensCustomerSDK.LottieConfiguration
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum CompatibleBackgroundBehavior : Swift.Int {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  case continuePlaying
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor @preconcurrency final public class CompatibleAnimationView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(compatibleAnimation: LensCustomerSDK.CompatibleAnimation)
  @objc @_Concurrency.MainActor @preconcurrency public init(compatibleAnimation: LensCustomerSDK.CompatibleAnimation, compatibleRenderingEngineOption: LensCustomerSDK.CompatibleRenderingEngineOption)
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(url: Foundation.URL)
  @objc @_Concurrency.MainActor @preconcurrency public init(url: Foundation.URL, compatibleRenderingEngineOption: LensCustomerSDK.CompatibleRenderingEngineOption)
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(data: Foundation.Data)
  @objc @_Concurrency.MainActor @preconcurrency public init(data: Foundation.Data, compatibleRenderingEngineOption: LensCustomerSDK.CompatibleRenderingEngineOption)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor @preconcurrency final public var compatibleAnimation: LensCustomerSDK.CompatibleAnimation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var loopAnimationCount: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var compatibleDictionaryTextProvider: LensCustomerSDK.CompatibleDictionaryTextProvider? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var shouldRasterizeWhenIdle: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentProgress: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var duration: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentFrame: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationFrame: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationProgress: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var animationSpeed: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var respectAnimationFrameRate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var isAnimationPlaying: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var backgroundMode: LensCustomerSDK.CompatibleBackgroundBehavior {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public func play()
  @objc @_Concurrency.MainActor @preconcurrency final public func play(completion: ((Swift.Bool) -> Swift.Void)?)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromProgress: CoreFoundation.CGFloat, toProgress: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromFrame: CoreFoundation.CGFloat, toFrame: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromMarker: Swift.String, toMarker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(marker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func stop()
  @objc @_Concurrency.MainActor @preconcurrency final public func pause()
  @objc @_Concurrency.MainActor @preconcurrency final public func reloadImages()
  @objc @_Concurrency.MainActor @preconcurrency final public func forceDisplayUpdate()
  @objc @_Concurrency.MainActor @preconcurrency final public func getValue(for keypath: LensCustomerSDK.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> Any?
  @objc @_Concurrency.MainActor @preconcurrency final public func logHierarchyKeypaths()
  @objc @_Concurrency.MainActor @preconcurrency final public func setColorValue(_ color: UIKit.UIColor, forKeypath keypath: LensCustomerSDK.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor @preconcurrency final public func getColorValue(for keypath: LensCustomerSDK.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> UIKit.UIColor?
  @objc @_Concurrency.MainActor @preconcurrency final public func addSubview(_ subview: LensCustomerSDK.AnimationSubview, forLayerAt keypath: LensCustomerSDK.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(rect: CoreFoundation.CGRect, toLayerAt keypath: LensCustomerSDK.CompatibleAnimationKeypath?) -> CoreFoundation.CGRect
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(point: CoreFoundation.CGPoint, toLayerAt keypath: LensCustomerSDK.CompatibleAnimationKeypath?) -> CoreFoundation.CGPoint
  @objc @_Concurrency.MainActor @preconcurrency final public func progressTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency final public func frameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency final public func durationFrameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc deinit
}
@objc final public class CompatibleDictionaryTextProvider : ObjectiveC.NSObject {
  @objc public init(values: [Swift.String : Swift.String])
  @objc deinit
}
public enum RenderingEngineOption : Swift.Hashable {
  case automatic
  case specific(LensCustomerSDK.RenderingEngine)
  public static var mainThread: LensCustomerSDK.RenderingEngineOption {
    get
  }
  public static var coreAnimation: LensCustomerSDK.RenderingEngineOption {
    get
  }
}
public enum RenderingEngine : Swift.Hashable {
  case mainThread
  case coreAnimation
}
extension LensCustomerSDK.RenderingEngineOption : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension LensCustomerSDK.RenderingEngine : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public class BundleImageProvider : LensCustomerSDK.AnimationImageProvider {
  public init(bundle: Foundation.Bundle, searchPath: Swift.String?, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public func imageForAsset(asset: LensCustomerSDK.ImageAsset) -> CoreGraphics.CGImage?
  public func contentsGravity(for _: LensCustomerSDK.ImageAsset) -> QuartzCore.CALayerContentsGravity
  @objc deinit
}
extension LensCustomerSDK.BundleImageProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.BundleImageProvider, rhs: LensCustomerSDK.BundleImageProvider) -> Swift.Bool
}
public struct SSLClientCertificateError : Foundation.LocalizedError {
  public var errorDescription: Swift.String?
}
public class SSLClientCertificate {
  convenience public init(pkcs12Path: Swift.String, password: Swift.String) throws
  public init(identity: Security.SecIdentity, identityCertificate: Security.SecCertificate)
  convenience public init(pkcs12Url: Foundation.URL, password: Swift.String) throws
  public init(pkcs12Url: Foundation.URL, importOptions: CoreFoundation.CFDictionary) throws
  @objc deinit
}
@available(*, deprecated, message: "Use DefaultAnimationCache instead, which is thread-safe and automatically responds to memory pressure.")
public typealias LRUAnimationCache = LensCustomerSDK.DefaultAnimationCache
@_Concurrency.MainActor @preconcurrency public struct LottieView<Placeholder> where Placeholder : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(animation: LensCustomerSDK.LottieAnimation?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(dotLottieFile: LensCustomerSDK.DotLottieFile?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> LensCustomerSDK.LottieAnimation?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> LensCustomerSDK.LottieAnimation?, @SwiftUICore.ViewBuilder placeholder: @escaping (() -> Placeholder))
  @_Concurrency.MainActor @preconcurrency public init(_ loadDotLottieFile: @escaping () async throws -> LensCustomerSDK.DotLottieFile?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadDotLottieFile: @escaping () async throws -> LensCustomerSDK.DotLottieFile?, @SwiftUICore.ViewBuilder placeholder: @escaping (() -> Placeholder))
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> LensCustomerSDK.LottieAnimationSource?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> LensCustomerSDK.LottieAnimationSource?, @SwiftUICore.ViewBuilder placeholder: @escaping () -> Placeholder)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure<Property>(_ property: Swift.ReferenceWritableKeyPath<LensCustomerSDK.LottieAnimationView, Property>, to value: Property) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func configure<Property>(_ property: Swift.ReferenceWritableKeyPath<LensCustomerSDK.LottieAnimationView, Property>, to value: Property) -> LensCustomerSDK.LottieView<Placeholder> where Property : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func configure(_ configure: @escaping (LensCustomerSDK.LottieAnimationView) -> Swift.Void) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func resizable() -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func intrinsicSize() -> LensCustomerSDK.LottieView<Placeholder>
  @available(*, deprecated, renamed: "playing()", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency public func play() -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func looping() -> LensCustomerSDK.LottieView<Placeholder>
  @available(*, deprecated, renamed: "playing(_:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency public func play(loopMode: LensCustomerSDK.LottieLoopMode = .playOnce) -> LensCustomerSDK.LottieView<Placeholder>
  @available(*, deprecated, renamed: "playbackMode(_:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency public func play(_ playbackMode: LensCustomerSDK.LottiePlaybackMode) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playing(_ mode: LensCustomerSDK.LottiePlaybackMode.PlaybackMode) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playing(loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playing() -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func paused(at state: LensCustomerSDK.LottiePlaybackMode.PausedState = .currentFrame) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playbackMode(_ playbackMode: LensCustomerSDK.LottiePlaybackMode) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func animationSpeed(_ animationSpeed: Swift.Double) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func animationDidLoad(_ animationDidLoad: @escaping (LensCustomerSDK.LottieAnimationSource) -> Swift.Void) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func animationDidFinish(_ animationCompletionHandler: LensCustomerSDK.LottieCompletionBlock?) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func backgroundBehavior(_ value: LensCustomerSDK.LottieBackgroundBehavior) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func accessibilityLabel(_ accessibilityLabel: Swift.String?) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func configuration(_ configuration: LensCustomerSDK.LottieConfiguration) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func logger(_ logger: LensCustomerSDK.LottieLogger) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func imageProvider<ImageProvider>(_ imageProvider: ImageProvider) -> LensCustomerSDK.LottieView<Placeholder> where ImageProvider : LensCustomerSDK.AnimationImageProvider, ImageProvider : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func textProvider<TextProvider>(_ textProvider: TextProvider) -> LensCustomerSDK.LottieView<Placeholder> where TextProvider : LensCustomerSDK.AnimationKeypathTextProvider, TextProvider : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func fontProvider<FontProvider>(_ fontProvider: FontProvider) -> LensCustomerSDK.LottieView<Placeholder> where FontProvider : LensCustomerSDK.AnimationFontProvider, FontProvider : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func valueProvider<ValueProvider>(_ valueProvider: ValueProvider, for keypath: LensCustomerSDK.AnimationKeypath) -> LensCustomerSDK.LottieView<Placeholder> where ValueProvider : LensCustomerSDK.AnyValueProvider, ValueProvider : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func currentProgress(_ currentProgress: LensCustomerSDK.AnimationProgressTime?) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func currentFrame(_ currentFrame: LensCustomerSDK.AnimationFrameTime?) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func currentTime(_ currentTime: Foundation.TimeInterval?) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func reloadAnimationTrigger(_ value: some Equatable, showPlaceholder: Swift.Bool = true) -> LensCustomerSDK.LottieView<Placeholder>
  @available(iOS 15.0, tvOS 15.0, macOS 12.0, *)
  @_Concurrency.MainActor @preconcurrency public func getRealtimeAnimationProgress(_ realtimeAnimationProgress: SwiftUICore.Binding<LensCustomerSDK.AnimationProgressTime>?) -> some SwiftUICore.View
  
  @available(iOS 15.0, tvOS 15.0, macOS 12.0, *)
  @_Concurrency.MainActor @preconcurrency public func getRealtimeAnimationFrame(_ realtimeAnimationFrame: SwiftUICore.Binding<LensCustomerSDK.AnimationFrameTime>?) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func dotLottieConfigurationComponents(_ dotLottieConfigurationComponents: LensCustomerSDK.DotLottieConfigurationComponents) -> LensCustomerSDK.LottieView<Placeholder>
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s15LensCustomerSDK10LottieViewV4bodyQrvp", 0) __<Placeholder>
}
final public class SizeValueProvider {
  public init(block: @escaping LensCustomerSDK.SizeValueProvider.SizeValueBlock)
  public init(_ size: CoreFoundation.CGSize)
  public typealias SizeValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  final public var size: CoreFoundation.CGSize {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: LensCustomerSDK.ValueProviderStorage<LensCustomerSDK.LottieVector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.SizeValueProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.SizeValueProvider, rhs: LensCustomerSDK.SizeValueProvider) -> Swift.Bool
}
extension Swift.Bool {
  public var rawValue: Swift.String {
    get
  }
  public var intValue: Swift.Int {
    get
  }
}
@objc @_hasMissingDesignatedInitializers public class LottieAnimationLayer : QuartzCore.CALayer {
  public init(animation: LensCustomerSDK.LottieAnimation?, imageProvider: (any LensCustomerSDK.AnimationImageProvider)? = nil, textProvider: any LensCustomerSDK.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any LensCustomerSDK.AnimationFontProvider = DefaultFontProvider(), configuration: LensCustomerSDK.LottieConfiguration = .shared, logger: LensCustomerSDK.LottieLogger = .shared)
  public init(dotLottie: LensCustomerSDK.DotLottieFile?, animationId: Swift.String? = nil, textProvider: any LensCustomerSDK.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any LensCustomerSDK.AnimationFontProvider = DefaultFontProvider(), configuration: LensCustomerSDK.LottieConfiguration = .shared, logger: LensCustomerSDK.LottieLogger = .shared)
  public init(configuration: LensCustomerSDK.LottieConfiguration = .shared, logger: LensCustomerSDK.LottieLogger = .shared)
  open func play(completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func play(fromProgress: LensCustomerSDK.AnimationProgressTime? = nil, toProgress: LensCustomerSDK.AnimationProgressTime, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func play(fromFrame: LensCustomerSDK.AnimationFrameTime? = nil, toFrame: LensCustomerSDK.AnimationFrameTime, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func play(marker: Swift.String, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func play(markers: [Swift.String], completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func stop()
  open func pause()
  open func pause(at state: LensCustomerSDK.LottiePlaybackMode.PausedState)
  @available(*, deprecated, renamed: "setPlaybackMode(_:completion:)", message: "Will be removed in a future major release.")
  open func play(_ playbackMode: LensCustomerSDK.LottiePlaybackMode, animationCompletionHandler: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func setPlaybackMode(_ playbackMode: LensCustomerSDK.LottiePlaybackMode, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func play(_ playbackMode: LensCustomerSDK.LottiePlaybackMode.PlaybackMode, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  public var currentPlaybackMode: LensCustomerSDK.LottiePlaybackMode? {
    get
  }
  public var valueProviders: [LensCustomerSDK.AnimationKeypath : any LensCustomerSDK.AnyValueProvider] {
    get
  }
  public var animationLayerDidLoad: ((_ animationLayer: LensCustomerSDK.LottieAnimationLayer, _ renderingEngine: LensCustomerSDK.RenderingEngineOption) -> Swift.Void)?
  public var configuration: LensCustomerSDK.LottieConfiguration {
    get
    set
  }
  public var animationLayer: QuartzCore.CALayer? {
    get
  }
  public var screenScale: CoreFoundation.CGFloat {
    get
    set
  }
  public var backgroundBehavior: LensCustomerSDK.LottieBackgroundBehavior {
    get
    set
  }
  public var animation: LensCustomerSDK.LottieAnimation? {
    get
    set
  }
  public var animationLoaded: ((_ animationLayer: LensCustomerSDK.LottieAnimationLayer, _ animation: LensCustomerSDK.LottieAnimation) -> Swift.Void)? {
    get
    set
  }
  public var imageProvider: any LensCustomerSDK.AnimationImageProvider {
    get
    set
  }
  public var textProvider: any LensCustomerSDK.AnimationKeypathTextProvider {
    get
    set
  }
  public var fontProvider: any LensCustomerSDK.AnimationFontProvider {
    get
    set
  }
  public var maskAnimationToBounds: Swift.Bool {
    get
    set
  }
  public var isAnimationPlaying: Swift.Bool {
    get
  }
  public var loopMode: LensCustomerSDK.LottieLoopMode {
    get
    set
  }
  public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  public var currentProgress: LensCustomerSDK.AnimationProgressTime {
    get
    set
  }
  public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  public var currentFrame: LensCustomerSDK.AnimationFrameTime {
    get
    set
  }
  public var realtimeAnimationFrame: LensCustomerSDK.AnimationFrameTime {
    get
  }
  public var realtimeAnimationProgress: LensCustomerSDK.AnimationProgressTime {
    get
  }
  public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  public var currentRenderingEngine: LensCustomerSDK.RenderingEngine? {
    get
  }
  public var mainThreadRenderingEngineShouldForceDisplayUpdateOnEachFrame: Swift.Bool {
    get
    set
  }
  public func loadAnimation(_ animationId: Swift.String? = nil, from dotLottieFile: LensCustomerSDK.DotLottieFile)
  public func loadAnimation(atIndex index: Swift.Int, from dotLottieFile: LensCustomerSDK.DotLottieFile)
  public func reloadImages()
  public func forceDisplayUpdate()
  public func setValueProvider(_ valueProvider: any LensCustomerSDK.AnyValueProvider, keypath: LensCustomerSDK.AnimationKeypath)
  public func getValue(for keypath: LensCustomerSDK.AnimationKeypath, atFrame: LensCustomerSDK.AnimationFrameTime?) -> Any?
  public func getOriginalValue(for keypath: LensCustomerSDK.AnimationKeypath, atFrame: LensCustomerSDK.AnimationFrameTime?) -> Any?
  public func logHierarchyKeypaths()
  public func allHierarchyKeypaths() -> [Swift.String]
  public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: LensCustomerSDK.AnimationKeypath?) -> CoreFoundation.CGRect?
  public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: LensCustomerSDK.AnimationKeypath?) -> CoreFoundation.CGPoint?
  public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: LensCustomerSDK.AnimationKeypath)
  public func progressTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationProgressTime?
  public func frameTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationFrameTime?
  public func durationFrameTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationFrameTime?
  public func updateAnimationForBackgroundState()
  public func updateAnimationForForegroundState(wasWaitingToPlayAnimation: Swift.Bool)
  @objc deinit
}
public class FilepathImageProvider : LensCustomerSDK.AnimationImageProvider {
  public init(filepath: Swift.String, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public init(filepath: Foundation.URL, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public func imageForAsset(asset: LensCustomerSDK.ImageAsset) -> CoreGraphics.CGImage?
  public func contentsGravity(for _: LensCustomerSDK.ImageAsset) -> QuartzCore.CALayerContentsGravity
  @objc deinit
}
extension LensCustomerSDK.FilepathImageProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.FilepathImageProvider, rhs: LensCustomerSDK.FilepathImageProvider) -> Swift.Bool
}
public enum LottiePlaybackMode : Swift.Hashable {
  case paused(at: LensCustomerSDK.LottiePlaybackMode.PausedState)
  case playing(_: LensCustomerSDK.LottiePlaybackMode.PlaybackMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case progress(_: LensCustomerSDK.AnimationProgressTime)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case frame(_: LensCustomerSDK.AnimationFrameTime)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case time(_: Foundation.TimeInterval)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case pause
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromProgress(_: LensCustomerSDK.AnimationProgressTime?, toProgress: LensCustomerSDK.AnimationProgressTime, loopMode: LensCustomerSDK.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromFrame(_: LensCustomerSDK.AnimationFrameTime?, toFrame: LensCustomerSDK.AnimationFrameTime, loopMode: LensCustomerSDK.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromMarker(_: Swift.String?, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: LensCustomerSDK.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case marker(_: Swift.String, loopMode: LensCustomerSDK.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case markers(_: [Swift.String])
  public enum PausedState : Swift.Hashable {
    case currentFrame
    case progress(_: LensCustomerSDK.AnimationProgressTime)
    case frame(_: LensCustomerSDK.AnimationFrameTime)
    case time(_: Foundation.TimeInterval)
    case marker(_: Swift.String, position: LensCustomerSDK.LottieMarkerPosition = .start)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: LensCustomerSDK.LottiePlaybackMode.PausedState, b: LensCustomerSDK.LottiePlaybackMode.PausedState) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum PlaybackMode : Swift.Hashable {
    case fromProgress(_: LensCustomerSDK.AnimationProgressTime?, toProgress: LensCustomerSDK.AnimationProgressTime, loopMode: LensCustomerSDK.LottieLoopMode)
    case fromFrame(_: LensCustomerSDK.AnimationFrameTime?, toFrame: LensCustomerSDK.AnimationFrameTime, loopMode: LensCustomerSDK.LottieLoopMode)
    case fromMarker(_: Swift.String?, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: LensCustomerSDK.LottieLoopMode)
    case marker(_: Swift.String, loopMode: LensCustomerSDK.LottieLoopMode)
    case markers(_: [Swift.String])
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: LensCustomerSDK.LottiePlaybackMode.PlaybackMode, b: LensCustomerSDK.LottiePlaybackMode.PlaybackMode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.LottiePlaybackMode, b: LensCustomerSDK.LottiePlaybackMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LensCustomerSDK.LottiePlaybackMode {
  public static var paused: LensCustomerSDK.LottiePlaybackMode {
    get
  }
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toProgress(_ toProgress: LensCustomerSDK.AnimationProgressTime, loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottiePlaybackMode
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toFrame(_ toFrame: LensCustomerSDK.AnimationFrameTime, loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottiePlaybackMode
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toMarker(_ toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottiePlaybackMode
}
extension LensCustomerSDK.LottiePlaybackMode.PlaybackMode {
  public static func toProgress(_ toProgress: LensCustomerSDK.AnimationProgressTime, loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottiePlaybackMode.PlaybackMode
  public static func toFrame(_ toFrame: LensCustomerSDK.AnimationFrameTime, loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottiePlaybackMode.PlaybackMode
  public static func toMarker(_ toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottiePlaybackMode.PlaybackMode
}
public enum LottieMarkerPosition : Swift.Hashable {
  case start
  case end
  public static func == (a: LensCustomerSDK.LottieMarkerPosition, b: LensCustomerSDK.LottieMarkerPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency public func addChildren(viewController: UIKit.UIViewController, containerView: UIKit.UIView? = nil, isSafeArea: Swift.Bool = false)
}
public typealias AnimationFrameTime = CoreFoundation.CGFloat
public typealias AnimationProgressTime = CoreFoundation.CGFloat
@_hasMissingDesignatedInitializers public class VMJsonManager {
  public class func convertToDictionary(text: Swift.String) -> [Swift.String : Any]?
  public class func data(jsonObject: Any) -> Foundation.Data?
  public class func formData(jsonObject: [Swift.String : Any]?) -> Foundation.Data?
  public class func json(data: Foundation.Data) -> Any
  public class func isValid(json: Any) -> Swift.Bool
  @objc deinit
}
public protocol SSLTrustValidator {
  func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
}
open class SSLCert {
  public init(data: Foundation.Data)
  public init(key: Security.SecKey)
  @objc deinit
}
open class SSLSecurity : LensCustomerSDK.SSLTrustValidator {
  public var validatedDN: Swift.Bool
  public var validateEntireChain: Swift.Bool
  convenience public init(usePublicKeys: Swift.Bool = false)
  public init(certs: [LensCustomerSDK.SSLCert], usePublicKeys: Swift.Bool)
  open func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
  public func extractPublicKey(_ data: Foundation.Data) -> Security.SecKey?
  public func extractPublicKey(_ cert: Security.SecCertificate, policy: Security.SecPolicy) -> Security.SecKey?
  public func certificateChain(_ trust: Security.SecTrust) -> [Foundation.Data]
  public func publicKeyChain(_ trust: Security.SecTrust) -> [Security.SecKey]
  @objc deinit
}
public enum LottieBackgroundBehavior {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  case continuePlaying
  public static func `default`(for renderingEngine: LensCustomerSDK.RenderingEngine) -> LensCustomerSDK.LottieBackgroundBehavior
  public static func == (a: LensCustomerSDK.LottieBackgroundBehavior, b: LensCustomerSDK.LottieBackgroundBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LottieLoopMode : Swift.Hashable {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LensCustomerSDK.LottieLoopMode : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.LottieLoopMode, rhs: LensCustomerSDK.LottieLoopMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor @preconcurrency open class LottieAnimationView : LensCustomerSDK.LottieAnimationViewBase {
  @_Concurrency.MainActor @preconcurrency public init(animation: LensCustomerSDK.LottieAnimation?, imageProvider: (any LensCustomerSDK.AnimationImageProvider)? = nil, textProvider: any LensCustomerSDK.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any LensCustomerSDK.AnimationFontProvider = DefaultFontProvider(), configuration: LensCustomerSDK.LottieConfiguration = .shared, logger: LensCustomerSDK.LottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency public init(dotLottie: LensCustomerSDK.DotLottieFile?, animationId: Swift.String? = nil, textProvider: any LensCustomerSDK.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any LensCustomerSDK.AnimationFontProvider = DefaultFontProvider(), configuration: LensCustomerSDK.LottieConfiguration = .shared, logger: LensCustomerSDK.LottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency public init(configuration: LensCustomerSDK.LottieConfiguration = .shared, logger: LensCustomerSDK.LottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency open func play(_ mode: LensCustomerSDK.LottiePlaybackMode.PlaybackMode, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(fromProgress: LensCustomerSDK.AnimationProgressTime? = nil, toProgress: LensCustomerSDK.AnimationProgressTime, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(fromFrame: LensCustomerSDK.AnimationFrameTime? = nil, toFrame: LensCustomerSDK.AnimationFrameTime, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(marker: Swift.String, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(markers: [Swift.String], completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func stop()
  @_Concurrency.MainActor @preconcurrency open func pause()
  @available(*, deprecated, renamed: "setPlaybackMode(_:completion:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency open func play(_ playbackMode: LensCustomerSDK.LottiePlaybackMode, animationCompletionHandler: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func setPlaybackMode(_ playbackMode: LensCustomerSDK.LottiePlaybackMode, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency public var animateLayoutChangesWithCurrentCoreAnimationContext: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var configuration: LensCustomerSDK.LottieConfiguration {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var valueProviders: [LensCustomerSDK.AnimationKeypath : any LensCustomerSDK.AnyValueProvider] {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var backgroundBehavior: LensCustomerSDK.LottieBackgroundBehavior {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animation: LensCustomerSDK.LottieAnimation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animationLoaded: ((_ animationView: LensCustomerSDK.LottieAnimationView, _ animation: LensCustomerSDK.LottieAnimation) -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var imageProvider: any LensCustomerSDK.AnimationImageProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var textProvider: any LensCustomerSDK.AnimationKeypathTextProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var fontProvider: any LensCustomerSDK.AnimationFontProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var maskAnimationToBounds: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var isAnimationPlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var isAnimationQueued: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var loopMode: LensCustomerSDK.LottieLoopMode {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentProgress: LensCustomerSDK.AnimationProgressTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentFrame: LensCustomerSDK.AnimationFrameTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var realtimeAnimationFrame: LensCustomerSDK.AnimationFrameTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var realtimeAnimationProgress: LensCustomerSDK.AnimationProgressTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var viewportFrame: CoreFoundation.CGRect? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency public var currentRenderingEngine: LensCustomerSDK.RenderingEngine? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var currentPlaybackMode: LensCustomerSDK.LottiePlaybackMode? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var mainThreadRenderingEngineShouldForceDisplayUpdateOnEachFrame: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func loadAnimation(_ animationId: Swift.String? = nil, from dotLottieFile: LensCustomerSDK.DotLottieFile)
  @_Concurrency.MainActor @preconcurrency public func loadAnimation(atIndex index: Swift.Int, from dotLottieFile: LensCustomerSDK.DotLottieFile)
  @_Concurrency.MainActor @preconcurrency public func reloadImages()
  @_Concurrency.MainActor @preconcurrency public func forceDisplayUpdate()
  @_Concurrency.MainActor @preconcurrency public func setValueProvider(_ valueProvider: any LensCustomerSDK.AnyValueProvider, keypath: LensCustomerSDK.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public func getValue(for keypath: LensCustomerSDK.AnimationKeypath, atFrame: LensCustomerSDK.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor @preconcurrency public func getOriginalValue(for keypath: LensCustomerSDK.AnimationKeypath, atFrame: LensCustomerSDK.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor @preconcurrency public func logHierarchyKeypaths()
  @_Concurrency.MainActor @preconcurrency public func allHierarchyKeypaths() -> [Swift.String]
  @_Concurrency.MainActor @preconcurrency public func addSubview(_ subview: LensCustomerSDK.AnimationSubview, forLayerAt keypath: LensCustomerSDK.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: LensCustomerSDK.AnimationKeypath?) -> CoreFoundation.CGRect?
  @_Concurrency.MainActor @preconcurrency public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: LensCustomerSDK.AnimationKeypath?) -> CoreFoundation.CGPoint?
  @_Concurrency.MainActor @preconcurrency public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: LensCustomerSDK.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public func progressTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationProgressTime?
  @_Concurrency.MainActor @preconcurrency public func frameTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationFrameTime?
  @_Concurrency.MainActor @preconcurrency public func durationFrameTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationFrameTime?
  @objc deinit
}
public class DotLottieCache : LensCustomerSDK.DotLottieCacheProvider {
  public init()
  public static let sharedCache: LensCustomerSDK.DotLottieCache
  public var cacheSize: Swift.Int {
    get
    set
  }
  public func clearCache()
  public func file(forKey key: Swift.String) -> LensCustomerSDK.DotLottieFile?
  public func setFile(_ lottie: LensCustomerSDK.DotLottieFile, forKey key: Swift.String)
  @objc deinit
}
extension LensCustomerSDK.DotLottieCache : @unchecked Swift.Sendable {
}
public protocol AnimationCacheProvider : AnyObject, Swift.Sendable {
  func animation(forKey: Swift.String) -> LensCustomerSDK.LottieAnimation?
  func setAnimation(_ animation: LensCustomerSDK.LottieAnimation, forKey: Swift.String)
  func clearCache()
}
extension Foundation.TimeZone {
  public func hoursFromGMT() -> Swift.String
  public func hoursFromGMTWithSign() -> Swift.String
}
@_Concurrency.MainActor @preconcurrency public struct LottieButton {
  @_Concurrency.MainActor @preconcurrency public init(animation: LensCustomerSDK.LottieAnimation?, action: @escaping () -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure(_ configure: @escaping (LensCustomerSDK.AnimatedButton) -> Swift.Void) -> LensCustomerSDK.LottieButton
  @_Concurrency.MainActor @preconcurrency public func configuration(_ configuration: LensCustomerSDK.LottieConfiguration) -> LensCustomerSDK.LottieButton
  @_Concurrency.MainActor @preconcurrency public func animate(fromProgress: LensCustomerSDK.AnimationProgressTime, toProgress: LensCustomerSDK.AnimationProgressTime, on event: LensCustomerSDK.LottieControlEvent) -> LensCustomerSDK.LottieButton
  @_Concurrency.MainActor @preconcurrency public func animate(fromMarker: Swift.String, toMarker: Swift.String, on event: LensCustomerSDK.LottieControlEvent) -> LensCustomerSDK.LottieButton
  @_Concurrency.MainActor @preconcurrency public func valueProvider<ValueProvider>(_ valueProvider: ValueProvider, for keypath: LensCustomerSDK.AnimationKeypath) -> LensCustomerSDK.LottieButton where ValueProvider : LensCustomerSDK.AnyValueProvider, ValueProvider : Swift.Equatable
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s15LensCustomerSDK12LottieButtonV4bodyQrvp", 0) __
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ImageAsset : LensCustomerSDK.Asset {
  final public let name: Swift.String
  final public let directory: Swift.String
  final public let width: Swift.Double
  final public let height: Swift.Double
  override final public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func makeCornerRadius(with value: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency public func makeBlendEdge(withPoint: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency public func makeBlendEdge(heightDevideBy: CoreFoundation.CGFloat = 06)
  @_Concurrency.MainActor @preconcurrency public var isCircle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func layoutIfNeededWithAnimation()
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var safeAreaInsets_Below11Also: UIKit.UIEdgeInsets {
    get
  }
}
extension UIKit.UIView {
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var atCornerRadius: CoreFoundation.CGFloat {
    @objc get
    @objc set(newValue)
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var atBorderColor: UIKit.UIColor? {
    @objc get
    @objc set(newValue)
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var borderWidth: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var shadowRadius: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var shadowColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var shadowOpacity: Swift.Float {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var shadowOffset: CoreFoundation.CGSize {
    @objc get
    @objc set
  }
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func makeSecure()
}
public protocol AssistSocketProtocol : AnyObject {
  func didSocketConnected()
  func didSocketDisconnected(_ error: (any Swift.Error)?)
  func didReceive(_ data: Foundation.Data)
  func didReceive(_ string: Swift.String)
  func custom_socket(call_back listerner: any LensCustomerSDK.WebSocketCallBack) -> (any LensCustomerSDK.WebSocketProtocol)?
  var canReceiveData: Swift.Bool { get set }
}
public protocol WebSocketCallBack : AnyObject {
  func onConnect()
  func onDisconnect(error: (any Swift.Error)?)
  func onTextReceive(_ text: Swift.String)
  func onDataReceive(_ data: Foundation.Data)
}
public protocol WebSocketProtocol : AnyObject {
  var disableSSLCertValidation: Swift.Bool { get set }
  var is_connected: Swift.Bool { get }
  func disconnect()
  func write(data: Foundation.Data)
  func write(string: Swift.String)
  func connect(websocket url: Foundation.URLRequest)
  func lostNetwork()
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor @preconcurrency public var isIPad: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var isHighResIPad: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var modelName: Swift.String {
    get
  }
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor @preconcurrency public var isIPhone5: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var isMaxOrPlusDevice: Swift.Bool {
    get
  }
  public enum ScreenType : Swift.String {
    case iPhone4_4S
    case iPhones_5_5s_5c_SE
    case iPhones_6_6s_7_8
    case iPhones_6Plus_6sPlus_7Plus_8Plus
    case iPhoneXR
    case iPhoneX_iPhoneXS
    case iPhoneXSMax
    case unknown
    public init?(rawValue: Swift.String)
    @available(iOS 2.0, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var screenType: UIKit.UIDevice.ScreenType {
    get
  }
}
extension UIKit.UIScreen {
  @_Concurrency.MainActor @preconcurrency public var screenSizeBasedOnOrientaion: CoreFoundation.CGSize {
    get
  }
}
@_Concurrency.MainActor @preconcurrency public struct LottieSwitch {
  @_Concurrency.MainActor @preconcurrency public init(animation: LensCustomerSDK.LottieAnimation?)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure(_ configure: @escaping (LensCustomerSDK.AnimatedSwitch) -> Swift.Void) -> LensCustomerSDK.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func configuration(_ configuration: LensCustomerSDK.LottieConfiguration) -> LensCustomerSDK.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func isOn(_ binding: SwiftUICore.Binding<Swift.Bool>) -> LensCustomerSDK.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func onAnimation(fromProgress onStartProgress: LensCustomerSDK.AnimationProgressTime, toProgress onEndProgress: LensCustomerSDK.AnimationProgressTime) -> LensCustomerSDK.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func offAnimation(fromProgress offStartProgress: LensCustomerSDK.AnimationProgressTime, toProgress offEndProgress: LensCustomerSDK.AnimationProgressTime) -> LensCustomerSDK.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func valueProvider<ValueProvider>(_ valueProvider: ValueProvider, for keypath: LensCustomerSDK.AnimationKeypath) -> LensCustomerSDK.LottieSwitch where ValueProvider : LensCustomerSDK.AnyValueProvider, ValueProvider : Swift.Equatable
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s15LensCustomerSDK12LottieSwitchV4bodyQrvp", 0) __
}
extension LensCustomerSDK.DotLottieFile {
  public enum SynchronouslyBlockingCurrentThread {
    public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache) -> Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>
    public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache) -> Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>
    public static func loadedFrom(data: Foundation.Data, filename: Swift.String) -> Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>
  }
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> LensCustomerSDK.DotLottieFile
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> LensCustomerSDK.DotLottieFile
  public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func asset(named name: Swift.String, bundle: Foundation.Bundle = Bundle.main, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> LensCustomerSDK.DotLottieFile
  public static func asset(named name: Swift.String, bundle: Foundation.Bundle = Bundle.main, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> LensCustomerSDK.DotLottieFile
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, handleResult: @escaping (Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func loadedFrom(data: Foundation.Data, filename: Swift.String, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func loadedFrom(data: Foundation.Data, filename: Swift.String, dispatchQueue: Dispatch.DispatchQueue = .dotLottie) async throws -> LensCustomerSDK.DotLottieFile
}
extension Dispatch.DispatchQueue {
  public static let dotLottie: Dispatch.DispatchQueue
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedButton : LensCustomerSDK.AnimatedControl {
  @_Concurrency.MainActor @preconcurrency override public init(animation: LensCustomerSDK.LottieAnimation?, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency public var performAction: (() -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public func setPlayRange(fromProgress: LensCustomerSDK.AnimationProgressTime, toProgress: LensCustomerSDK.AnimationProgressTime, event: LensCustomerSDK.LottieControlEvent)
  @_Concurrency.MainActor @preconcurrency public func setPlayRange(fromMarker fromName: Swift.String, toMarker toName: Swift.String, event: LensCustomerSDK.LottieControlEvent)
  @objc deinit
}
public enum AssistSocketErrorState : Swift.Error {
  case nointernet, writeTimeoutError, invalidSSLError, compressionError, outputStreamWriteError, protocolError, upgradeError, closeError, connectionTimeOut
  public static func == (a: LensCustomerSDK.AssistSocketErrorState, b: LensCustomerSDK.AssistSocketErrorState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class DisposableObserver : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.DisposableObserver, rhs: LensCustomerSDK.DisposableObserver) -> Swift.Bool
  public init(value: Swift.AnyObject)
  @objc deinit
}
public protocol DotLottieCacheProvider : Swift.Sendable {
  func file(forKey: Swift.String) -> LensCustomerSDK.DotLottieFile?
  func setFile(_ lottie: LensCustomerSDK.DotLottieFile, forKey: Swift.String)
  func clearCache()
}
extension UIKit.UISearchBar {
  @_Concurrency.MainActor @preconcurrency public var at_searchTextField: UIKit.UITextField? {
    get
  }
}
public class VMResponseSerialization {
  public var responseType: LensCustomerSDK.VMResponseType
  public init()
  @objc deinit
}
public struct LottieConfiguration : Swift.Hashable {
  public init(renderingEngine: LensCustomerSDK.RenderingEngineOption = .automatic, decodingStrategy: LensCustomerSDK.DecodingStrategy = .dictionaryBased, colorSpace: CoreGraphics.CGColorSpace = CGColorSpaceCreateDeviceRGB(), reducedMotionOption: LensCustomerSDK.ReducedMotionOption = .systemReducedMotionToggle)
  public static var shared: LensCustomerSDK.LottieConfiguration
  public var renderingEngine: LensCustomerSDK.RenderingEngineOption
  public var decodingStrategy: LensCustomerSDK.DecodingStrategy
  public var reducedMotionOption: LensCustomerSDK.ReducedMotionOption
  public var colorSpace: CoreGraphics.CGColorSpace
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.LottieConfiguration, b: LensCustomerSDK.LottieConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class AnimationSubview : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public enum LottieAnimationCache {
  public static var shared: (any LensCustomerSDK.AnimationCacheProvider)?
}
public enum LottieAnimationSource : Swift.Sendable {
  case lottieAnimation(LensCustomerSDK.LottieAnimation)
  case dotLottieFile(LensCustomerSDK.DotLottieFile)
}
extension LensCustomerSDK.LottieAnimation {
  final public var animationSource: LensCustomerSDK.LottieAnimationSource {
    get
  }
}
extension LensCustomerSDK.DotLottieFile {
  final public var animationSource: LensCustomerSDK.LottieAnimationSource {
    get
  }
}
public class DefaultAnimationCache : LensCustomerSDK.AnimationCacheProvider {
  public init()
  public static let sharedCache: LensCustomerSDK.DefaultAnimationCache
  public var cacheSize: Swift.Int {
    get
    set
  }
  public func clearCache()
  public func animation(forKey key: Swift.String) -> LensCustomerSDK.LottieAnimation?
  public func setAnimation(_ animation: LensCustomerSDK.LottieAnimation, forKey key: Swift.String)
  @objc deinit
}
extension LensCustomerSDK.DefaultAnimationCache : @unchecked Swift.Sendable {
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class NotificationView : UIKit.UIView {
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var messageLabel: UIKit.UILabel!
  @_Concurrency.MainActor @preconcurrency public static func getNotificationView() -> LensCustomerSDK.NotificationView?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency public func show()
  @_Concurrency.MainActor @preconcurrency public func dismiss(completion: (() -> ())? = nil)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UIView {
  public enum NotificationBannerStyle {
    case banner
    case toast
    public static func == (a: UIKit.UIView.NotificationBannerStyle, b: UIKit.UIView.NotificationBannerStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public func showNotificationInWindow(message: Swift.String, bgColor: UIKit.UIColor? = nil, textColor: UIKit.UIColor? = nil, show duration: Foundation.TimeInterval = 4, style: UIKit.UIView.NotificationBannerStyle = .banner, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func showNotificationBanner(message: Swift.String, bgColor: UIKit.UIColor? = nil, textColor: UIKit.UIColor? = nil, show duration: Foundation.TimeInterval = 4, style: UIKit.UIView.NotificationBannerStyle = .banner, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func dismissNotificationView()
}
extension LensCustomerSDK.LottieType {
  public static var ALL_LOTTIE_ANIMATION_VIEW_TAG: Swift.Int {
    get
  }
  public func getLottie(withName: Swift.String, bundle: Foundation.Bundle) -> LensCustomerSDK.LottieAnimationView
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class LottieMessageView : UIKit.UIView {
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var lottieContainer: UIKit.UIView!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var lottieContainerHeight: UIKit.NSLayoutConstraint!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var lottieContainerWidth: UIKit.NSLayoutConstraint!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var messageLabel: UIKit.UILabel!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var actionButton: UIKit.UIButton!
  @_Concurrency.MainActor @preconcurrency public var lottie: LensCustomerSDK.LottieAnimationView? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public static func instance(lottieType: any LensCustomerSDK.LottieType, messageLabelConfig: ((UIKit.UILabel) -> Swift.Void)? = nil, customView: UIKit.UIView? = nil, actionButtonConfiguration: ((UIKit.UIButton) -> (() -> Swift.Void)?)? = nil) -> LensCustomerSDK.LottieMessageView
  @_Concurrency.MainActor @preconcurrency public static func instance(with lottieType: any LensCustomerSDK.LottieType, withCustomMessage message: Swift.String? = nil, lineCount: Swift.Int? = -1, customView: UIKit.UIView? = nil, actionButtonConfiguration: ((UIKit.UIButton) -> (() -> Swift.Void)?)? = nil) -> LensCustomerSDK.LottieMessageView
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func awakeFromNib()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
final public class GradientValueProvider {
  public init(block: @escaping LensCustomerSDK.GradientValueProvider.ColorsValueBlock, locations: LensCustomerSDK.GradientValueProvider.ColorLocationsBlock? = nil)
  public init(_ colors: [LensCustomerSDK.LottieColor], locations: [Swift.Double] = [])
  public typealias ColorsValueBlock = (CoreFoundation.CGFloat) -> [LensCustomerSDK.LottieColor]
  public typealias ColorLocationsBlock = (CoreFoundation.CGFloat) -> [Swift.Double]
  final public var colors: [LensCustomerSDK.LottieColor] {
    get
    set
  }
  final public var locations: [Swift.Double] {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: LensCustomerSDK.ValueProviderStorage<[Swift.Double]> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.GradientValueProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.GradientValueProvider, rhs: LensCustomerSDK.GradientValueProvider) -> Swift.Bool
}
extension UIKit.UIColor {
  convenience public init(red: Swift.Int, green: Swift.Int, blue: Swift.Int)
  convenience public init(rgb: Swift.Int)
  public class func color(dark: UIKit.UIColor, light: UIKit.UIColor) -> UIKit.UIColor
}
public enum DecodingStrategy : Swift.Hashable {
  case legacyCodable
  case dictionaryBased
  public static func == (a: LensCustomerSDK.DecodingStrategy, b: LensCustomerSDK.DecodingStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.String {
  public var isEmailID: Swift.Bool {
    get
  }
  public var intValue: Swift.Int {
    get
  }
  public var floatValue: CoreFoundation.CGFloat {
    get
  }
  public func subString(fromIndex: Swift.Int) -> Swift.String
  public func subString(toIndex: Swift.Int) -> Swift.String
  public static func < (lhs: Swift.String, rhs: Swift.Int) -> Swift.String
  public func copyInClipboard()
  public var utf8Data: Foundation.Data? {
    get
  }
  public var isoLatin1Data: Foundation.Data? {
    get
  }
  public var asciiData: Foundation.Data? {
    get
  }
  public func data(encode: Swift.String.Encoding) -> Foundation.Data?
  public var splitByNewLine: [Swift.String] {
    get
  }
  public var splitBySpace: [Swift.String] {
    get
  }
}
extension UIKit.UIBarButtonItem {
  @_Concurrency.MainActor @preconcurrency public var frame: CoreFoundation.CGRect {
    get
  }
}
public enum ContentType : Swift.String {
  case jsonType, formType
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class VMRequestSerialization {
  public typealias HTTPField = Swift.String
  public var timeOutInterval: Foundation.TimeInterval
  public var HTTPHeaders: [Swift.String : Swift.String?]
  public var contentType: Swift.String {
    get
    set(newValue)
  }
  public init(timeOutInterval: Foundation.TimeInterval = 60)
  public func setValue(_ value: Swift.String?, forHTTPField: Swift.String)
  public func value(_ forHTTPField: Swift.String) -> Swift.String?
  public func setValues(_ values: [LensCustomerSDK.VMRequestSerialization.HTTPField : Swift.String])
  public func addValue(_ value: Swift.String, forHTTPField key: Swift.String)
  public func addValues(_ values: [Swift.String], forHttpField key: Swift.String)
  @objc deinit
}
extension Foundation.Data {
  public func write(fileName: Swift.String, appendIntermediateDir path: Swift.String? = nil) throws -> Foundation.URL?
  public var mbSize: CoreFoundation.CGFloat {
    get
  }
  public var sizeWithUnit: Swift.String {
    get
  }
}
public protocol AnimationImageProvider {
  var cacheEligible: Swift.Bool { get }
  func imageForAsset(asset: LensCustomerSDK.ImageAsset) -> CoreGraphics.CGImage?
  func contentsGravity(for asset: LensCustomerSDK.ImageAsset) -> QuartzCore.CALayerContentsGravity
}
extension LensCustomerSDK.AnimationImageProvider {
  public var cacheEligible: Swift.Bool {
    get
  }
  public func contentsGravity(for _: LensCustomerSDK.ImageAsset) -> QuartzCore.CALayerContentsGravity
}
public enum DotLottieError : Swift.Error {
  case noDataLoaded
  case assetNotFound(name: Swift.String, bundle: Foundation.Bundle?)
  case loadingFromAssetNotSupported
  @available(*, deprecated, message: "Unused")
  case invalidFileFormat
  @available(*, deprecated, message: "Unused")
  case invalidData
  @available(*, deprecated, message: "Unused")
  case animationNotAvailable
}
final public class PointValueProvider {
  public init(block: @escaping LensCustomerSDK.PointValueProvider.PointValueBlock)
  public init(_ point: CoreFoundation.CGPoint)
  public typealias PointValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  final public var point: CoreFoundation.CGPoint {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: LensCustomerSDK.ValueProviderStorage<LensCustomerSDK.LottieVector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.PointValueProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.PointValueProvider, rhs: LensCustomerSDK.PointValueProvider) -> Swift.Bool
}
final public class Keyframe<T> {
  public init(_ value: T, spatialInTangent: LensCustomerSDK.LottieVector3D? = nil, spatialOutTangent: LensCustomerSDK.LottieVector3D? = nil)
  public init(value: T, time: LensCustomerSDK.AnimationFrameTime, isHold: Swift.Bool = false, inTangent: LensCustomerSDK.LottieVector2D? = nil, outTangent: LensCustomerSDK.LottieVector2D? = nil, spatialInTangent: LensCustomerSDK.LottieVector3D? = nil, spatialOutTangent: LensCustomerSDK.LottieVector3D? = nil)
  final public let value: T
  final public let time: LensCustomerSDK.AnimationFrameTime
  final public let isHold: Swift.Bool
  final public let inTangent: LensCustomerSDK.LottieVector2D?
  final public let outTangent: LensCustomerSDK.LottieVector2D?
  final public let spatialInTangent: LensCustomerSDK.LottieVector3D?
  final public let spatialOutTangent: LensCustomerSDK.LottieVector3D?
  @objc deinit
}
extension LensCustomerSDK.Keyframe : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.Keyframe<T>, rhs: LensCustomerSDK.Keyframe<T>) -> Swift.Bool
}
extension LensCustomerSDK.Keyframe : Swift.Hashable where T : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension LensCustomerSDK.Keyframe : Swift.Sendable where T : Swift.Sendable {
}
extension UIKit.UIPopoverArrowDirection {
  public func defaultSourceRect(from view: UIKit.UIView) -> CoreFoundation.CGRect?
  public var isVerticalDirection: Swift.Bool {
    get
  }
}
extension UIKit.UIViewController {
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func openShareSheet(_ data: [Any], popFromView view: UIKit.UIView, completionHandler completionBlock: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func openShareSheet(_ data: [Any], popFromView barbutton: UIKit.UIBarButtonItem, completionHandler completionBlock: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func prepareAsPopoverController(from view: UIKit.UIView, soruceRect: CoreFoundation.CGRect?, preferedSize contentSize: CoreFoundation.CGSize = .zero, permittedArrowDirections directions: UIKit.UIPopoverArrowDirection = .down)
  @_Concurrency.MainActor @preconcurrency public func prepareAsPopoverController(from barButton: UIKit.UIBarButtonItem, soruceRect: CoreFoundation.CGRect?, preferedSize contentSize: CoreFoundation.CGSize = .zero, permittedArrowDirections directions: UIKit.UIPopoverArrowDirection = .down)
  @_Concurrency.MainActor @preconcurrency public func dismissPopoverIfExist()
}
extension UIKit.UIViewController : UIKit.UIPopoverPresentationControllerDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic open func popoverPresentationController(_ popoverPresentationController: UIKit.UIPopoverPresentationController, willRepositionPopoverTo rect: Swift.UnsafeMutablePointer<CoreFoundation.CGRect>, in view: Swift.AutoreleasingUnsafeMutablePointer<UIKit.UIView>)
  @_Concurrency.MainActor @preconcurrency @objc dynamic open func prepareForPopoverPresentation(_ popoverPresentationController: UIKit.UIPopoverPresentationController)
  @_Concurrency.MainActor @preconcurrency @objc dynamic open func popoverPresentationControllerDidDismissPopover(_ popoverPresentationController: UIKit.UIPopoverPresentationController)
}
extension Swift.Int {
  public var cgfloat: CoreFoundation.CGFloat {
    get
  }
}
public protocol CommonIntUtility {
  var isNegative: Swift.Bool { get }
  var isZero: Swift.Bool { get }
  var string: Swift.String { get }
}
extension LensCustomerSDK.CommonIntUtility where Self : Swift.SignedInteger {
  public var string: Swift.String {
    get
  }
  public func string(maximumNumber: Swift.Int) -> Swift.String
  public var isNegative: Swift.Bool {
    get
  }
  public var isZero: Swift.Bool {
    get
  }
  public var convertFileSizeWithUnit: Swift.String {
    get
  }
  public var fileSizeWithUnit: Swift.String {
    get
  }
}
extension Swift.Int : LensCustomerSDK.CommonIntUtility {
}
extension Swift.Int32 : LensCustomerSDK.CommonIntUtility {
}
extension Swift.Int64 : LensCustomerSDK.CommonIntUtility {
}
extension Swift.Int16 : LensCustomerSDK.CommonIntUtility {
}
infix operator +| : DefaultPrecedence
infix operator +- : DefaultPrecedence
final public class FloatValueProvider {
  public init(block: @escaping LensCustomerSDK.FloatValueProvider.CGFloatValueBlock)
  public init(_ float: CoreFoundation.CGFloat)
  public typealias CGFloatValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var float: CoreFoundation.CGFloat {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: LensCustomerSDK.ValueProviderStorage<LensCustomerSDK.LottieVector1D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.FloatValueProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.FloatValueProvider, rhs: LensCustomerSDK.FloatValueProvider) -> Swift.Bool
}
extension LensCustomerSDK.LottieAnimationView {
  @_Concurrency.MainActor @preconcurrency convenience public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, imageProvider: (any LensCustomerSDK.AnimationImageProvider)? = nil, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(filePath: Swift.String, imageProvider: (any LensCustomerSDK.AnimationImageProvider)? = nil, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(url: Foundation.URL, imageProvider: (any LensCustomerSDK.AnimationImageProvider)? = nil, session: Foundation.URLSession = .shared, closure: @escaping LensCustomerSDK.LottieAnimationView.DownloadClosure, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(asset name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: (any LensCustomerSDK.AnimationImageProvider)? = nil, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieName name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationId: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: LensCustomerSDK.LottieConfiguration = .shared, completion: ((LensCustomerSDK.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieFilePath filePath: Swift.String, animationId: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: LensCustomerSDK.LottieConfiguration = .shared, completion: ((LensCustomerSDK.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieUrl url: Foundation.URL, animationId: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: LensCustomerSDK.LottieConfiguration = .shared, session: Foundation.URLSession = .shared, completion: ((LensCustomerSDK.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieAsset name: Swift.String, bundle: Foundation.Bundle = Bundle.main, animationId: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: LensCustomerSDK.LottieConfiguration = .shared, completion: ((LensCustomerSDK.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  public typealias DownloadClosure = ((any Swift.Error)?) -> Swift.Void
}
public struct DotLottieConfiguration {
  public var id: Swift.String
  public var loopMode: LensCustomerSDK.LottieLoopMode
  public var speed: Swift.Double
  public var imageProvider: (any LensCustomerSDK.AnimationImageProvider)? {
    get
  }
}
public struct DotLottieConfigurationComponents : Swift.OptionSet {
  public init(rawValue: Swift.Int)
  public static let imageProvider: LensCustomerSDK.DotLottieConfigurationComponents
  public static let loopMode: LensCustomerSDK.DotLottieConfigurationComponents
  public static let animationSpeed: LensCustomerSDK.DotLottieConfigurationComponents
  public static let all: LensCustomerSDK.DotLottieConfigurationComponents
  public static let none: LensCustomerSDK.DotLottieConfigurationComponents
  public let rawValue: Swift.Int
  public typealias ArrayLiteralElement = LensCustomerSDK.DotLottieConfigurationComponents
  public typealias Element = LensCustomerSDK.DotLottieConfigurationComponents
  public typealias RawValue = Swift.Int
}
postfix operator |-|
postfix operator |=|
infix operator |-| : DefaultPrecedence
infix operator |=| : DefaultPrecedence
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency postfix public static func |-| (argument: UIKit.UIView)
  @_Concurrency.MainActor @preconcurrency public static func |-| (lhs: UIKit.UIView, rhs: UIKit.UIView)
  @_Concurrency.MainActor @preconcurrency public static func |-| (lhs: UIKit.UIView, padding: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency postfix public static func |=| (argument: UIKit.UIView)
  @_Concurrency.MainActor @preconcurrency public static func |=| (lhs: UIKit.UIView, rhs: UIKit.UIView)
}
@objc final public class CompatibleAnimationKeypath : ObjectiveC.NSObject {
  @objc public init(keypath: Swift.String)
  @objc public init(keys: [Swift.String])
  final public let animationKeypath: LensCustomerSDK.AnimationKeypath
  @objc deinit
}
public protocol AnimationFontProvider {
  func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
}
final public class DefaultFontProvider : LensCustomerSDK.AnimationFontProvider {
  public init()
  final public func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
  @objc deinit
}
extension LensCustomerSDK.DefaultFontProvider : Swift.Equatable {
  public static func == (_: LensCustomerSDK.DefaultFontProvider, _: LensCustomerSDK.DefaultFontProvider) -> Swift.Bool
}
extension CoreFoundation.CGFloat {
  public var quarter: CoreFoundation.CGFloat {
    get
  }
  public var half: CoreFoundation.CGFloat {
    get
  }
  public var Threequarter: CoreFoundation.CGFloat {
    get
  }
}
extension CoreFoundation.CGFloat {
  public func rounded(toPlaces places: Swift.Int) -> CoreFoundation.CGFloat
}
public enum ColorFormatDenominator : Swift.Hashable {
  case One
  case OneHundred
  case TwoFiftyFive
  public static func == (a: LensCustomerSDK.ColorFormatDenominator, b: LensCustomerSDK.ColorFormatDenominator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct LottieColor : Swift.Hashable {
  public var r: Swift.Double
  public var g: Swift.Double
  public var b: Swift.Double
  public var a: Swift.Double
  public init(r: Swift.Double, g: Swift.Double, b: Swift.Double, a: Swift.Double, denominator: LensCustomerSDK.ColorFormatDenominator = .One)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.LottieColor, b: LensCustomerSDK.LottieColor) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AnyValueProvider {
  var valueType: any Any.Type { get }
  var typeErasedStorage: LensCustomerSDK.AnyValueProviderStorage { get }
  func hasUpdate(frame: LensCustomerSDK.AnimationFrameTime) -> Swift.Bool
}
extension LensCustomerSDK.AnyValueProvider {
  public func value(frame: LensCustomerSDK.AnimationFrameTime) -> Any
}
public enum ValueProviderStorage<T> where T : LensCustomerSDK.AnyInterpolatable {
  case singleValue(T)
  case keyframes([LensCustomerSDK.Keyframe<T>])
  case closure((LensCustomerSDK.AnimationFrameTime) -> T)
}
public enum AnyValueProviderStorage {
  case singleValue(Any)
  case keyframes([LensCustomerSDK.Keyframe<Any>], interpolate: (LensCustomerSDK.AnimationFrameTime) -> Any)
  case closure((LensCustomerSDK.AnimationFrameTime) -> Any)
}
@_hasMissingDesignatedInitializers final public class DotLottieFile {
  public struct Animation {
    public let animation: LensCustomerSDK.LottieAnimation
    public let configuration: LensCustomerSDK.DotLottieConfiguration
  }
  final public var animations: [LensCustomerSDK.DotLottieFile.Animation] {
    get
  }
  @objc deinit
}
extension LensCustomerSDK.DotLottieFile : @unchecked Swift.Sendable {
}
extension LensCustomerSDK.LottieVector1D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct LottieVector2D : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.LottieVector2D, b: LensCustomerSDK.LottieVector2D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LensCustomerSDK.LottieVector3D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension LensCustomerSDK.LottieVector3D {
  public var pointValue: CoreFoundation.CGPoint {
    get
  }
  public var sizeValue: CoreFoundation.CGSize {
    get
  }
}
public struct AnimationKeypath : Swift.Hashable, Swift.ExpressibleByStringLiteral {
  public init(keypath: Swift.String)
  public init(stringLiteral: Swift.String)
  public init(keys: [Swift.String])
  public var keys: [Swift.String] {
    get
  }
  public var string: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.AnimationKeypath, b: LensCustomerSDK.AnimationKeypath) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedSwitch : LensCustomerSDK.AnimatedControl {
  @_Concurrency.MainActor @preconcurrency override public init(animation: LensCustomerSDK.LottieAnimation?, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency override open func animationDidSet()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  public enum CancelBehavior {
    case reverse
    case none
    public static func == (a: LensCustomerSDK.AnimatedSwitch.CancelBehavior, b: LensCustomerSDK.AnimatedSwitch.CancelBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var cancelBehavior: LensCustomerSDK.AnimatedSwitch.CancelBehavior
  @_Concurrency.MainActor @preconcurrency public var animateUpdateWhenChangingAnimation: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public var stateUpdated: ((_ isOn: Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var isOn: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func setIsOn(_ isOn: Swift.Bool, animated: Swift.Bool, shouldFireHaptics: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func setProgressForState(fromProgress: LensCustomerSDK.AnimationProgressTime, toProgress: LensCustomerSDK.AnimationProgressTime, forOnState: Swift.Bool)
  @objc deinit
}
extension Foundation.URL {
  public var params: [(Swift.String, Swift.String)] {
    get
  }
  public func appendParams(param: [Swift.String : Any]) -> Foundation.URL?
  public static func constructURLString(API: Swift.String, service: Swift.String, protocol protocolString: Swift.String, domain: Swift.String) -> Swift.String
  public static func constructURL(API: Swift.String, service: Swift.String, protocol protocolString: Swift.String, domain: Swift.String) -> Foundation.URL?
}
extension UIKit.UIScrollView {
  @_Concurrency.MainActor @preconcurrency public func didScrollToEnd() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func tryingToViewMore(_ range: CoreFoundation.CGFloat = 50) -> Swift.Bool
}
extension UIKit.UIScrollView {
  public enum ATViewSide {
    case left, right, bottom, top
    public static func == (a: UIKit.UIScrollView.ATViewSide, b: UIKit.UIScrollView.ATViewSide) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public func contentSize(withSafeArea side: UIKit.UIScrollView.ATViewSide) -> CoreFoundation.CGSize
}
extension Swift.Array {
  public mutating func removeElements(_ filter: (Element) -> Swift.Bool)
}
extension Swift.Array where Element : Swift.Equatable {
  public func contains(_ element: Element) -> Swift.Bool
  public func index(of element: Element) -> Swift.Int?
  public mutating func remove(element: Element)
}
public protocol Interpolatable : LensCustomerSDK.AnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
public protocol SpatialInterpolatable : LensCustomerSDK.AnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
public protocol AnyInterpolatable {
  func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
extension LensCustomerSDK.Interpolatable {
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent _: CoreFoundation.CGPoint?, spatialInTangent _: CoreFoundation.CGPoint?) -> Self
}
extension LensCustomerSDK.SpatialInterpolatable {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
extension Swift.Double : LensCustomerSDK.Interpolatable {
}
extension CoreFoundation.CGFloat : LensCustomerSDK.Interpolatable {
}
extension Swift.Float : LensCustomerSDK.Interpolatable {
}
extension LensCustomerSDK.Interpolatable where Self : Swift.BinaryFloatingPoint {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
extension CoreFoundation.CGRect : LensCustomerSDK.Interpolatable {
  public func interpolate(to: CoreFoundation.CGRect, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGRect
}
extension CoreFoundation.CGSize : LensCustomerSDK.Interpolatable {
  public func interpolate(to: CoreFoundation.CGSize, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
}
extension CoreFoundation.CGPoint : LensCustomerSDK.SpatialInterpolatable {
  public func interpolate(to: CoreFoundation.CGPoint, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> CoreFoundation.CGPoint
}
extension LensCustomerSDK.LottieColor : LensCustomerSDK.Interpolatable {
  public func interpolate(to: LensCustomerSDK.LottieColor, amount: CoreFoundation.CGFloat) -> LensCustomerSDK.LottieColor
}
extension LensCustomerSDK.LottieVector1D : LensCustomerSDK.Interpolatable {
  public func interpolate(to: LensCustomerSDK.LottieVector1D, amount: CoreFoundation.CGFloat) -> LensCustomerSDK.LottieVector1D
}
extension LensCustomerSDK.LottieVector2D : LensCustomerSDK.SpatialInterpolatable {
  public func interpolate(to: LensCustomerSDK.LottieVector2D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> LensCustomerSDK.LottieVector2D
}
extension LensCustomerSDK.LottieVector3D : LensCustomerSDK.SpatialInterpolatable {
  public func interpolate(to: LensCustomerSDK.LottieVector3D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> LensCustomerSDK.LottieVector3D
}
extension Swift.Array : LensCustomerSDK.Interpolatable, LensCustomerSDK.AnyInterpolatable where Element : LensCustomerSDK.Interpolatable {
  public func interpolate(to: [Element], amount: CoreFoundation.CGFloat) -> [Element]
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : LensCustomerSDK.Interpolatable, LensCustomerSDK.AnyInterpolatable where Wrapped : LensCustomerSDK.Interpolatable {
  public func interpolate(to: Wrapped?, amount: CoreFoundation.CGFloat) -> Wrapped?
}
#else
extension Swift.Optional : LensCustomerSDK.Interpolatable, LensCustomerSDK.AnyInterpolatable where Wrapped : LensCustomerSDK.Interpolatable {
  public func interpolate(to: Wrapped?, amount: CoreFoundation.CGFloat) -> Wrapped?
}
#endif
public typealias LottieControlType = UIKit.UIControl
public typealias LottieControlState = UIKit.UIControl.State
public typealias LottieControlEvent = UIKit.UIControl.Event
final public class ColorValueProvider {
  public init(block: @escaping LensCustomerSDK.ColorValueProvider.ColorValueBlock)
  public init(_ color: LensCustomerSDK.LottieColor)
  public init(_ keyframes: [LensCustomerSDK.Keyframe<LensCustomerSDK.LottieColor>])
  public typealias ColorValueBlock = (CoreFoundation.CGFloat) -> LensCustomerSDK.LottieColor
  final public var color: LensCustomerSDK.LottieColor {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: LensCustomerSDK.ValueProviderStorage<LensCustomerSDK.LottieColor> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.ColorValueProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.ColorValueProvider, rhs: LensCustomerSDK.ColorValueProvider) -> Swift.Bool
}
public class SocketHandler {
  public var socket: (any LensCustomerSDK.WebSocketProtocol)?
  public var timeOut: Swift.Double
  public var reachability: LensCustomerSDK.Reachability?
  public var gateWayUrlRequest: Foundation.URLRequest!
  final public let writeQoS: Foundation.QualityOfService
  final public let readQoS: Foundation.QualityOfService
  public init(_ url: Foundation.URLRequest, writeQoS: Foundation.QualityOfService, readQoS: Foundation.QualityOfService)
  public var disableSSLCertValidation: Swift.Bool {
    get
    set
  }
  public var isConnected: Swift.Bool {
    get
  }
  public func start()
  public func addListerner(_ object: any LensCustomerSDK.AssistSocketProtocol) -> LensCustomerSDK.DisposableObserver
  public func removeListerner(_ object: LensCustomerSDK.DisposableObserver)
  public func reset()
  public func write(_ string: Swift.String?)
  public func write(_ data: Foundation.Data?)
  public func disconnect()
  @objc deinit
}
extension LensCustomerSDK.SocketHandler : LensCustomerSDK.WebSocketCallBack {
  public func onConnect()
  public func onDisconnect(error: (any Swift.Error)?)
  public func onTextReceive(_ text: Swift.String)
  public func onDataReceive(_ data: Foundation.Data)
}
public protocol LottieType {
  var lottie: LensCustomerSDK.LottieAnimationView { get }
  var size: CoreFoundation.CGSize? { get }
  var message: Swift.String? { get }
}
public enum LensAnnotationType : Swift.String {
  case none, measurement, rectangle, ellipse, pencil, arrow, pointer
  public var isArrow: Swift.Bool {
    get
  }
  public var isMeasurement: Swift.Bool {
    get
  }
  public var isPencil: Swift.Bool {
    get
  }
  public var isPointer: Swift.Bool {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum FreeStyleState : Swift.CustomStringConvertible {
  case mouse_move, mouse_up
  public var description: Swift.String {
    get
  }
  public static func == (a: LensCustomerSDK.FreeStyleState, b: LensCustomerSDK.FreeStyleState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public enum ARFrameMode : Swift.Int {
  case auto
  case aspectFit
  case aspectFill
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum ARVideoOrientation : Swift.Int {
  case auto
  case alwaysPortrait
  case alwaysLandscape
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum RecordARMicrophonePermission : Swift.Int {
  case auto
  case manual
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum RecordARStatus : Swift.Int {
  case unknown
  case readyToRecord
  case recording
  case paused
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum RecordARMicrophoneStatus : Swift.Int {
  case unknown
  case enabled
  case disabled
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum VideoResolution : CoreFoundation.CGFloat {
  case resolution_720p
  case resolution_480p
  case resolution_360p
  public init?(rawValue: CoreFoundation.CGFloat)
  public typealias RawValue = CoreFoundation.CGFloat
  public var rawValue: CoreFoundation.CGFloat {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class ARRenderView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency weak public var arVideoDelegate: (any LensCustomerSDK.ARVideoDelegate)?
  @_Concurrency.MainActor @preconcurrency public var sceneView: ARKit.ARSCNView!
  @_Concurrency.MainActor @preconcurrency public var selectedARTool: LensCustomerSDK.LensAnnotationType {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc convenience dynamic public init()
  @_Concurrency.MainActor @preconcurrency convenience public init(arDelegate: (any LensCustomerSDK.ARViewDelegate)? = nil, triggerId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func setUserName(name: Swift.String)
  @objc @_Concurrency.MainActor @preconcurrency public func resumeARSCNViewSession(isSessionStart: Swift.Bool = true, callWithDelay: Swift.Bool = false)
  @objc @_Concurrency.MainActor @preconcurrency public func pauseARSCNViewSession()
  @objc @_Concurrency.MainActor @preconcurrency public func pauseARSCNViewSession(forBackgroundTransition: Swift.Bool)
  @objc @_Concurrency.MainActor @preconcurrency public func isARSCNViewSessionPaused() -> Swift.Bool
  @objc @_Concurrency.MainActor @preconcurrency public func pauseARSCNViewSessionInHD(SessionPauseCallback callback: @escaping () -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public func snapshot() -> UIKit.UIImage
  @_Concurrency.MainActor @preconcurrency public func getRawCameraImageBuffer() -> CoreVideo.CVPixelBuffer?
  @_Concurrency.MainActor @preconcurrency public func getRawCameraImage() -> UIKit.UIImage?
  @objc deinit
}
extension LensCustomerSDK.ARRenderView {
  @_Concurrency.MainActor @preconcurrency public func updateSelectedARTool(tool: LensCustomerSDK.LensAnnotationType)
}
extension LensCustomerSDK.ARRenderView {
  @_Concurrency.MainActor @preconcurrency public func drawLine(withId id: Swift.String, withLineColor color: UIKit.UIColor = UIColor(red: 0.129, green: 0.639, blue: 0.356, alpha: 1), atPoint point: CoreFoundation.CGPoint, triggerId: Swift.String, freeStyle: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func placeArrow(withId id: Swift.String = Node.DEFAULT_USER_ID, atPoint originalPoint: CoreFoundation.CGPoint, withArrowColor arrowColor: UIKit.UIColor = UIColor(red: 0.129, green: 0.639, blue: 0.356, alpha: 1), triggerId: Swift.String, isCustomer: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency public func placePointer(withId id: Swift.String = Node.DEFAULT_USER_ID, atPoint originalPoint: CoreFoundation.CGPoint, withLabel userName: Swift.String, fadeOutDelay: Swift.Int = Pointer.DEFAULT_FADE_OUT_DELAY, withPointerColor pointerColor: UIKit.UIColor = UIColor(red: 0.129, green: 0.639, blue: 0.356, alpha: 1), triggerId: Swift.String, isCustomer: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency public func drawRectangle(withId id: Swift.String, color: UIKit.UIColor = UIColor(red: 0.129, green: 0.639, blue: 0.356, alpha: 1), startPoint: CoreFoundation.CGPoint, endPoint: CoreFoundation.CGPoint, triggerId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func drawEllipse(withId id: Swift.String, color: UIKit.UIColor = UIColor(red: 0.129, green: 0.639, blue: 0.356, alpha: 1), startPoint: CoreFoundation.CGPoint, endPoint: CoreFoundation.CGPoint, triggerId: Swift.String)
}
extension LensCustomerSDK.ARRenderView {
  @_Concurrency.MainActor @preconcurrency public func setVideoFPS(fps: Swift.Int)
  @_Concurrency.MainActor @preconcurrency public func renderPointCloud(_ flag: Swift.Bool, callback: ((_ flag: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func isRenderingPointCloud() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func renderPlanes(_ flag: Swift.Bool, callback: ((_ flag: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func isRenderingPlanes() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var isHDStreaming: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func setHighResolution(_ flag: Swift.Bool, callback: ((_ flag: Swift.Bool) -> Swift.Void)? = nil)
  @available(*, deprecated, renamed: "getCustomerAnchorCount")
  @_Concurrency.MainActor @preconcurrency public func getAnchorCount() -> Swift.Int
  @_Concurrency.MainActor @preconcurrency public func getCustomerAnchorCount() -> Swift.Int
  @_Concurrency.MainActor @preconcurrency public func getTechnicianAnchorCount() -> Swift.Int
  @_Concurrency.MainActor @preconcurrency public func getMaxAnchorCount() -> Swift.Int
  @available(*, deprecated, renamed: "removeFirstCustomerAnchor")
  @_Concurrency.MainActor @preconcurrency public func removeFirstAnchor(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func removeFirstCustomerAnchor(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @available(*, deprecated, renamed: "removeLastCustomerAnchor")
  @_Concurrency.MainActor @preconcurrency public func removeLastAnchor(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func removeLastCustomerAnchor(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func removeLastTechnicianAnchor(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @available(*, deprecated, renamed: "removeAllCustomerAnchors")
  @_Concurrency.MainActor @preconcurrency public func removeAllAnchors(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func removeAllCustomerAnchors(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func removeAllTechnicianAnchors(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func removeSelectedCustomerAnchor(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func isAnyCustomerAnchorSelected() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func isAnyTechnicianAnchorSelected() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func selectTechnicianAnchor(atPoint originalPoint: CoreFoundation.CGPoint, triggerId: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func setAnchorSelectionListener(listener: any LensCustomerSDK.AnnotationSelectionListener)
  @_Concurrency.MainActor @preconcurrency public func setAnchorStateListener(listener: any LensCustomerSDK.AnchorStateListener)
  @_Concurrency.MainActor @preconcurrency public func updateNodeAnchor(annotateId: Swift.String, text: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func selectNodeAnchor(annotateId: Swift.String, senderTriggerId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func deselectNodeAnchor(annotateId: Swift.String, triggerId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func removeNodeAnchor(annotateId: Swift.String)
}
extension LensCustomerSDK.ARRenderView {
  @_Concurrency.MainActor @preconcurrency public class func checkARKitCompatibility() -> Swift.Bool
}
extension LensCustomerSDK.ARRenderView : ARKit.ARSessionDelegate, ARKit.ARSCNViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func sessionWasInterrupted(_ session: ARKit.ARSession)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func sessionInterruptionEnded(_ session: ARKit.ARSession)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func session(_ session: ARKit.ARSession, cameraDidChangeTrackingState camera: ARKit.ARCamera)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func session(_ session: ARKit.ARSession, didFailWithError error: any Swift.Error)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func renderer(_ renderer: any SceneKit.SCNSceneRenderer, didAdd node: SceneKit.SCNNode, for anchor: ARKit.ARAnchor)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func renderer(_ renderer: any SceneKit.SCNSceneRenderer, didUpdate node: SceneKit.SCNNode, for anchor: ARKit.ARAnchor)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func session(_ session: ARKit.ARSession, didUpdate frame: ARKit.ARFrame)
}
@objc @available(iOS 11.0, *)
public class ARRecorder : ObjectiveC.NSObject {
  @objc public var delegate: (any LensCustomerSDK.RecordARDelegate)?
  @objc public var renderAR: (any LensCustomerSDK.RenderARDelegate)?
  @objc public var status: LensCustomerSDK.RecordARStatus {
    get
  }
  @objc public var micStatus: LensCustomerSDK.RecordARMicrophoneStatus {
    get
  }
  @objc public var requestMicPermission: LensCustomerSDK.RecordARMicrophonePermission {
    @objc get
    @objc set
  }
  public var videoResolution: LensCustomerSDK.VideoResolution {
    get
    set
  }
  @objc public var videoOrientation: LensCustomerSDK.ARVideoOrientation
  @objc public var contentMode: LensCustomerSDK.ARFrameMode
  @objc public var onlyRenderWhileRecording: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var enableAudio: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var enableMixWithOthers: Swift.Bool
  @objc public var adjustVideoForSharing: Swift.Bool
  @objc public var deleteCacheWhenExported: Swift.Bool
  @objc public var enableAdjustEnvironmentLighting: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var retainTechnique: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public init(ARSceneKit: ARKit.ARSCNView)
  @objc deinit
  public func isVideoRecording() -> Swift.Bool
  @objc public func record(at url: Foundation.URL? = nil)
  @objc public func record(at url: Foundation.URL? = nil, forDuration duration: Foundation.TimeInterval, _ finished: ((_ videoPath: Foundation.URL) -> Swift.Void)? = nil)
  @objc public func pause()
  @objc public func stopAndExport(_ finished: ((_ videoAsset: Photos.PHAsset?, _ videoPath: Foundation.URL?, _ permissionStatus: Photos.PHAuthorizationStatus, _ exported: Swift.Bool) -> Swift.Void)? = nil)
  @objc public func stop(_ finished: ((_ videoPath: Foundation.URL) -> Swift.Void)? = nil)
  @objc public func cancel()
  @objc public func export(video path: Foundation.URL, _ finished: ((_ videoAsset: Photos.PHAsset?, _ videoPath: Foundation.URL?, _ exported: Swift.Bool, _ permissionStatus: Photos.PHAuthorizationStatus) -> Swift.Void)? = nil)
  @objc public func requestMicrophonePermission(_ finished: ((_ status: Swift.Bool) -> Swift.Void)? = nil)
}
@available(iOS 11.0, *)
@objc extension LensCustomerSDK.ARRecorder {
  @objc dynamic public func prepare(_ configuration: ARKit.ARConfiguration? = nil)
}
@available(iOS 11.0, *)
@objc public protocol RecordARDelegate {
  @objc func recorder(didEndRecording path: Foundation.URL, with noError: Swift.Bool)
  @objc func recorder(didFailRecording error: (any Swift.Error)?, and status: Swift.String)
  @objc optional func recorder(didCancelRecording status: Swift.String)
  @objc optional func recorder(didUpdateRecording duration: Foundation.TimeInterval)
  @objc func recorder(willEnterBackground status: LensCustomerSDK.RecordARStatus)
}
public enum StreamingType : Swift.String {
  case none
  case down
  case up
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum QRRetryMode {
  case NONE
  case RETRY_CONTINOUSLY
  case RETRY_UNTIL_TIME_LIMIT
  public static func == (a: LensCustomerSDK.QRRetryMode, b: LensCustomerSDK.QRRetryMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Lens {
  public var lensSignallingDelegate: (any LensCustomerSDK.LensSignallingProtocol)? {
    get
    set
  }
  public static var isVerbose: Swift.Bool
  public var isCameraFacingFront: Swift.Bool
  weak public var chatDelegate: (any LensCustomerSDK.ChatProtocol)?
  public var participants: [LensCustomerSDK.Participant] {
    get
  }
  public var sessionKey: Swift.String {
    get
  }
  public var clientRole: Swift.Int {
    get
  }
  public var clientToken: Swift.String {
    get
  }
  public var clientID: Swift.String? {
    get
  }
  public var displayName: Swift.String? {
    get
  }
  public var customerObject: LensCustomerSDK.Participant? {
    get
  }
  public var creatorZUID: Foundation.NSNumber? {
    get
  }
  public var technicianObjects: [LensCustomerSDK.Participant] {
    get
  }
  public var selfEmail: Swift.String {
    get
  }
  public var selfName: Swift.String {
    get
  }
  public var edition: LensCustomerSDK.Edition? {
    get
  }
  public var connectionParam: any LensCustomerSDK.CommonConnectionParams {
    get
  }
  public var isFreezedState: Swift.Bool {
    get
    set
  }
  public var isARSupported: Swift.Bool {
    get
    set
  }
  public var isFrontCamAvailable: Swift.Bool {
    get
  }
  @discardableResult
  public func swapToFrontCamera() -> Swift.Bool
  @discardableResult
  public func swapToBackCamera() -> Swift.Bool
  public var lens_protocol_delegate: (any LensCustomerSDK.LensSessionProtocolDelegate)?
  public var arRenderView: LensCustomerSDK.ARRenderView? {
    get
  }
  public var videoResolution: CoreFoundation.CGSize?
  public var arNodesNotifyList: [LensCustomerSDK.AnnotationNotify] {
    get
  }
  weak public var arDelegate: (any LensCustomerSDK.ARProtocol)?
  @objc deinit
}
extension LensCustomerSDK.Lens {
  public func onArNewNodeCreationReceived(annotationId: Swift.String)
  public func onArNodeRemovedReceived(annotationId: Swift.String)
  public func annotationSelected(annotationId: Swift.String, state: LensCustomerSDK.AnnotationSelection, triggerId: Swift.String)
}
extension LensCustomerSDK.Lens : LensCustomerSDK.AnnotationSelectionListener, LensCustomerSDK.AnchorStateListener {
  public func onAnnotationSelected(id: Swift.String, triggerId: Swift.String)
  public func onAnnotationDeselected(id: Swift.String, triggerId: Swift.String)
  public func onAnchorPlaced(annotationId: Swift.String, annotationColor: UIKit.UIColor, annotationType: Swift.String, annotationNumber: Swift.Int, triggerId: Swift.String, length: Swift.String? = nil)
  public func onAnchorRemoved(annotationId: Swift.String)
}
extension LensCustomerSDK.Lens {
  public func isToolSupported(tool: LensCustomerSDK.SupportedTools) -> Swift.Bool
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (LensCustomerSDK.Reachability) -> ()
  public typealias NetworkUnreachable = (LensCustomerSDK.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: LensCustomerSDK.Reachability.NetworkStatus, b: LensCustomerSDK.Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    @available(*, deprecated, renamed: "unavailable")
    public static let none: LensCustomerSDK.Reachability.Connection
    public static func == (a: LensCustomerSDK.Reachability.Connection, b: LensCustomerSDK.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: LensCustomerSDK.Reachability.NetworkReachable?
  public var whenUnreachable: LensCustomerSDK.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: LensCustomerSDK.Reachability.Connection {
    get
  }
  public var connection: LensCustomerSDK.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension LensCustomerSDK.Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class AnnotationNotes : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class AnnotaionNote : Swift.Codable {
  public var data: Swift.String
  final public let triggerID: Swift.String
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class AnnotationNotify : Swift.Codable {
  public var annotationObjectID: Swift.Int?
  final public let triggerID: Swift.String?
  public var notes: [LensCustomerSDK.AnnotaionNote]?
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class NotificationHandler {
  public static func removeAllNotificaion()
  public static func register(categories: [LensCustomerSDK.UserNotificationCategory])
  public static func schedule(notification configuration: LensCustomerSDK.UserNotificationScheduleConfiguration, completion: ((Swift.Bool) -> Swift.Void)?)
  @objc deinit
}
public struct OCRData {
  public var ocrText: Swift.String
  public var confidence: Swift.String
}
public struct QRData {
  public var qrText: Swift.String
}
public struct UserNotificationScheduleConfiguration {
  public let body: Swift.String
  public let title: Swift.String?
  public var uniqueID: Swift.String
  public let scheduleDate: Foundation.Date
  public var category: LensCustomerSDK.NotificationCategoryIdentifier?
}
public struct NotificationCategoryIdentifier : Swift.RawRepresentable {
  public var rawValue: Swift.String
  public static var chat: LensCustomerSDK.NotificationCategoryIdentifier
  public init(rawValue: Swift.String)
  public init(_ rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public struct UserNotificationCategory {
  public static var chat: LensCustomerSDK.UserNotificationCategory {
    get
  }
  public var categoryId: LensCustomerSDK.NotificationCategoryIdentifier
  public var actions: [LensCustomerSDK.UserNotificationAction]
  public init(_ cid: LensCustomerSDK.NotificationCategoryIdentifier, actions: [LensCustomerSDK.UserNotificationAction])
}
public struct UserNotificationAction {
  public enum ActionType {
    case actionButton(title: Swift.String)
    case inputField(title: Swift.String, textFieldplaceHolder: Swift.String, inputActionTitle: Swift.String)
  }
  public let actionType: LensCustomerSDK.UserNotificationAction.ActionType
  public let actionID: Swift.String
}
extension LensCustomerSDK.Lens {
  @discardableResult
  public func send(_ message: Swift.String) -> Swift.Bool
  @discardableResult
  public func send(_ chat: LensCustomerSDK.Chat) -> Swift.Bool
}
public enum CanvasBoardSettings : Swift.String {
  case ellipse, pencil, rectangle, arrow, pointer, none
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum FlashActionType : Swift.String {
  case turn_On, turn_Off
  public init(boolean: Swift.Bool)
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FlashSupportEvent : LensCustomerSDK.BaseParser {
  public var is_flash_supported: Swift.Bool
  public var current_flash_status: LensCustomerSDK.FlashActionType
  @objc deinit
}
public class ResolutionHandler {
  public var videoFrame: CoreFoundation.CGRect!
  public var videoRes: CoreFoundation.CGSize! {
    get
    set
  }
  public var viewRect: CoreFoundation.CGRect
  public init(fromView rect: CoreFoundation.CGRect)
  public func getVideoFrame(for input: LensCustomerSDK.DrawingInput) -> CoreFoundation.CGRect
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class Participant : LensCustomerSDK.BaseParser {
  public enum Role : Swift.String {
    case technician, customer, secondary_technician, external_technician
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Status : Swift.String {
    case UP, DOWN
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ParticpantOSType : Swift.String {
    case ios, android
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var clientId: Foundation.NSNumber?
  final public let role: LensCustomerSDK.Participant.Role?
  final public let email: Swift.String?
  public var status: LensCustomerSDK.Participant.Status?
  final public let zuid: Foundation.NSNumber?
  public var name: Swift.String? {
    get
  }
  public var time: Swift.Int?
  public var platformType: LensCustomerSDK.Participant.ParticpantOSType?
  final public let app_version: Swift.String?
  public init(selfEmail: Swift.String?, role: LensCustomerSDK.Participant.Role, status: LensCustomerSDK.Participant.Status?, zuid: Foundation.NSNumber?, display_name: Swift.String?, app_version: Swift.String?, joiningTime: Swift.Int?)
  public static func == (lhs: LensCustomerSDK.Participant, rhs: LensCustomerSDK.Participant) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.SessionValidationResponse.SessionValidationError : Swift.Equatable {}
extension LensCustomerSDK.SessionValidationResponse.SessionValidationError : Swift.Hashable {}
extension LensCustomerSDK.Edition : Swift.Equatable {}
extension LensCustomerSDK.Edition : Swift.Hashable {}
extension LensCustomerSDK.Edition : Swift.RawRepresentable {}
extension LensCustomerSDK.Features : Swift.Equatable {}
extension LensCustomerSDK.Features : Swift.Hashable {}
extension LensCustomerSDK.Features : Swift.RawRepresentable {}
extension LensCustomerSDK.AssisLensStates.AssistLensDisconnectState : Swift.Equatable {}
extension LensCustomerSDK.AssisLensStates.AssistLensDisconnectState : Swift.Hashable {}
extension LensCustomerSDK.SessionValidation : Swift.Equatable {}
extension LensCustomerSDK.SessionValidation : Swift.Hashable {}
extension LensCustomerSDK.SessionValidation : Swift.RawRepresentable {}
extension LensCustomerSDK.ConnectionProcessType : Swift.Equatable {}
extension LensCustomerSDK.ConnectionProcessType : Swift.Hashable {}
extension LensCustomerSDK.ConnectionProcessType : Swift.RawRepresentable {}
extension LensCustomerSDK.TechnicianAction : Swift.Equatable {}
extension LensCustomerSDK.TechnicianAction : Swift.Hashable {}
extension LensCustomerSDK.TechnicianAction : Swift.RawRepresentable {}
extension LensCustomerSDK.RecodingStatus : Swift.Equatable {}
extension LensCustomerSDK.RecodingStatus : Swift.Hashable {}
extension LensCustomerSDK.RecodingStatus : Swift.RawRepresentable {}
extension LensCustomerSDK.RecordingControlMode : Swift.Equatable {}
extension LensCustomerSDK.RecordingControlMode : Swift.Hashable {}
extension LensCustomerSDK.RecordingControlMode : Swift.RawRepresentable {}
extension LensCustomerSDK.CustomerAction : Swift.Equatable {}
extension LensCustomerSDK.CustomerAction : Swift.Hashable {}
extension LensCustomerSDK.CustomerAction : Swift.RawRepresentable {}
extension LensCustomerSDK.ConferenceType : Swift.Equatable {}
extension LensCustomerSDK.ConferenceType : Swift.Hashable {}
extension LensCustomerSDK.ConferenceType : Swift.RawRepresentable {}
extension LensCustomerSDK.LensOpreationError : Swift.Equatable {}
extension LensCustomerSDK.LensOpreationError : Swift.Hashable {}
extension LensCustomerSDK.ShareCameraActionType : Swift.Equatable {}
extension LensCustomerSDK.ShareCameraActionType : Swift.Hashable {}
extension LensCustomerSDK.ShareCameraActionType : Swift.RawRepresentable {}
extension LensCustomerSDK.ShareCameraTechAction : Swift.Equatable {}
extension LensCustomerSDK.ShareCameraTechAction : Swift.Hashable {}
extension LensCustomerSDK.ShareCameraTechAction : Swift.RawRepresentable {}
extension LensCustomerSDK.SnapShotAction : Swift.Equatable {}
extension LensCustomerSDK.SnapShotAction : Swift.Hashable {}
extension LensCustomerSDK.SnapShotAction : Swift.RawRepresentable {}
extension LensCustomerSDK.ScanType : Swift.Equatable {}
extension LensCustomerSDK.ScanType : Swift.Hashable {}
extension LensCustomerSDK.ScanType : Swift.RawRepresentable {}
extension LensCustomerSDK.RoleEnum : Swift.Equatable {}
extension LensCustomerSDK.RoleEnum : Swift.Hashable {}
extension LensCustomerSDK.RoleEnum : Swift.RawRepresentable {}
extension LensCustomerSDK.MonitorActionEnum : Swift.Equatable {}
extension LensCustomerSDK.MonitorActionEnum : Swift.Hashable {}
extension LensCustomerSDK.MonitorActionEnum : Swift.RawRepresentable {}
extension LensCustomerSDK.AnnotationObjectType : Swift.Equatable {}
extension LensCustomerSDK.AnnotationObjectType : Swift.Hashable {}
extension LensCustomerSDK.AnnotationObjectType : Swift.RawRepresentable {}
extension LensCustomerSDK.ClearAction : Swift.Equatable {}
extension LensCustomerSDK.ClearAction : Swift.Hashable {}
extension LensCustomerSDK.ClearAction : Swift.RawRepresentable {}
extension LensCustomerSDK.AnnotationSelection : Swift.Equatable {}
extension LensCustomerSDK.AnnotationSelection : Swift.Hashable {}
extension LensCustomerSDK.AnnotationSelection : Swift.RawRepresentable {}
extension LensCustomerSDK.AR_TrackingState : Swift.Equatable {}
extension LensCustomerSDK.AR_TrackingState : Swift.Hashable {}
extension LensCustomerSDK.SupportedTools : Swift.Equatable {}
extension LensCustomerSDK.SupportedTools : Swift.Hashable {}
extension LensCustomerSDK.SupportedTools : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Session : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Session : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Session : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Session.Scan : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Session.Scan : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Session.Scan : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Chat : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Chat : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Chat : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.InviteUser : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.InviteUser : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.InviteUser : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.InviteUser.Error : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.InviteUser.Error : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.InviteUser.Error : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.ErrorMsg : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.ErrorMsg : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.ErrorMsg : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Notes : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Notes : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Notes : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Common : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Common : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Common : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.ARErroMessage : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.ARErroMessage : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.ARErroMessage : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Snapshot : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Snapshot : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Snapshot : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.CustomerActionContent : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.CustomerActionContent : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.CustomerActionContent : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.ShareCamera : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.ShareCamera : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.ShareCamera : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Flash : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Flash : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Flash : Swift.RawRepresentable {}
extension LensCustomerSDK.FreezeCurrentStatus.FreezeBy : Swift.Equatable {}
extension LensCustomerSDK.FreezeCurrentStatus.FreezeBy : Swift.Hashable {}
extension LensCustomerSDK.SDKLensLottieType : Swift.Equatable {}
extension LensCustomerSDK.SDKLensLottieType : Swift.Hashable {}
extension LensCustomerSDK.ImageScrollView.ContentMode : Swift.Equatable {}
extension LensCustomerSDK.ImageScrollView.ContentMode : Swift.Hashable {}
extension LensCustomerSDK.ImageScrollView.ContentMode : Swift.RawRepresentable {}
extension LensCustomerSDK.ImageScrollView.Offset : Swift.Equatable {}
extension LensCustomerSDK.ImageScrollView.Offset : Swift.Hashable {}
extension LensCustomerSDK.ImageScrollView.Offset : Swift.RawRepresentable {}
extension LensCustomerSDK.DrawingInput.DrawShape : Swift.Equatable {}
extension LensCustomerSDK.DrawingInput.DrawShape : Swift.Hashable {}
extension LensCustomerSDK.DrawingInput.DrawShape : Swift.RawRepresentable {}
extension LensCustomerSDK.DrawingInput.FreeStyleState : Swift.Equatable {}
extension LensCustomerSDK.DrawingInput.FreeStyleState : Swift.Hashable {}
extension LensCustomerSDK.DrawingInput.FreeStyleState : Swift.RawRepresentable {}
extension LensCustomerSDK.LensFlashError : Swift.Equatable {}
extension LensCustomerSDK.LensFlashError : Swift.Hashable {}
extension LensCustomerSDK.LensFlashError : Swift.RawRepresentable {}
extension LensCustomerSDK.ARInputViewOrientation : Swift.Equatable {}
extension LensCustomerSDK.ARInputViewOrientation : Swift.Hashable {}
extension LensCustomerSDK.ARInputViewOrientation : Swift.RawRepresentable {}
extension LensCustomerSDK.VMHTTPMethod : Swift.Equatable {}
extension LensCustomerSDK.VMHTTPMethod : Swift.Hashable {}
extension LensCustomerSDK.VMHTTPMethod : Swift.RawRepresentable {}
extension LensCustomerSDK.VMSessionError : Swift.Equatable {}
extension LensCustomerSDK.VMSessionError : Swift.Hashable {}
extension LensCustomerSDK.VMSessionError : Swift.RawRepresentable {}
extension LensCustomerSDK.VMResponseType : Swift.Equatable {}
extension LensCustomerSDK.VMResponseType : Swift.Hashable {}
extension LensCustomerSDK.LayerType : Swift.Equatable {}
extension LensCustomerSDK.LayerType : Swift.Hashable {}
extension LensCustomerSDK.LayerType : Swift.RawRepresentable {}
extension LensCustomerSDK.MatteType : Swift.Equatable {}
extension LensCustomerSDK.MatteType : Swift.Hashable {}
extension LensCustomerSDK.MatteType : Swift.RawRepresentable {}
extension LensCustomerSDK.BlendMode : Swift.Equatable {}
extension LensCustomerSDK.BlendMode : Swift.Hashable {}
extension LensCustomerSDK.BlendMode : Swift.RawRepresentable {}
extension Foundation.Date.Weekday : Swift.Equatable {}
extension Foundation.Date.Weekday : Swift.Hashable {}
extension Foundation.Date.Weekday : Swift.RawRepresentable {}
extension Foundation.Date.SearchDirection : Swift.Equatable {}
extension Foundation.Date.SearchDirection : Swift.Hashable {}
extension LensCustomerSDK.CoordinateSpace : Swift.Equatable {}
extension LensCustomerSDK.CoordinateSpace : Swift.Hashable {}
extension LensCustomerSDK.CoordinateSpace : Swift.RawRepresentable {}
extension ObjectiveC.NSObject.AssistImpactFeedbackStyle : Swift.Equatable {}
extension ObjectiveC.NSObject.AssistImpactFeedbackStyle : Swift.Hashable {}
extension LensCustomerSDK.CloseCode : Swift.Equatable {}
extension LensCustomerSDK.CloseCode : Swift.Hashable {}
extension LensCustomerSDK.CloseCode : Swift.RawRepresentable {}
extension LensCustomerSDK.ErrorType : Swift.Equatable {}
extension LensCustomerSDK.ErrorType : Swift.Hashable {}
extension LensCustomerSDK.WebSocket.OpCode : Swift.Equatable {}
extension LensCustomerSDK.WebSocket.OpCode : Swift.Hashable {}
extension LensCustomerSDK.WebSocket.OpCode : Swift.RawRepresentable {}
extension LensCustomerSDK.CompatibleRenderingEngineOption : Swift.Equatable {}
extension LensCustomerSDK.CompatibleRenderingEngineOption : Swift.Hashable {}
extension LensCustomerSDK.CompatibleRenderingEngineOption : Swift.RawRepresentable {}
extension LensCustomerSDK.CompatibleBackgroundBehavior : Swift.Equatable {}
extension LensCustomerSDK.CompatibleBackgroundBehavior : Swift.Hashable {}
extension LensCustomerSDK.CompatibleBackgroundBehavior : Swift.RawRepresentable {}
extension LensCustomerSDK.LottieView : SwiftUICore.View {}
extension LensCustomerSDK.LottieView : Swift.Sendable {}
extension LensCustomerSDK.SizeValueProvider : LensCustomerSDK.AnyValueProvider {}
extension LensCustomerSDK.LottieBackgroundBehavior : Swift.Equatable {}
extension LensCustomerSDK.LottieBackgroundBehavior : Swift.Hashable {}
extension LensCustomerSDK.LottieButton : SwiftUICore.View {}
extension LensCustomerSDK.LottieButton : Swift.Sendable {}
extension UIKit.UIDevice.ScreenType : Swift.Equatable {}
extension UIKit.UIDevice.ScreenType : Swift.Hashable {}
extension UIKit.UIDevice.ScreenType : Swift.RawRepresentable {}
extension LensCustomerSDK.LottieSwitch : SwiftUICore.View {}
extension LensCustomerSDK.LottieSwitch : Swift.Sendable {}
extension LensCustomerSDK.AssistSocketErrorState : Swift.Equatable {}
extension LensCustomerSDK.AssistSocketErrorState : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UIView.NotificationBannerStyle : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UIView.NotificationBannerStyle : Swift.Hashable {}
extension LensCustomerSDK.GradientValueProvider : LensCustomerSDK.AnyValueProvider {}
extension LensCustomerSDK.ContentType : Swift.Equatable {}
extension LensCustomerSDK.ContentType : Swift.Hashable {}
extension LensCustomerSDK.ContentType : Swift.RawRepresentable {}
extension LensCustomerSDK.PointValueProvider : LensCustomerSDK.AnyValueProvider {}
extension LensCustomerSDK.FloatValueProvider : LensCustomerSDK.AnyValueProvider {}
extension LensCustomerSDK.AnimatedSwitch.CancelBehavior : Swift.Equatable {}
extension LensCustomerSDK.AnimatedSwitch.CancelBehavior : Swift.Hashable {}
extension UIKit.UIScrollView.ATViewSide : Swift.Equatable {}
extension UIKit.UIScrollView.ATViewSide : Swift.Hashable {}
extension LensCustomerSDK.ColorValueProvider : LensCustomerSDK.AnyValueProvider {}
extension LensCustomerSDK.LensAnnotationType : Swift.Equatable {}
extension LensCustomerSDK.LensAnnotationType : Swift.Hashable {}
extension LensCustomerSDK.LensAnnotationType : Swift.RawRepresentable {}
extension LensCustomerSDK.FreeStyleState : Swift.Equatable {}
extension LensCustomerSDK.FreeStyleState : Swift.Hashable {}
extension LensCustomerSDK.ARFrameMode : Swift.Equatable {}
extension LensCustomerSDK.ARFrameMode : Swift.Hashable {}
extension LensCustomerSDK.ARFrameMode : Swift.RawRepresentable {}
extension LensCustomerSDK.ARVideoOrientation : Swift.Equatable {}
extension LensCustomerSDK.ARVideoOrientation : Swift.Hashable {}
extension LensCustomerSDK.ARVideoOrientation : Swift.RawRepresentable {}
extension LensCustomerSDK.RecordARMicrophonePermission : Swift.Equatable {}
extension LensCustomerSDK.RecordARMicrophonePermission : Swift.Hashable {}
extension LensCustomerSDK.RecordARMicrophonePermission : Swift.RawRepresentable {}
extension LensCustomerSDK.RecordARStatus : Swift.Equatable {}
extension LensCustomerSDK.RecordARStatus : Swift.Hashable {}
extension LensCustomerSDK.RecordARStatus : Swift.RawRepresentable {}
extension LensCustomerSDK.RecordARMicrophoneStatus : Swift.Equatable {}
extension LensCustomerSDK.RecordARMicrophoneStatus : Swift.Hashable {}
extension LensCustomerSDK.RecordARMicrophoneStatus : Swift.RawRepresentable {}
extension LensCustomerSDK.VideoResolution : Swift.Equatable {}
extension LensCustomerSDK.VideoResolution : Swift.Hashable {}
extension LensCustomerSDK.VideoResolution : Swift.RawRepresentable {}
extension LensCustomerSDK.StreamingType : Swift.Equatable {}
extension LensCustomerSDK.StreamingType : Swift.Hashable {}
extension LensCustomerSDK.StreamingType : Swift.RawRepresentable {}
extension LensCustomerSDK.QRRetryMode : Swift.Equatable {}
extension LensCustomerSDK.QRRetryMode : Swift.Hashable {}
@available(*, unavailable, renamed: "Connection")
extension LensCustomerSDK.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension LensCustomerSDK.Reachability.NetworkStatus : Swift.Hashable {}
extension LensCustomerSDK.Reachability.Connection : Swift.Equatable {}
extension LensCustomerSDK.Reachability.Connection : Swift.Hashable {}
extension LensCustomerSDK.CanvasBoardSettings : Swift.Equatable {}
extension LensCustomerSDK.CanvasBoardSettings : Swift.Hashable {}
extension LensCustomerSDK.CanvasBoardSettings : Swift.RawRepresentable {}
extension LensCustomerSDK.FlashActionType : Swift.Equatable {}
extension LensCustomerSDK.FlashActionType : Swift.Hashable {}
extension LensCustomerSDK.FlashActionType : Swift.RawRepresentable {}
extension LensCustomerSDK.Participant.Role : Swift.Equatable {}
extension LensCustomerSDK.Participant.Role : Swift.Hashable {}
extension LensCustomerSDK.Participant.Role : Swift.RawRepresentable {}
extension LensCustomerSDK.Participant.Status : Swift.Equatable {}
extension LensCustomerSDK.Participant.Status : Swift.Hashable {}
extension LensCustomerSDK.Participant.Status : Swift.RawRepresentable {}
extension LensCustomerSDK.Participant.ParticpantOSType : Swift.Equatable {}
extension LensCustomerSDK.Participant.ParticpantOSType : Swift.Hashable {}
extension LensCustomerSDK.Participant.ParticpantOSType : Swift.RawRepresentable {}
