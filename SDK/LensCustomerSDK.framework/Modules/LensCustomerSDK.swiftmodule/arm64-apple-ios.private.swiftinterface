// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios14.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name LensCustomerSDK
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import ARKit
import AVFoundation
import AVKit
import CallKit
import Combine
import CommonCrypto
import Compression
import CoreData
import CoreFoundation
import CoreGraphics
import CoreImage
import CoreMedia
import CoreText
import CoreVideo
import DeveloperToolsSupport
import Foundation
@_exported import LensCustomerSDK
import Metal
import Photos
import PushKit
import QuartzCore
import QuickLook
import SceneKit
import Security
import SnapKit
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import UniformTypeIdentifiers
import UserNotifications
import UserNotificationsUI
import Vision
import WebKit
import WebRTC
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import zlib
public enum SessionValidationResponse {
  case validTechnician(any LensCustomerSDK.TechnicianSessionParams)
  case validCustomer(any LensCustomerSDK.CustomerSessionParams)
  case error((any Swift.Error)?)
  public enum SessionValidationError : Swift.Error {
    case invalidKey
    case invalidLicence
    case sessionExpired
    case unknowError
    case internalError
    case invalidOrgAcess
    case differentOrg
    case appUpgrade
    case customer_already_active_in_session
    case parameterMissing
    case unauthorized
    case userActionNotAllowed
    public static func == (a: LensCustomerSDK.SessionValidationResponse.SessionValidationError, b: LensCustomerSDK.SessionValidationResponse.SessionValidationError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public enum Edition : Swift.String {
  case FREE, STANDARD, PROFESSIONAL
  public var features: [LensCustomerSDK.Features] {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum Features : Swift.String {
  case INSTANT_CHAT, USER_MANAGEMENT, ZOOM, ACTION_LOG_VIEWER, SESSION_NOTES, CAPTURE_SCREEN_SHOT, SMS_INVITATION, ANNOTATION_TECHNICIAN, FREEZE_CAMERA_STREAM, DEPARTMENT, OFFLINE_RECORDING, ADVANCED_CHAT, SECONDARY_TECHNICIAN, FLASH, RECORDING, AR_NOTES, LIVE_TEXT, QR_BARCODE, SHARE_CAMERA, EXTERNAL_TECHNICIAN, AR_MEASURE
  case ANNOTATION_CUSTOMER
  case NONE
  case COMMON
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AssisLensStates {
  case socketConnected, localPeerHandShakeInitated, localPeerHandShakeDone, remotePeerHandshakeInitated, remotePeerHandshakeDone, connectionCompleted, localIceCandidatesConnectionFailure, remoteIceCandidatesConnectionFailure
  case disconnected((any Swift.Error)?)
  public enum AssistLensDisconnectState : Swift.Error {
    case noInternet, customerEndSession, technicianEndSession, timeout, invalid_client, invalid_key, session_expired, localPeerHandShakeError, remotePeerHandShakeError, serverEndedSession, openedInDifferentLocation, customer_already_active_in_session, secTechEntryRejected
    public static func == (a: LensCustomerSDK.AssisLensStates.AssistLensDisconnectState, b: LensCustomerSDK.AssisLensStates.AssistLensDisconnectState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var debugDescription: Swift.String {
    get
  }
}
public enum SessionValidation : Swift.String {
  case valid_session, invalid_session, invalid_client, session_expired, duplicate_client
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ConnectionProcessType : Swift.String {
  case REINIT, INIT, RESTART
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum TechnicianAction : Swift.String {
  case snapshot_taken, video_pause, video_play, audio_muted, audio_unmuted
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum RecodingStatus : Swift.String {
  case ENABLED, STORAGE_FULL, NOT_CONFIGURED, NOT_AVAILABLE
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum RecordingControlMode : Swift.String {
  case FULL_SESSION_REC, IN_SESSION_REC
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CustomerAction : Swift.String {
  case muteAudio
  case muteVideo
  case unmuteAudio
  case unmuteVideo
  case appResignActive
  case appBecomeActive
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ConferenceType : Swift.String {
  case smart_conference, peer_to_peer
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum LensOpreationError : Swift.Error {
  case featureNotExist, messageNotSent, scopeError, dataCorrupted
  public static func == (a: LensCustomerSDK.LensOpreationError, b: LensCustomerSDK.LensOpreationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ShareCameraActionType : Swift.String {
  case request
  case response
  case videoOff
  case cameraStreamChange
  case cameraStreamRemoved
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ShareCameraTechAction : Swift.String {
  case cameraStreamChange, cameraStreamRemoved, RequestApproved, RequestRejected, RequestWaiting
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum SnapShotAction : Swift.String, Swift.Codable {
  case freeze, freeze_request, unfreeze, unfreeze_request
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ScanType : Swift.String {
  case OCR
  case QR
  case BARCODE
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum RoleEnum : Swift.String {
  case Customer
  case PrimaryTechnician
  case SecondaryTechnician
  case ExternalTechnician
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ScanRequestType : Swift.Equatable {
  case LOCAL
  case REMOTE(trigger_id: Swift.String)
  public static func == (a: LensCustomerSDK.ScanRequestType, b: LensCustomerSDK.ScanRequestType) -> Swift.Bool
}
public enum ScanState {
  case REQUESTED(scanType: LensCustomerSDK.ScanType, scanRequestType: LensCustomerSDK.ScanRequestType)
  case COMPLETED(model: LensCustomerSDK.ScanModel)
  case ERROR(scanError: LensCustomerSDK.ScanError)
}
public enum ScanModel {
  case OCR(ocrText: Swift.String, confidence: Swift.String)
  case QR(qrText: Swift.String)
  case BARCODE(barcodeText: Swift.String)
}
public struct ScanError : Swift.Error {
  public let scanType: LensCustomerSDK.ScanType
  public let scanRequestType: LensCustomerSDK.ScanRequestType
  public let errorMessage: Swift.String
}
public enum MonitorActionEnum : Swift.String {
  case OPEN, UPDATE, SELECT, DESELECT, DELETE, TURN_ON, TURN_OFF, ARROW, PENCIL, RECTANGLE, ELLIPSE, MEASUREMENT, POINTER_3D, TYPE_ERROR
  public static func convertLensAnnotationType(typeString: Swift.String) -> LensCustomerSDK.MonitorActionEnum
  public static func convertLensAnnotationType(type: LensCustomerSDK.LensAnnotationType) -> LensCustomerSDK.MonitorActionEnum
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MonitorFeatureEnum {
  case AR_NOTES, OCR, QR, FLASH, ANNOTATE(triggerId: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum AnnotationObjectType : Swift.String {
  case pencil, ellipse, rectangle, arrow, pointer
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ClearAction : Swift.String {
  case clear_ar, clearall_ar, clearall_2d, clearall, add_ar
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AnnotationSelection : Swift.String {
  case ar_selected, ar_deselected
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AR_TrackingState {
  case normal, excessiveMotion, initializing, relocalizing, insufficientFeatures, notAvailable
  public static func == (a: LensCustomerSDK.AR_TrackingState, b: LensCustomerSDK.AR_TrackingState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum SupportedTools : Swift.String {
  case ARROW, PENCIL, RECTANGLE, ELLIPSE, AR_MEASURE, AR_NOTES, POINTER, FLASH, SELECT
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MexType : Swift.Int32 {
  case PIN_PAGE_DETAILS
  case PIN_USER_VIDEO_RECEIVE
  public init?(rawValue: Swift.Int32)
  public typealias RawValue = Swift.Int32
  public var rawValue: Swift.Int32 {
    get
  }
}
@objc @_Concurrency.MainActor @preconcurrency open class ChatletViewController : UIKit.UIViewController, WebKit.WKDownloadDelegate, WebKit.WKNavigationDelegate, WebKit.WKUIDelegate {
  @_Concurrency.MainActor @preconcurrency public var new_chat_notification: LensCustomerSDK.LensBind<Swift.Bool>
  @_Concurrency.MainActor @preconcurrency public var chat_open_request: LensCustomerSDK.LensBind<Swift.Bool>
  @_Concurrency.MainActor @preconcurrency public init(connection_param: any LensCustomerSDK.CommonConnectionParams)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency public func load_chatlet_if_not_loaded_already()
  @_Concurrency.MainActor @preconcurrency public func logout_user()
  @objc deinit
}
extension LensCustomerSDK.ChatletViewController {
  @_Concurrency.MainActor @preconcurrency public func send_chat(_ chat_text: Swift.String)
}
extension LensCustomerSDK.ChatletViewController {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didCommit navigation: WebKit.WKNavigation!)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didStartProvisionalNavigation navigation: WebKit.WKNavigation!)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation!)
  @available(iOS 13.0, *)
  @_Concurrency.MainActor @preconcurrency public func webView(_ webView: WebKit.WKWebView, navigationAction: WebKit.WKNavigationAction, preferences: WebKit.WKWebpagePreferences, decisionHandler: @escaping (WebKit.WKNavigationActionPolicy, WebKit.WKWebpagePreferences) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationResponse: WebKit.WKNavigationResponse, decisionHandler: @escaping (WebKit.WKNavigationResponsePolicy) -> Swift.Void)
}
extension LensCustomerSDK.ChatletViewController : WebKit.WKScriptMessageHandler {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func userContentController(_ userContentController: WebKit.WKUserContentController, didReceive message: WebKit.WKScriptMessage)
}
extension LensCustomerSDK.ChatletViewController {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, createWebViewWith configuration: WebKit.WKWebViewConfiguration, for navigationAction: WebKit.WKNavigationAction, windowFeatures: WebKit.WKWindowFeatures) -> WebKit.WKWebView?
  @available(iOS 14.5, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, navigationAction: WebKit.WKNavigationAction, didBecome download: WebKit.WKDownload)
  @available(iOS 14.5, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func download(_ download: WebKit.WKDownload, decideDestinationUsing response: Foundation.URLResponse, suggestedFilename: Swift.String, completionHandler: @escaping (Foundation.URL?) -> Swift.Void)
  @available(iOS 14.5, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func downloadDidFinish(_ download: WebKit.WKDownload)
  @available(iOS 14.5, *)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func download(_ download: WebKit.WKDownload, didFailWithError error: any Swift.Error, resumeData: Foundation.Data?)
}
@objc @_hasMissingDesignatedInitializers public class Chat : LensCustomerSDK.BaseParser {
  public var clientID: Foundation.NSNumber?
  final public let message: Swift.String?
  public var participant: LensCustomerSDK.Participant?
  final public let date: Foundation.Date
  public init(with chatMsg: Swift.String?)
  @objc deinit
}
public struct LensSessionContent {
  public enum Session : Swift.String {
    case Invite
    case noChat
    case invalid_client
    case invalid_key
    case Nointernet
    case oopsWrong
    case sessionExpired
    case timeout
    case leaveSession
    case planError_Standard_Above
    case planError_Professional
    case planError_Annotation
    case customerJoined
    case customerLeft
    case exitWarning
    case clearAnnotaionConfirmation
    case diffLocation
    case inviteTechnician
    case inviteTechnicianDescription
    case inviteInternalTechnicianDescription
    case inviteExternalTechnicianDescription
    case shareCopyInviteTechnician
    case share
    case copy
    case customer_already_active_join_as_technician
    case customer_already_active_signin_as_technician
    case secTechEntryRequestTitle
    case secTechEntryRequestDesc
    case secTechEntryRequestAccept
    case secTechEntryRequestReject
    case emailInviteFailedTitle
    case emailInviteFailedDesc
    case inviteeNotInOrgTitle
    case inviteeNotInOrgDesc
    case inviteSentSuccess
    case shareSessionLink
    case sessionLinkCopied
    public var localized: Swift.String {
      get
    }
    public enum Scan : Swift.String {
      case scanError
      public var localized: Swift.String {
        get
      }
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Chat : Swift.String {
    case placeHolder
    case title
    case loading_chat
    case download_completed
    case downloaded_files_can_be_viewed_in_FilesApp
    case starting_download
    case wait_until_previous_download_finishes
    case download_failed
    case download_error_description
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum InviteUser : Swift.String {
    case inviteCustomerTitle
    case inviteTechnicianTitle
    case enterCustomerid
    case inviteCustomerDescription
    case linkDescription
    case invitationSentToCustomer
    case copiedInviteLink
    public var localized: Swift.String {
      get
    }
    public enum Error : Swift.String {
      case failed
      public var localized: Swift.String {
        get
      }
      public static func invalidEmail() -> Swift.String
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ErrorMsg : Swift.String {
    case accessDeniedMsgForPhotos
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Notes : Swift.String {
    case noteUpdate
    case noteUpdateFailed
    case noteFetchFailed
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Common : Swift.String {
    case loading
    case connecting
    case joining
    case deleting
    case invalidEmail
    case guest
    case exit
    case cancel
    case end
    case reply
    case send
    case ok
    case settings
    case capturing
    case wait
    case yes
    case no
    case customer
    case deny
    case allow
    case view_now
    case refresh
    case close
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ARErroMessage : Swift.String {
    case excessiveMotion
    case insufficientFeatures
    case notAvailable
    case relocalizing
    case initializing
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Snapshot : Swift.String {
    case failure
    case success
    case deleteSuccess
    case deleteFailure
    case deleteConfirmation
    case freezeSuccess
    case freezeInprogress
    case unfreezed
    case streamPaused
    case recodingEnabled
    case recordingStopped
    case storageExceeded
    case recordingNotEnabled
    case selectAll
    case view
    case clear
    case screenshotDownloadFailed
    case freezeAlert
    case freezeAlertHeader
    case freezeAnnotateDownstreamer
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum CustomerActionContent : Swift.String {
    case muteAudio
    case unmuteAudio
    case pauseVideo
    case resumeVideo
    case lockDevice
    case unlockDevice
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ShareCamera : Swift.String {
    case share
    case shareMsgDescription
    case shareMsgDescByPrimaryTech
    case stopShareCamera
    case stopShareCameraDescription
    case shareCameraTechRequestTitle
    case shareCameraTechRequestDesc
    case noneSharing
    public var localized: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Flash : Swift.String {
    case flash_title
    case flash_light_on
    case flash_light_off
    case flash_light_on_failed
    case flash_light_off_failed
    public var localized: Swift.String {
      get
    }
    public static func flash_light_on(by_participant: Swift.String) -> Swift.String
    public static func flash_light_off(by_participant: Swift.String) -> Swift.String
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension Foundation.Data {
  public var utf8String: Swift.String? {
    get
  }
  public var asciiString: Swift.String? {
    get
  }
  public var isoLatin1: Swift.String? {
    get
  }
  public var jsonData: LensCustomerSDK.JSON? {
    get
  }
  public func getInt64(startIndex: Swift.Int) -> Swift.Int64
  public func getInt32(startIndex: Swift.Int) -> Swift.Int32
  public func getInt16(startIndex: Swift.Int) -> Swift.Int16
  public func getInt8(startIndex: Swift.Int) -> Swift.Int8
  public func getString(startIndex: Swift.Int, length: Swift.Int) -> Swift.String?
  public func get<T>(startIndex: Swift.Int, _: T.Type) -> T
  public mutating func appendValue<T>(_ value: T)
  public mutating func appendValue(_ value: Swift.String)
}
extension Swift.Dictionary {
  public var jsonData: Foundation.Data? {
    get
  }
}
extension Swift.String {
  public static let EMPTY: Swift.String
  public static let SPACE: Swift.String
  public static let ZERO: Swift.String
  public static let ONE: Swift.String
  public static let MINUS_ONE: Swift.String!
  public static let UNDERSCORE: Swift.String!
  public static let HASH: Swift.String!
  public static let NEW_LINE: Swift.String!
  public static let LESS_THAN: Swift.String!
  public static let GREATER_THAN: Swift.String!
  public static let EQUALS: Swift.String!
  public static let PLUS: Swift.String!
  public static let HYPHEN: Swift.String!
  public static let COMMA: Swift.String!
  public static let COLON: Swift.String!
  public static let SEMI_COLON: Swift.String!
  public static let AMPERSAND: Swift.String!
  public static let ASTERISK: Swift.String!
  public static let DOT: Swift.String!
  public static let SINGLE_QUOTE: Swift.String
  public static let DOUBLE_QUOTE: Swift.String
  public static let FORWARD_SLASH: Swift.String
  public static let BACK_SLASH: Swift.String
  public static let HTML_AMPERSAND_1: Swift.String
  public static let HTML_AMPERSAND_2: Swift.String
  public static let HTML_LESS_THAN: Swift.String
  public static let HTML_GREATER_THAN: Swift.String
  public static let HTML_SINGLE_QUOTE_1: Swift.String
  public static let HTML_SINGLE_QUOTE_2: Swift.String
  public static let HTML_DOUBLE_QUOTE: Swift.String
  public static let HTML_NEW_LINE: Swift.String
  public static let BOOL_TRUE: Swift.String
  public static let BOOL_FALSE: Swift.String
  public static let ZST_ERROR_PLACEHOLDER: Swift.String
  public func jsonStringParse() -> Any?
  public func heightWithConstrainedWidth(width: CoreFoundation.CGFloat, font: UIKit.UIFont) -> CoreFoundation.CGFloat
}
public protocol LensSessionProtocolDelegate {
  func flash_change(is_supported: Swift.Bool?, current_flash_status: Swift.Bool)
  func flash_change_triggered(by_participant_name: Swift.String?, isOn: Swift.Bool)
  func flash_change_failed(error_message: Swift.String, isOn: Swift.Bool)
  func chatlet_feature_status(is_enabled: Swift.Bool)
}
public typealias JSON = [Swift.String : Any]
public typealias JSONKey = Swift.String
public struct JsonParser {
  public var json: LensCustomerSDK.JSON
  public init?(json: LensCustomerSDK.JSON?)
  public subscript<DataType>(key: LensCustomerSDK.JSONKey) -> DataType? {
    get
  }
  public func jsonParser(forKey key: LensCustomerSDK.JSONKey) -> LensCustomerSDK.JsonParser?
  public func jsonParsers(forKey key: LensCustomerSDK.JSONKey) -> [LensCustomerSDK.JsonParser]?
}
public class LensBind<T> {
  public typealias Listener = (T) -> Swift.Void
  public var value: T {
    get
    set
  }
  public init(_ value: T)
  public func bind(listener: LensCustomerSDK.LensBind<T>.Listener?)
  @objc deinit
}
public struct RoomCredential {
}
public struct TalkSettings {
}
public struct SessionDetails : Swift.Decodable {
  public var session_token: Swift.String?
  public let zsoid: Swift.String
  public let customer_join_link: Swift.String
  public let session_key: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public struct GatewayDetails : Swift.Decodable {
  public let web_socket_path: Swift.String
  public let group: Swift.String
  public let gateway_servers: [Swift.String]
  public init(from decoder: any Swift.Decoder) throws
}
public struct ClientDetails : Swift.Decodable {
  public let client_id: Swift.String
  public let client_role: Swift.Int
  public let client_token: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public protocol AudioSessionProtocol : AnyObject {
  func didChangeRoute(_ audioDescription: AVFAudio.AVAudioSessionRouteDescription, reason: AVFAudio.AVAudioSession.RouteChangeReason)
}
public protocol LensSignallingProtocol : AnyObject {
  func renderingView(_ view: UIKit.UIView?)
  func didChangeLensConnectionState(state: LensCustomerSDK.AssisLensStates)
  func didChange(_ participant: LensCustomerSDK.Participant)
  func refreshBottomMenu()
  func didChangeARState(tracking state: ARKit.ARCamera.TrackingState)
  func participantRejoined(clientId: Swift.String)
  func onScanSuccess(scanResult: LensCustomerSDK.ScanModel)
  func onScanFailure(scanError: LensCustomerSDK.ScanError)
  func onSessionValidationDone()
  func onTechnicianPerform(draw shape: LensCustomerSDK.DrawingInput.DrawShape)
  func conferenceReceived(type: LensCustomerSDK.ConferenceType)
  func newFreezeAcknowledgement()
  func unFreezeFinalAction()
  func showFreezedImage()
}
extension LensCustomerSDK.LensSignallingProtocol {
  public func onSessionValidationDone()
  public func onTechnicianPerform(draw shape: LensCustomerSDK.DrawingInput.DrawShape)
  public func conferenceReceived(type: LensCustomerSDK.ConferenceType)
  public func newFreezeAcknowledgement()
  public func unFreezeFinalAction()
  public func showFreezedImage()
  public func participantRejoined(clientId: Swift.String)
}
public protocol ChatProtocol : AnyObject {
  func didReceive(_ chat: LensCustomerSDK.Chat)
}
public protocol CommonConnectionParams {
  var key: Swift.String { get }
  var session_details: LensCustomerSDK.SessionDetails { get set }
  var gateway_details: LensCustomerSDK.GatewayDetails { get }
  var client_details: LensCustomerSDK.ClientDetails { get }
}
public protocol CustomerSessionParams : LensCustomerSDK.CommonConnectionParams {
}
public protocol TechnicianSessionParams : LensCustomerSDK.CommonConnectionParams {
  var isSessionHost: Swift.Bool { get }
}
public enum VariacType : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  case int(Swift.Int)
  case string(Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
public protocol ARProtocol : AnyObject {
  func onArCommentsReceived(annotationNode: LensCustomerSDK.AnnotationNotify)
  func onAnchorSelectionChanged(annotationId: Swift.String, state: LensCustomerSDK.AnnotationSelection, triggerId: Swift.String)
  func onAnchorPlaced(annotationId: Swift.String)
  func onAnchorRemoved(annotationId: Swift.String)
  var isARSupported: Swift.Bool { get }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class BaseParser : ObjectiveC.NSObject {
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
public enum SDKLensLottieType : LensCustomerSDK.LottieType {
  case loader
  public var lottie: LensCustomerSDK.LottieAnimationView {
    get
  }
  public var lottieName: Swift.String {
    get
  }
  public var message: Swift.String? {
    get
  }
  public var size: CoreFoundation.CGSize? {
    get
  }
  public static func == (a: LensCustomerSDK.SDKLensLottieType, b: LensCustomerSDK.SDKLensLottieType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
public struct ZAssistAlertModel {
  public init(alertConfig: LensCustomerSDK.Alert_Configs, footer_config: LensCustomerSDK.Footer_Configs? = nil, actions: [LensCustomerSDK.ZAssistAlertAction], action_buttons_axis: UIKit.NSLayoutConstraint.Axis = .horizontal)
  public let alert_config: LensCustomerSDK.Alert_Configs
  public var footer_config: LensCustomerSDK.Footer_Configs?
  public let actions: [LensCustomerSDK.ZAssistAlertAction]
  public var action_buttons_axis: UIKit.NSLayoutConstraint.Axis
}
@available(iOSApplicationExtension, unavailable)
public struct ZAssistAlertAction : Swift.Equatable {
  public init(title: Swift.String, title_color: UIKit.UIColor = .color(dark: .white, light: .black), bg_color: UIKit.UIColor = .clear, is_priority: Swift.Bool = false, action: ((LensCustomerSDK.ZAssistAlertAction) -> ()?)? = nil)
  public let title: Swift.String
  public var title_color: UIKit.UIColor
  public var bg_color: UIKit.UIColor
  public var is_priority: Swift.Bool
  public var action: ((LensCustomerSDK.ZAssistAlertAction) -> ()?)?
  public static func == (lhs: LensCustomerSDK.ZAssistAlertAction, rhs: LensCustomerSDK.ZAssistAlertAction) -> Swift.Bool
}
@available(iOSApplicationExtension, unavailable)
public struct Alert_Configs {
  public init(title: Swift.String? = nil, body: Foundation.NSAttributedString? = nil)
  public var title: Swift.String?
  public var title_color: UIKit.UIColor
  public var alert_bg_color: UIKit.UIColor
  public var body: Foundation.NSAttributedString?
}
@available(iOSApplicationExtension, unavailable)
public struct Check_Box_Configuration {
  public init(icon_font: UIKit.UIFont, selected_check_box: Swift.String, unselected_check_box: Swift.String, defaultValue: Swift.Bool = true, onChange: ((Swift.Bool) -> ())? = nil)
  public var icon_font: UIKit.UIFont
  public var selected_check_box: Swift.String
  public var selected_check_box_color: UIKit.UIColor
  public var unselected_check_box: Swift.String
  public var unselected_check_box_color: UIKit.UIColor
  public var defaultValue: Swift.Bool
  public var onChange: ((Swift.Bool) -> ())?
}
@available(iOSApplicationExtension, unavailable)
public struct Footer_Configs {
  public init(bg_color: UIKit.UIColor = .clear, text_color: UIKit.UIColor = .color(dark: .white, light: .black), footer_note: Swift.String, check_box_configuration: LensCustomerSDK.Check_Box_Configuration? = nil)
  public var bg_color: UIKit.UIColor
  public var text_color: UIKit.UIColor
  public let footer_note: Swift.String
  public var check_box_configuration: LensCustomerSDK.Check_Box_Configuration?
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class ZAssistAlert : LensCustomerSDK.OverlayViewController {
  @_Concurrency.MainActor @preconcurrency public var delegate: (any UIKit.UITextViewDelegate)?
  @_Concurrency.MainActor @preconcurrency convenience public init(with model: LensCustomerSDK.ZAssistAlertModel)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LensCustomer : LensCustomerSDK.Lens {
  weak public var otherActionDelegate: (any LensCustomerSDK.OtherActionProtocol)?
  public var getStreamType: LensCustomerSDK.StreamingType? {
    get
  }
  public init(connectionParam: any LensCustomerSDK.CustomerSessionParams, name: Swift.String, email: Swift.String, isARSupported: Swift.Bool = false)
  public func startSession()
  public static func validateSessionForSDK(sessionKey key: Swift.String, token: Swift.String, completion: @escaping (LensCustomerSDK.SessionValidationResponse) -> Swift.Void)
  @objc deinit
}
extension LensCustomerSDK.LensCustomer {
  @discardableResult
  public func muteAudio() -> Swift.Bool
  @discardableResult
  public func unmuteAudio() -> Swift.Bool
  @discardableResult
  public func muteVideo() -> Swift.Bool
  @discardableResult
  public func unmuteVideo() -> Swift.Bool
  public func speakerOn()
  public func speakerOff()
  public func closeRoom()
  public func shareCamera()
  public func stopCamera()
}
extension LensCustomerSDK.Lens : LensCustomerSDK.AudioSessionProtocol {
  public func didChangeRoute(_ audioDescription: AVFAudio.AVAudioSessionRouteDescription, reason: AVFAudio.AVAudioSession.RouteChangeReason)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class ImageScrollView : UIKit.UIScrollView, UIKit.UIScrollViewDelegate {
  public enum ContentMode : Swift.Int {
    case aspectFill
    case aspectFit
    case widthFill
    case heightFill
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum Offset : Swift.Int {
    case begining
    case center
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var isImageInZoomState: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency open var imageContentMode: LensCustomerSDK.ImageScrollView.ContentMode
  @_Concurrency.MainActor @preconcurrency open var initialOffset: LensCustomerSDK.ImageScrollView.Offset
  @_Concurrency.MainActor @preconcurrency weak public var zoomView: UIKit.UIView?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var frame: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency public func adjustFrameToCenter()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency open func display(image res: CoreFoundation.CGSize)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func removeFromSuperview()
  @_Concurrency.MainActor @preconcurrency @objc public func viewForZooming(in scrollView: UIKit.UIScrollView) -> UIKit.UIView?
  @_Concurrency.MainActor @preconcurrency @objc public func scrollViewDidZoom(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc public func scrollViewDidEndZooming(_ scrollView: UIKit.UIScrollView, with view: UIKit.UIView?, atScale scale: CoreFoundation.CGFloat)
}
public struct DrawingInput {
  public enum DrawShape : Swift.String {
    case ellipse, pencil, rectangle, arrow, pointer
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var id: Swift.String
  public var triggerId: Swift.String
  public var annotationType: LensCustomerSDK.DrawingInput.DrawShape
  public var storkeColor: UIKit.UIColor
  public var start: CoreFoundation.CGPoint!
  public var end: CoreFoundation.CGPoint!
  public var fillColor: UIKit.UIColor
  public var fadeOutDelay: Swift.Int
  public var name: Swift.String
  public enum FreeStyleState : Swift.String {
    case mouse_move, mouse_up
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var freeStyleState: LensCustomerSDK.DrawingInput.FreeStyleState?
  public var size: CoreFoundation.CGSize {
    get
  }
  public var frame: CoreFoundation.CGRect {
    get
    set
  }
  public var line_width: CoreFoundation.CGFloat
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func showNotificationBanner(message: Swift.String, show duration: Foundation.TimeInterval = 4, completion: (() -> Swift.Void)? = nil)
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func showLottie(lottie type: any LensCustomerSDK.LottieType, onTap: ((UIKit.UIButton) -> (() -> Swift.Void)?)? = nil, lottieBackgroundColor: UIKit.UIColor = UIColor.white, subViewIndex: Swift.Int = -1, tag: Swift.Int? = 43566534)
  @_Concurrency.MainActor @preconcurrency public func dismissLottieView()
  @_Concurrency.MainActor @preconcurrency public func at_showLoader(with size: CoreFoundation.CGSize = CGSize.init(width: 100, height: 100), overViewColor: UIKit.UIColor = UIColor.black.withAlphaComponent(0.5), text: Swift.String = "", textColor: UIKit.UIColor = .white)
  @_Concurrency.MainActor @preconcurrency public var at_isLoaderHidden: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func at_hideLoader()
}
extension ObjectiveC.NSObject {
  public func hapticMediumImpact()
  public func hapticWarningImpact()
  public func hapticSuccessImpact()
  public func hapticErrorImpact()
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AudioSessionHandler : ObjectiveC.NSObject {
  weak public var delegate: (any LensCustomerSDK.AudioSessionProtocol)?
  convenience public init(with delegate: any LensCustomerSDK.AudioSessionProtocol)
  public func set(_ port: AVFAudio.AVAudioSession.PortOverride, completion: @escaping (Swift.Bool) -> ())
  @objc deinit
}
extension LensCustomerSDK.AudioSessionHandler : WebRTC.RTCAudioSessionDelegate {
  @objc dynamic public func audioSessionDidChangeRoute(_ session: WebRTC.RTCAudioSession, reason: AVFAudio.AVAudioSession.RouteChangeReason, previousRoute: AVFAudio.AVAudioSessionRouteDescription)
}
public enum LensFlashError : Swift.String, Swift.Error {
  case unable_to_turn_on_the_flash
  case unable_to_turn_off_the_flash
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct LensFlashNotification {
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class LensFlashCoordinator : ObjectiveC.NSObject {
  public typealias FlashChangeNotification = (LensCustomerSDK.LensFlashNotification) -> ()
  public func reset_upstreamer_flash_info()
  public func update_upstreamer_flash_info(is_supported: Swift.Bool, is_On: Swift.Bool, notify_needed: Swift.Bool)
  public func force_stop_the_flashlight()
  public func current_device_has_flash(is_front_camera: Swift.Bool = false) -> Swift.Bool
  public func current_device_flash_status() -> Swift.Bool
  public func current_device_flash_toggle(trigger_Id: Foundation.NSNumber?)
  @objc deinit
}
public class DrawingShapes {
  final public let superShapeLayer: QuartzCore.CAShapeLayer
  weak public var view: UIKit.UIView?
  public init(with view: UIKit.UIView, within rect: CoreFoundation.CGRect)
  public func draw(with drawParm: LensCustomerSDK.DrawingInput, lineDashPattern: [Foundation.NSNumber]? = nil)
  public func clearPath(for id: Swift.String)
  public func clearAll()
  @objc deinit
}
extension LensCustomerSDK.Lens {
  public func requestOCR()
  public func requestQR(retryMode: LensCustomerSDK.QRRetryMode)
}
public protocol OtherActionProtocol : AnyObject {
  func onTechnicianPerform(action: LensCustomerSDK.TechnicianAction)
  var isCustomerVideoMuted: Swift.Bool { get }
  func onShareCameraResponse(action: LensCustomerSDK.ShareCameraTechAction, participant: LensCustomerSDK.Participant?)
  func showNotificationBanner(msg: Swift.String)
  func onVideoStateChanged(status: Swift.Bool)
  func onFreezeSuccess(fromUpstreamer: Swift.Bool)
  func onFreezeFailure()
  func onUnfreezed()
  func didReceiveAnnotation(input: LensCustomerSDK.DrawingInput?, isClear: Swift.Bool)
  func onCameraSwitch(isFront: Swift.Bool)
}
extension LensCustomerSDK.OtherActionProtocol {
  public func didReceiveAnnotation(input: LensCustomerSDK.DrawingInput?, isClear: Swift.Bool)
}
@_hasMissingDesignatedInitializers @objc(ARNode) @_Concurrency.MainActor @preconcurrency public class Node : SceneKit.SCNNode {
  @_Concurrency.MainActor @preconcurrency public static var DEFAULT_USER_ID: Swift.String {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func createOutlineNode() -> SceneKit.SCNNode
  @objc deinit
}
extension LensCustomerSDK.Node : Swift.Comparable {
  @_Concurrency.MainActor @preconcurrency public static func < (lhs: LensCustomerSDK.Node, rhs: LensCustomerSDK.Node) -> Swift.Bool
}
public protocol AnnotationSelectionListener : AnyObject {
  func onAnnotationSelected(id: Swift.String, triggerId: Swift.String)
  func onAnnotationDeselected(id: Swift.String, triggerId: Swift.String)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class LineNode : LensCustomerSDK.Node {
  @_Concurrency.MainActor @preconcurrency public static let LINE_NODE_NAME: Swift.String
  @_Concurrency.MainActor @preconcurrency public func reset()
  @_Concurrency.MainActor @preconcurrency public func getLineVertextCameraPoint(forIndex index: Swift.Int) -> SceneKit.SCNVector3
  @_Concurrency.MainActor @preconcurrency public func getLineVertexCameraNode(forIndex index: Swift.Int) -> SceneKit.SCNNode
  @_Concurrency.MainActor @preconcurrency public func addWorldPointAndCreateVertices(sceneView: ARKit.ARSCNView, worldPoint: SceneKit.SCNVector3, withInvertedTriangle isInvertedTriangle: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func addPointAndCreateVertices(sceneView: ARKit.ARSCNView, wx: Swift.Float, wy: Swift.Float, wz: Swift.Float, withInvertedTriangle isInvertedTriangle: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency override public func createOutlineNode() -> SceneKit.SCNNode
  @objc deinit
}
@_inheritsConvenienceInitializers @available(iOS 11.0, *)
@objc public class ViewAR : ObjectiveC.NSObject {
  @objc public static var orientation: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension LensCustomerSDK.ARRenderView {
  @_Concurrency.MainActor @preconcurrency public func measurement_Trigger_Action()
  @_Concurrency.MainActor @preconcurrency public func undoLastARMeaserment()
  @_Concurrency.MainActor @preconcurrency public func undoInprogressARMeasurement()
  @_Concurrency.MainActor @preconcurrency public func undoLastCustomerAnnotation()
}
@objc public enum ARInputViewOrientation : Swift.Int {
  case portrait = 1
  case landscapeLeft = 3
  case landscapeRight = 4
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum ARInputViewOrientationMode {
  case auto
  case all
  case manual(subviews: [UIKit.UIView])
  case disabled
}
public protocol AnchorStateListener {
  func onAnchorPlaced(annotationId: Swift.String, annotationColor: UIKit.UIColor, annotationType: Swift.String, annotationNumber: Swift.Int, triggerId: Swift.String, length: Swift.String?)
  func onAnchorRemoved(annotationId: Swift.String)
}
@available(iOS 11.0, *)
@objc public protocol RenderARDelegate {
  @objc func frame(didRender buffer: CoreVideo.CVPixelBuffer, with time: CoreMedia.CMTime, using rawBuffer: CoreVideo.CVPixelBuffer)
}
public class CustomCircularArray<E> {
  public init(ofSize size: Swift.Int)
  public func setOverwriteCallback(_ callback: ((E, Swift.Int) -> ())?)
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public func clear()
  public func get(index: Swift.Int) -> E?
  public var first: E? {
    get
  }
  public var last: E? {
    get
  }
  public func popLast() -> E?
  public func popFirst() -> E?
  public func push(element: E)
  public func remove(forWhich: (E) -> Swift.Bool) -> [E?]
  public func remove(index: Swift.Int)
  public func nextIndex() -> Swift.Int
  public func getMaxElementCount() -> Swift.Int
  @objc deinit
}
extension UIKit.UILabel {
  @_Concurrency.MainActor @preconcurrency public func set(icon: any LensCustomerSDK.ATIcon, iconSize: CoreFoundation.CGFloat? = nil, color: UIKit.UIColor? = nil)
}
public protocol ATIcon {
  var iconString: Swift.String { get }
  var iconSize: CoreFoundation.CGFloat { get }
  var description: Swift.String? { get }
  var iconNormalColor: UIKit.UIColor? { get }
  var iconSelectedColor: UIKit.UIColor? { get }
  var iconDisabledColor: UIKit.UIColor? { get }
  func iconFont(size: CoreFoundation.CGFloat) -> UIKit.UIFont
}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UIButton {
  @_Concurrency.MainActor @preconcurrency public func set(icon: any LensCustomerSDK.ATIcon, iconSize: CoreFoundation.CGFloat? = nil, iconColor: UIKit.UIColor? = nil, for controlStates: [UIKit.UIControl.State] = [.normal, .highlighted])
}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UIBarButtonItem {
  @_Concurrency.MainActor @preconcurrency public func set(icon: any LensCustomerSDK.ATIcon, iconSize: CoreFoundation.CGFloat? = nil, iconColor: UIKit.UIColor? = nil, for controlStates: [UIKit.UIControl.State] = [.normal, .highlighted,.selected])
}
@objc @_hasMissingDesignatedInitializers public class RemovePointerOperation : Foundation.Operation {
  @objc override dynamic public func cancel()
  @objc override dynamic public func main()
  @objc deinit
}
extension UIKit.UIImage {
  public static func getPointerTexture(color: UIKit.UIColor) -> UIKit.UIImage?
  public static func getPlaneTexture() -> UIKit.UIImage?
  public static func getBorderTexture() -> UIKit.UIImage?
  public static func getBorderLineTexture() -> UIKit.UIImage?
  public static func getCancelButtonTexture() -> UIKit.UIImage?
  public static func getARNotesButtonTexture() -> UIKit.UIImage?
}
public protocol ARViewDelegate : AnyObject {
  func didChange(tracking state: ARKit.ARCamera.TrackingState)
}
public protocol ARVideoDelegate : AnyObject {
  func didChanged(_ size: CoreFoundation.CGSize)
  func onVideoFrameUpdate(frameBuffer: CoreVideo.CVPixelBuffer, rotation: Swift.Int, timestamp: Swift.Int64)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class Pointer : LensCustomerSDK.Node {
  @_Concurrency.MainActor @preconcurrency public static let POINTER_NODE_NAME: Swift.String
  @_Concurrency.MainActor @preconcurrency public static let DEFAULT_BOX_HEIGHT: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public static let DEFAULT_BOX_WIDTH: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public static let DEFAULT_FADE_OUT_DELAY: Swift.Int
  @_Concurrency.MainActor @preconcurrency public static let DEFAULT_FADE_OUT_DURATION: Swift.Int
  @_Concurrency.MainActor @preconcurrency public static let DEFAULT_POINTER_SCALE: Swift.Float
  @_Concurrency.MainActor @preconcurrency public var fadeOutDelay: Swift.Int
  @_Concurrency.MainActor @preconcurrency public var fadeOutDuration: Swift.Int
  @_Concurrency.MainActor @preconcurrency public var currentDefaultScale: Swift.Float
  @_Concurrency.MainActor @preconcurrency final public let pointerColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public func updateScaleRelativeToCamera(camera: ARKit.ARCamera)
  @_Concurrency.MainActor @preconcurrency public func updateScaleRelativeToCamera(distanceToCamera distance: Swift.Float)
  @_Concurrency.MainActor @preconcurrency public static func constructPointerName(withId id: Swift.String) -> Swift.String
  @objc deinit
}
public protocol NodeStateChangeCallback {
  func onNodeDeleteRequested(node: LensCustomerSDK.Node)
}
@available(iOSApplicationExtension, unavailable)
public protocol ControllerReusable {
  static var at_storyBoardId: Swift.String { get }
  static var at_storyBoard: UIKit.UIStoryboard { get }
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.ControllerReusable {
  public static func at_storyBoardInstance<T>() -> T where T : UIKit.UIViewController
}
@available(iOSApplicationExtension, unavailable)
public protocol ViewResuable {
  static var owner: Any? { get }
  static var nibName: Swift.String { get }
  static var bundle: Foundation.Bundle { get }
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.ViewResuable where Self : UIKit.UIView {
  public static var owner: Any? {
    get
  }
  public static var bundle: Foundation.Bundle {
    get
  }
  public static var nibName: Swift.String {
    get
  }
  public static var view: UIKit.UIView {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
public protocol CellResuable {
  static var identifier: Swift.String { get }
  static var nibName: Swift.String { get }
  static var bundle: Foundation.Bundle { get }
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.CellResuable where Self : UIKit.UIView {
  public static var bundle: Foundation.Bundle {
    get
  }
  public static var nibName: Swift.String {
    get
  }
  public static var nib: UIKit.UINib {
    get
  }
}
extension LensCustomerSDK.LottieColor : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public enum ReducedMotionOption {
  case specific(LensCustomerSDK.ReducedMotionMode)
  case dynamic(any LensCustomerSDK.ReducedMotionOptionProvider, dataID: Swift.AnyHashable)
}
extension LensCustomerSDK.ReducedMotionOption {
  public static var standardMotion: LensCustomerSDK.ReducedMotionOption {
    get
  }
  public static var reducedMotion: LensCustomerSDK.ReducedMotionOption {
    get
  }
  public static var systemReducedMotionToggle: LensCustomerSDK.ReducedMotionOption {
    get
  }
}
extension LensCustomerSDK.ReducedMotionOption {
  public var currentReducedMotionMode: LensCustomerSDK.ReducedMotionMode {
    get
  }
}
extension LensCustomerSDK.ReducedMotionOption : Swift.Hashable {
  public static func == (lhs: LensCustomerSDK.ReducedMotionOption, rhs: LensCustomerSDK.ReducedMotionOption) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ReducedMotionMode : Swift.Hashable {
  case standardMotion
  case reducedMotion
  public static func == (a: LensCustomerSDK.ReducedMotionMode, b: LensCustomerSDK.ReducedMotionMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ReducedMotionOptionProvider {
  var currentReducedMotionMode: LensCustomerSDK.ReducedMotionMode { get }
}
public struct SystemReducedMotionOptionProvider : LensCustomerSDK.ReducedMotionOptionProvider {
  public init()
  public var currentReducedMotionMode: LensCustomerSDK.ReducedMotionMode {
    get
  }
}
public enum VMHTTPMethod : Swift.String {
  case post, get, put, delete
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum VMSessionError : Swift.String, Swift.Error {
  case invalidURLString, sessionNotConfigured
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum VMResponseType {
  case data, dictionary
  public static func == (a: LensCustomerSDK.VMResponseType, b: LensCustomerSDK.VMResponseType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class VMSessionManager {
  final public let requestSerialization: LensCustomerSDK.VMRequestSerialization
  final public let responseSerialization: LensCustomerSDK.VMResponseSerialization
  public typealias ApiSuccess = (_ data: Foundation.Data?, _ dictionary: [Swift.String : Any]?, _ response: Foundation.HTTPURLResponse) -> Swift.Void
  public typealias ApiFailure = ((any Swift.Error)?) -> Swift.Void
  public var session: LensCustomerSDK.VMSession {
    get
    set
  }
  public static var manager: LensCustomerSDK.VMSessionManager {
    get
  }
  public init(reqSer: LensCustomerSDK.VMRequestSerialization = VMRequestSerialization(), respSer: LensCustomerSDK.VMResponseSerialization = VMResponseSerialization(), config: Foundation.URLSessionConfiguration = .default)
  public func GET(API: Swift.String, requestSerialization: LensCustomerSDK.VMRequestSerialization? = nil, params: [Swift.String : Swift.String] = [:], success: @escaping LensCustomerSDK.VMSessionManager.ApiSuccess, failure: @escaping LensCustomerSDK.VMSessionManager.ApiFailure)
  public func PUT(API: Swift.String, requestSerialization: LensCustomerSDK.VMRequestSerialization? = nil, params: [Swift.String : Swift.String] = [:], success: @escaping LensCustomerSDK.VMSessionManager.ApiSuccess, failure: @escaping LensCustomerSDK.VMSessionManager.ApiFailure)
  public func DELETE(API: Swift.String, requestSerialization: LensCustomerSDK.VMRequestSerialization? = nil, params: [Swift.String : Swift.String] = [:], success: @escaping LensCustomerSDK.VMSessionManager.ApiSuccess, failure: @escaping LensCustomerSDK.VMSessionManager.ApiFailure)
  public func POST(API: Swift.String, requestSerialization: LensCustomerSDK.VMRequestSerialization? = nil, params: [Swift.String : Any] = [:], success: @escaping LensCustomerSDK.VMSessionManager.ApiSuccess, failure: @escaping LensCustomerSDK.VMSessionManager.ApiFailure)
  public func hitAPI(_ method: LensCustomerSDK.VMHTTPMethod, _ API: Swift.String, _ requestSerialization: LensCustomerSDK.VMRequestSerialization? = nil, _ params: [Swift.String : Any] = [:], _ success: @escaping LensCustomerSDK.VMSessionManager.ApiSuccess, _ failure: @escaping LensCustomerSDK.VMSessionManager.ApiFailure, _ requestConfiguration: ((Foundation.URLRequest) -> Swift.Void)? = nil)
  public func hitUploadAPI(_ method: LensCustomerSDK.VMHTTPMethod, httpBodyData: Foundation.Data, _ API: Swift.String, _ requestSerialization: LensCustomerSDK.VMRequestSerialization? = nil, _ params: [Swift.String : Any] = [:], _ success: @escaping LensCustomerSDK.VMSessionManager.ApiSuccess, _ failure: @escaping LensCustomerSDK.VMSessionManager.ApiFailure, _ requestConfiguration: ((Foundation.URLRequest) -> Swift.Void)? = nil)
  public func invalidCancelSession()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Asset : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  final public let id: Swift.String
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
extension LensCustomerSDK.Asset : @unchecked Swift.Sendable {
}
public enum LayerType : Swift.Int, Swift.Codable {
  case precomp
  case solid
  case image
  case null
  case shape
  case text
  case unknown
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum MatteType : Swift.Int, Swift.Codable {
  case none
  case add
  case invert
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum BlendMode : Swift.Int, Swift.Codable {
  case normal
  case multiply
  case screen
  case overlay
  case darken
  case lighten
  case colorDodge
  case colorBurn
  case hardLight
  case softLight
  case difference
  case exclusion
  case hue
  case saturation
  case color
  case luminosity
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension UIKit.UIColor {
  public var lottieColorValue: LensCustomerSDK.LottieColor {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
public protocol DrawerControllerDelegate {
  func drawerView(for drawerController: LensCustomerSDK.DrawerViewController) -> UIKit.UIView
  func drawerMaximumHieght(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  func drawerMinimumHieght(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  func drawerWidth(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  func drawer(movingPosition: LensCustomerSDK.DrawerMovingPosition, drawerChangedHeight height: CoreFoundation.CGFloat, drawerMinHeight: CoreFoundation.CGFloat, drawerMaximumHeight: CoreFoundation.CGFloat, animated: Swift.Bool)
  func drawer(controller: LensCustomerSDK.DrawerViewController, movingPosition: LensCustomerSDK.DrawerMovingPosition, canChangeDrawerHeight height: CoreFoundation.CGFloat, drawerMinHeight: CoreFoundation.CGFloat, drawerMaximumHeight: CoreFoundation.CGFloat) -> Swift.Bool
  func drawer(_ drawer: LensCustomerSDK.DrawerViewController, reachedMinHeight height: CoreFoundation.CGFloat, animated: Swift.Bool)
  func drawer(_ drawer: LensCustomerSDK.DrawerViewController, reachedMaximumHeight height: CoreFoundation.CGFloat, animated: Swift.Bool)
  func drawer(dismissed withAnimation: Swift.Bool)
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.DrawerControllerDelegate where Self : UIKit.UIViewController {
  public func drawerMinimumHieght(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  public func drawerMaximumHieght(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  public func drawerWidth(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  public func drawer(movingPosition: LensCustomerSDK.DrawerMovingPosition, drawerChangedHeight height: CoreFoundation.CGFloat, drawerMinHeight: CoreFoundation.CGFloat, drawerMaximumHeight: CoreFoundation.CGFloat, animated: Swift.Bool)
  public func drawer(movingPosition: LensCustomerSDK.DrawerMovingPosition, canChangeDrawerHeight height: CoreFoundation.CGFloat, drawerMinHeight: CoreFoundation.CGFloat, drawerMaximumHeight: CoreFoundation.CGFloat) -> Swift.Bool
  public func drawer(_ drawer: LensCustomerSDK.DrawerViewController, reachedMinHeight height: CoreFoundation.CGFloat, animated: Swift.Bool)
  public func drawer(_ drawer: LensCustomerSDK.DrawerViewController, reachedMaximumHeight height: CoreFoundation.CGFloat, animated: Swift.Bool)
  public var drawerViewController: LensCustomerSDK.DrawerViewController? {
    get
  }
  @discardableResult
  public func dismissDrawer(animated: Swift.Bool, completion: (() -> Swift.Void)?) -> Swift.Bool
  public func updateDrawerHieghtByGiven(_ height: CoreFoundation.CGFloat)
  public func drawer(dismissed withAnimation: Swift.Bool)
}
@available(iOSApplicationExtension, unavailable)
public enum DrawerMovingPosition : Swift.Int {
  case nutral, up, down
  public init?(rawValue: Swift.Int)
  @available(iOSApplicationExtension, unavailable)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum positionType : Swift.Int {
  case up, middle
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class DrawerViewController : LensCustomerSDK.OverlayViewController {
  @_Concurrency.MainActor @preconcurrency public var drawerDelegate: (any LensCustomerSDK.DrawerControllerDelegate)?
  @_Concurrency.MainActor @preconcurrency public var indicatorHeight: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var indicatorWidth: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var drawerIndicatorColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var drawerBackgroundColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var minimumSlidVelocity: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public var maximumSlidVelocity: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public var heightChangingProgress: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func updateDrawerHeight(height: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency public var canStopMiddle: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var containerMiddlePoint: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var containerMaxHeight: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var childForStatusBarHidden: UIKit.UIViewController? {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency open var hideStatusBar: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc convenience dynamic public init()
  @_Concurrency.MainActor @preconcurrency convenience public init(delegate: any LensCustomerSDK.DrawerControllerDelegate, hideStatusBar hidden: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency public func updateDrawerHieghtByGiven(_ height: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func dismiss(animated flag: Swift.Bool, completion: (() -> Swift.Void)?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillTransition(to size: CoreFoundation.CGSize, with coordinator: any UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor @preconcurrency override public func deviceRotated(_ currentOrientation: UIKit.UIDeviceOrientation)
  @_Concurrency.MainActor @preconcurrency public func setPosition(position: LensCustomerSDK.positionType)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.DrawerViewController : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency open class DrawerChildTableViewController : UIKit.UIViewController, LensCustomerSDK.DrawerControllerDelegate {
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak open var scrollView: UIKit.UIScrollView!
  @_Concurrency.MainActor @preconcurrency public var canScrollView: Swift.Bool
  @discardableResult
  @_Concurrency.MainActor @preconcurrency public func presentWithDrawer(from: UIKit.UIViewController, config: ((LensCustomerSDK.DrawerViewController) -> ())? = nil) -> LensCustomerSDK.DrawerViewController
  @_Concurrency.MainActor @preconcurrency public func tableViewViewHandle()
  @_Concurrency.MainActor @preconcurrency open func drawerView(for drawer: LensCustomerSDK.DrawerViewController) -> UIKit.UIView
  @_Concurrency.MainActor @preconcurrency open func drawer(controller: LensCustomerSDK.DrawerViewController, movingPosition: LensCustomerSDK.DrawerMovingPosition, canChangeDrawerHeight height: CoreFoundation.CGFloat, drawerMinHeight: CoreFoundation.CGFloat, drawerMaximumHeight: CoreFoundation.CGFloat) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency open func drawer(movingPosition: LensCustomerSDK.DrawerMovingPosition, drawerChangedHeight height: CoreFoundation.CGFloat, drawerMinHeight: CoreFoundation.CGFloat, drawerMaximumHeight: CoreFoundation.CGFloat, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency open func drawer(_ drawer: LensCustomerSDK.DrawerViewController, reachedMinHeight height: CoreFoundation.CGFloat, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency open func drawerMaximumHieght(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  @_Concurrency.MainActor @preconcurrency open func drawerMinimumHieght(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  @_Concurrency.MainActor @preconcurrency open func drawerWidth(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  @_Concurrency.MainActor @preconcurrency open func drawer(_ drawer: LensCustomerSDK.DrawerViewController, reachedMaximumHeight height: CoreFoundation.CGFloat, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency open func drawer(dismissed withAnimation: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension UIKit.UITextField {
  @_Concurrency.MainActor @preconcurrency public var leftPading: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var placeHolderColor: UIKit.UIColor {
    get
    set
  }
}
extension QuartzCore.CALayer {
  @nonobjc public func logLayerTree(withIndent: Swift.Int = 0)
}
public class VMSession {
  public typealias dataSuccess = ((_ data: Foundation.Data, _ response: Foundation.HTTPURLResponse) -> Swift.Void)
  public typealias datafailure = (((any Swift.Error)?) -> Swift.Void)
  public init(config: Foundation.URLSessionConfiguration)
  public func invalidateAndCancel()
  public func dataTask(_ request: Foundation.URLRequest, success: @escaping LensCustomerSDK.VMSession.dataSuccess, failure: @escaping LensCustomerSDK.VMSession.datafailure)
  public func uploadTask()
  public func downloadTask(url: Foundation.URL)
  @objc deinit
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func adjustTableViewHeaderFrameIfNeeded()
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func scrollToLastIndexPath()
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public var isTableEmpty: Swift.Bool {
    get
  }
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func addNoDataView(noDataView: UIKit.UIView)
  @_Concurrency.MainActor @preconcurrency public func removenoDataView()
}
@objc public protocol GrowingTextViewDelegate : UIKit.UITextViewDelegate {
  @objc optional func textViewDidChangeHeight(_ textView: LensCustomerSDK.GrowingTextView, height: CoreFoundation.CGFloat)
}
@_inheritsConvenienceInitializers @IBDesignable @objc @_Concurrency.MainActor @preconcurrency open class GrowingTextView : UIKit.UITextView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var text: Swift.String! {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var maxLength: Swift.Int
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var trimWhiteSpaceWhenEndEditing: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var minHeight: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var maxHeight: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var placeholder: Swift.String? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var placeholderColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var attributedPlaceholder: Foundation.NSAttributedString? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect, textContainer: UIKit.NSTextContainer?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func draw(_ rect: CoreFoundation.CGRect)
}
extension UIKit.UIImage {
  convenience public init?(color: UIKit.UIColor, size: CoreFoundation.CGSize = CGSize(width: 1, height: 1))
}
extension LensCustomerSDK.LottieAnimation {
  public typealias DownloadClosure = (LensCustomerSDK.LottieAnimation?) -> Swift.Void
  final public var duration: Foundation.TimeInterval {
    get
  }
  final public var bounds: CoreFoundation.CGRect {
    get
  }
  final public var size: CoreFoundation.CGSize {
    get
  }
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared) -> LensCustomerSDK.LottieAnimation?
  public static func filepath(_ filepath: Swift.String, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared) -> LensCustomerSDK.LottieAnimation?
  public static func asset(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared) -> LensCustomerSDK.LottieAnimation?
  public static func from(data: Foundation.Data, strategy: LensCustomerSDK.DecodingStrategy = LottieConfiguration.shared.decodingStrategy) throws -> LensCustomerSDK.LottieAnimation
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared) async -> LensCustomerSDK.LottieAnimation?
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, closure: @escaping LensCustomerSDK.LottieAnimation.DownloadClosure, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared)
  final public func progressTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationProgressTime?
  final public func frameTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationFrameTime?
  final public func durationFrameTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationFrameTime?
  final public func progressTime(forFrame frameTime: LensCustomerSDK.AnimationFrameTime, clamped: Swift.Bool = true) -> LensCustomerSDK.AnimationProgressTime
  final public func frameTime(forProgress progressTime: LensCustomerSDK.AnimationProgressTime) -> LensCustomerSDK.AnimationFrameTime
  final public func time(forFrame frameTime: LensCustomerSDK.AnimationFrameTime) -> Foundation.TimeInterval
  final public func frameTime(forTime time: Foundation.TimeInterval) -> LensCustomerSDK.AnimationFrameTime
}
extension Foundation.Bundle : @unchecked Swift.Sendable {
}
extension Foundation.Date {
  public static func today() -> Foundation.Date
  public func next(_ weekday: Foundation.Date.Weekday, considerToday: Swift.Bool = false) -> Foundation.Date
  public func previous(_ weekday: Foundation.Date.Weekday, considerToday: Swift.Bool = false) -> Foundation.Date
  public func get(_ direction: Foundation.Date.SearchDirection, _ weekDay: Foundation.Date.Weekday, considerToday consider: Swift.Bool = false) -> Foundation.Date
}
extension Foundation.Date {
  public func getWeekDaysInEnglish() -> [Swift.String]
  public enum Weekday : Swift.String {
    case monday, tuesday, wednesday, thursday, friday, saturday, sunday
    public init?(rawValue: Swift.String)
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum SearchDirection {
    case Next
    case Previous
    public static func == (a: Foundation.Date.SearchDirection, b: Foundation.Date.SearchDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Foundation.Date {
  public static func string(for date: Foundation.Date, format: Swift.String? = nil) -> Swift.String
  public func string(format: Swift.String? = nil) -> Swift.String
  public static func date(for string: Swift.String, format: Swift.String) -> Foundation.Date?
}
extension Foundation.Date {
  public func getString(mode: UIKit.UIDatePicker.Mode = .date, timeZone: Foundation.TimeZone = TimeZone.current) -> Swift.String
  public func getString(format: Swift.String) -> Swift.String
  public func at_getLocalizedString(_ mode: UIKit.UIDatePicker.Mode = .date) -> Swift.String
}
extension Foundation.Date {
  public var millisecondsSince1970: Swift.Int {
    get
  }
  public var randomID: Swift.String {
    get
  }
}
extension Foundation.Date {
  public func isSmallerThanGivenDateByDay(_ date: Foundation.Date) -> Swift.Bool
  public func isEqualDay(_ date: Foundation.Date) -> Swift.Bool
  public func isSmallerThanByMinutes(_ date: Foundation.Date) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class LottieAnimationViewBase : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didMoveToWindow()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public enum CoordinateSpace : Swift.Int, Swift.Codable, Swift.Sendable {
  case type2d
  case type3d
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class LottieAnimation : Swift.Codable, Swift.Sendable {
  required public init(from decoder: any Swift.Decoder) throws
  public init(dictionary: [Swift.String : Any]) throws
  final public let startFrame: LensCustomerSDK.AnimationFrameTime
  final public let endFrame: LensCustomerSDK.AnimationFrameTime
  final public let framerate: Swift.Double
  final public var markerNames: [Swift.String] {
    get
  }
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
extension UIKit.UIButton {
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var disabledTitle: Swift.String {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var disabledTitleColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var paddingX: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency dynamic public var paddingY: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
}
extension UIKit.UIButton {
  @_Concurrency.MainActor @preconcurrency public func setDefaultTitle(_ title: Swift.String, controlState states: [UIKit.UIControl.State] = [.normal, .highlighted])
  @_Concurrency.MainActor @preconcurrency public func setDefaultAttributtedTitle(_ title: Foundation.NSAttributedString, controlState states: [UIKit.UIControl.State] = [.normal, .highlighted])
}
public typealias Email = Swift.String
extension UIKit.UINavigationController {
  @_Concurrency.MainActor @preconcurrency public var prefersLargeTitles: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func makeTransparantNavigationBar(_ flag: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func makeColorNavigationBar(color: UIKit.UIColor, hideShadowImage: Swift.Bool = true)
}
public typealias LottieCompletionBlock = (_ completed: Swift.Bool) -> Swift.Void
final public class LottieLogger {
  public init(assert: @escaping LensCustomerSDK.LottieLogger.Assert = { condition, message, file, line in
       
       
       
      Swift.assert(condition(), message(), file: file, line: line)
    }, assertionFailure: @escaping LensCustomerSDK.LottieLogger.AssertionFailure = { message, file, line in
       
       
       
       
      Swift.assertionFailure(message(), file: file, line: line)
    }, warn: @escaping LensCustomerSDK.LottieLogger.Warn = { message, _, _ in
    }, info: @escaping LensCustomerSDK.LottieLogger.Info = { message in
    })
  public typealias Assert = (_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias AssertionFailure = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Warn = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Info = (_ message: @autoclosure () -> Swift.String) -> Swift.Void
  public static var shared: LensCustomerSDK.LottieLogger
  final public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func assertionFailure(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func warn(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func info(_ message: @autoclosure () -> Swift.String = String())
  @objc deinit
}
extension LensCustomerSDK.LottieLogger {
  public static var printToConsole: LensCustomerSDK.LottieLogger {
    get
  }
}
extension ObjectiveC.NSObject {
  public static func performInMainThread(_ block: @escaping () -> Swift.Void)
  public func performInMainThread(_ block: @escaping () -> Swift.Void)
  public enum AssistImpactFeedbackStyle {
    case medium, high, low, success, warning, error
    public static func == (a: ObjectiveC.NSObject.AssistImpactFeedbackStyle, b: ObjectiveC.NSObject.AssistImpactFeedbackStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public func makeTapTick(_ style: ObjectiveC.NSObject.AssistImpactFeedbackStyle)
  public static func makeTapTick(_ style: ObjectiveC.NSObject.AssistImpactFeedbackStyle)
}
@objc @_Concurrency.MainActor @preconcurrency open class AnimatedControl : LensCustomerSDK.LottieControlType {
  @_Concurrency.MainActor @preconcurrency public init(animation: LensCustomerSDK.LottieAnimation?, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func continueTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency open func animationDidSet()
  @_Concurrency.MainActor @preconcurrency final public let animationView: LensCustomerSDK.LottieAnimationView
  @_Concurrency.MainActor @preconcurrency public var animation: LensCustomerSDK.LottieAnimation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func setLayer(named: Swift.String, forState: LensCustomerSDK.LottieControlState)
  @_Concurrency.MainActor @preconcurrency public func setValueProvider(_ valueProvider: any LensCustomerSDK.AnyValueProvider, keypath: LensCustomerSDK.AnimationKeypath)
  @objc deinit
}
public let WebsocketDidConnectNotification: Swift.String
public let WebsocketDidDisconnectNotification: Swift.String
public let WebsocketDisconnectionErrorKeyName: Swift.String
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum ErrorType : Swift.Error {
  case outputStreamWriteError
  case compressionError
  case invalidSSLError
  case writeTimeoutError
  case protocolError
  case upgradeError
  case closeError
  public static func == (a: LensCustomerSDK.ErrorType, b: LensCustomerSDK.ErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct WSError : Swift.Error {
  public let type: LensCustomerSDK.ErrorType
  public let message: Swift.String
  public let code: Swift.Int
}
public protocol WebSocketClient : AnyObject {
  var delegate: (any LensCustomerSDK.WebSocketDelegate)? { get set }
  var pongDelegate: (any LensCustomerSDK.WebSocketPongDelegate)? { get set }
  var disableSSLCertValidation: Swift.Bool { get set }
  var overrideTrustHostname: Swift.Bool { get set }
  var desiredTrustHostname: Swift.String? { get set }
  var sslClientCertificate: LensCustomerSDK.SSLClientCertificate? { get set }
  var security: (any LensCustomerSDK.SSLTrustValidator)? { get set }
  var enabledSSLCipherSuites: [Security.SSLCipherSuite]? { get set }
  var isConnected: Swift.Bool { get }
  func connect()
  func disconnect(forceTimeout: Foundation.TimeInterval?, closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension LensCustomerSDK.WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public struct SSLSettings {
  public let useSSL: Swift.Bool
  public let disableCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public let sslClientCertificate: LensCustomerSDK.SSLClientCertificate?
  public let cipherSuites: [Security.SSLCipherSuite]?
}
public protocol WSStreamDelegate : AnyObject {
  func newBytesInStream()
  func streamDidError(error: (any Swift.Error)?)
}
public protocol WSStream {
  var delegate: (any LensCustomerSDK.WSStreamDelegate)? { get set }
  func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: LensCustomerSDK.SSLSettings, completion: @escaping (((any Swift.Error)?) -> Swift.Void))
  func write(data: Foundation.Data) -> Swift.Int
  func read() -> Foundation.Data?
  func cleanup()
  func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
}
@objc @_inheritsConvenienceInitializers open class FoundationStream : ObjectiveC.NSObject, LensCustomerSDK.WSStream, Foundation.StreamDelegate {
  weak public var delegate: (any LensCustomerSDK.WSStreamDelegate)?
  public var enableSOCKSProxy: Swift.Bool
  public func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: LensCustomerSDK.SSLSettings, completion: @escaping (((any Swift.Error)?) -> Swift.Void))
  public func write(data: Foundation.Data) -> Swift.Int
  public func read() -> Foundation.Data?
  public func cleanup()
  public func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
  @objc override dynamic public init()
  @objc deinit
}
public protocol WebSocketDelegate : AnyObject {
  func websocketDidConnect(socket: any LensCustomerSDK.WebSocketClient)
  func websocketDidDisconnect(socket: any LensCustomerSDK.WebSocketClient, error: (any Swift.Error)?)
  func websocketDidReceiveMessage(socket: any LensCustomerSDK.WebSocketClient, text: Swift.String)
  func websocketDidReceiveData(socket: any LensCustomerSDK.WebSocketClient, data: Foundation.Data)
}
public protocol WebSocketPongDelegate : AnyObject {
  func websocketDidReceivePong(socket: any LensCustomerSDK.WebSocketClient, data: Foundation.Data?)
}
public protocol WebSocketAdvancedDelegate : AnyObject {
  func websocketDidConnect(socket: LensCustomerSDK.WebSocket)
  func websocketDidDisconnect(socket: LensCustomerSDK.WebSocket, error: (any Swift.Error)?)
  func websocketDidReceiveMessage(socket: LensCustomerSDK.WebSocket, text: Swift.String, response: LensCustomerSDK.WebSocket.WSResponse)
  func websocketDidReceiveData(socket: LensCustomerSDK.WebSocket, data: Foundation.Data, response: LensCustomerSDK.WebSocket.WSResponse)
  func websocketHttpUpgrade(socket: LensCustomerSDK.WebSocket, request: Swift.String)
  func websocketHttpUpgrade(socket: LensCustomerSDK.WebSocket, response: Swift.String)
}
@objc open class WebSocket : ObjectiveC.NSObject, Foundation.StreamDelegate, LensCustomerSDK.WebSocketClient, LensCustomerSDK.WSStreamDelegate {
  public enum OpCode : Swift.UInt8 {
    case continueFrame
    case textFrame
    case binaryFrame
    case connectionClose
    case ping
    case pong
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public static let ErrorDomain: Swift.String
  public var callbackQueue: Dispatch.DispatchQueue
  @_hasMissingDesignatedInitializers public class WSResponse {
    public var code: LensCustomerSDK.WebSocket.OpCode
    public var frameCount: Swift.Int
    public var buffer: Foundation.NSMutableData?
    final public let firstFrame: Foundation.Date
    @objc deinit
  }
  weak public var delegate: (any LensCustomerSDK.WebSocketDelegate)?
  weak public var advancedDelegate: (any LensCustomerSDK.WebSocketAdvancedDelegate)?
  weak public var pongDelegate: (any LensCustomerSDK.WebSocketPongDelegate)?
  public var onConnect: (() -> Swift.Void)?
  public var onDisconnect: (((any Swift.Error)?) -> Swift.Void)?
  public var onText: ((Swift.String) -> Swift.Void)?
  public var onData: ((Foundation.Data) -> Swift.Void)?
  public var onPong: ((Foundation.Data?) -> Swift.Void)?
  public var onHttpResponseHeaders: (([Swift.String : Swift.String]) -> Swift.Void)?
  public var disableSSLCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public var sslClientCertificate: LensCustomerSDK.SSLClientCertificate?
  public var enableCompression: Swift.Bool
  public var security: (any LensCustomerSDK.SSLTrustValidator)?
  public var enabledSSLCipherSuites: [Security.SSLCipherSuite]?
  public var isConnected: Swift.Bool {
    get
  }
  public var request: Foundation.URLRequest
  public var currentURL: Foundation.URL {
    get
  }
  public var respondToPingWithPong: Swift.Bool
  public init(request: Foundation.URLRequest, protocols: [Swift.String]? = nil, stream: any LensCustomerSDK.WSStream = FoundationStream())
  convenience public init(url: Foundation.URL, protocols: [Swift.String]? = nil)
  convenience public init(url: Foundation.URL, writeQueueQOS: Foundation.QualityOfService, protocols: [Swift.String]? = nil)
  open func connect()
  open func disconnect(forceTimeout: Foundation.TimeInterval? = nil, closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  open func write(string: Swift.String, completion: (() -> ())? = nil)
  open func write(data: Foundation.Data, completion: (() -> ())? = nil)
  open func write(ping: Foundation.Data, completion: (() -> ())? = nil)
  open func write(pong: Foundation.Data, completion: (() -> ())? = nil)
  public func newBytesInStream()
  public func streamDidError(error: (any Swift.Error)?)
  @objc deinit
}
public protocol AnimationKeypathTextProvider : AnyObject {
  func text(for keypath: LensCustomerSDK.AnimationKeypath, sourceText: Swift.String) -> Swift.String?
}
@available(*, deprecated, message: "`AnimationKeypathTextProvider` has been deprecated and renamed to `LegacyAnimationTextProvider`. Instead, conform to `AnimationKeypathTextProvider` instead or conform to `LegacyAnimationTextProvider` explicitly.")
public typealias AnimationTextProvider = LensCustomerSDK.LegacyAnimationTextProvider
public protocol LegacyAnimationTextProvider : LensCustomerSDK.AnimationKeypathTextProvider {
  func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
}
extension LensCustomerSDK.LegacyAnimationTextProvider {
  public func text(for _: LensCustomerSDK.AnimationKeypath, sourceText _: Swift.String) -> Swift.String?
}
final public class DictionaryTextProvider : LensCustomerSDK.AnimationKeypathTextProvider, LensCustomerSDK.LegacyAnimationTextProvider {
  public init(_ values: [Swift.String : Swift.String])
  final public func text(for keypath: LensCustomerSDK.AnimationKeypath, sourceText: Swift.String) -> Swift.String?
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
extension LensCustomerSDK.DictionaryTextProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.DictionaryTextProvider, rhs: LensCustomerSDK.DictionaryTextProvider) -> Swift.Bool
}
final public class DefaultTextProvider : LensCustomerSDK.AnimationKeypathTextProvider, LensCustomerSDK.LegacyAnimationTextProvider {
  public init()
  final public func textFor(keypathName _: Swift.String, sourceText: Swift.String) -> Swift.String
  final public func text(for _: LensCustomerSDK.AnimationKeypath, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
extension LensCustomerSDK.DefaultTextProvider : Swift.Equatable {
  public static func == (_: LensCustomerSDK.DefaultTextProvider, _: LensCustomerSDK.DefaultTextProvider) -> Swift.Bool
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func addBackgroundLottie(_ lottieType: any LensCustomerSDK.LottieType, customView: UIKit.UIView? = nil, actionButtonConfiguration: ((UIKit.UIButton) -> (() -> Swift.Void))? = nil)
  @_Concurrency.MainActor @preconcurrency public func updateBackgroundLottie()
  @_Concurrency.MainActor @preconcurrency public var isBackgroundLottiePlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func removeBackgroundLottie()
}
extension Foundation.FileManager {
  public static var documentDirURL: Foundation.URL? {
    get
  }
}
public struct MultiTechSessionDetails {
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class MultipleTechDetailsViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func prepopulateData(participant: [LensCustomerSDK.Participant], hostZuid: Foundation.NSNumber, isHost: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func presentWithDrawer(controller: UIKit.UIViewController, _ completion: (() -> Swift.Void)? = nil, hideStatusBar: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension LensCustomerSDK.MultipleTechDetailsViewController : UIKit.UITableViewDelegate, UIKit.UITableViewDataSource {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, heightForRowAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, estimatedHeightForRowAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, titleForHeaderInSection section: Swift.Int) -> Swift.String?
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, willDisplayHeaderView view: UIKit.UIView, forSection section: Swift.Int)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
}
extension LensCustomerSDK.MultipleTechDetailsViewController : LensCustomerSDK.DrawerControllerDelegate {
  @_Concurrency.MainActor @preconcurrency public func drawerView(for drawerController: LensCustomerSDK.DrawerViewController) -> UIKit.UIView
  @_Concurrency.MainActor @preconcurrency public func drawer(controller: LensCustomerSDK.DrawerViewController, movingPosition: LensCustomerSDK.DrawerMovingPosition, canChangeDrawerHeight height: CoreFoundation.CGFloat, drawerMinHeight: CoreFoundation.CGFloat, drawerMaximumHeight: CoreFoundation.CGFloat) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func drawer(_ drawer: LensCustomerSDK.DrawerViewController, reachedMinHeight height: CoreFoundation.CGFloat, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func drawerMaximumHieght(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  @_Concurrency.MainActor @preconcurrency public func drawer(dismissed withAnimation: Swift.Bool)
}
extension LensCustomerSDK.LensCustomerSessionController : LensCustomerSDK.ARProtocol {
  @_Concurrency.MainActor @preconcurrency public func onAnchorSelectionChanged(annotationId: Swift.String, state: LensCustomerSDK.AnnotationSelection, triggerId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func onAnchorRemoved(annotationId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func onAnchorPlaced(annotationId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func onArCommentsReceived(annotationNode: LensCustomerSDK.AnnotationNotify)
  @_Concurrency.MainActor @preconcurrency public func onArNewNodeCreated()
  @_Concurrency.MainActor @preconcurrency public func onArNodeRemoved()
  @_Concurrency.MainActor @preconcurrency public func updateAnnotationNotesListViewControllerifPresenting()
}
public protocol AnnotationNotesListUIProtocol : AnyObject {
  func onArSelectionCompleted(isSelected: Swift.Bool, annotationId: Swift.String, triggerId: Swift.String)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class AnnotationNotesListViewController : UIKit.UIViewController, LensCustomerSDK.KeyboardNotificationhandler {
  @_Concurrency.MainActor @preconcurrency weak public var arNotesListUIDelegate: (any LensCustomerSDK.AnnotationNotesListUIProtocol)?
  @_Concurrency.MainActor @preconcurrency weak public var lensVC: UIKit.UIViewController?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func showEmptyStateView()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension LensCustomerSDK.AnnotationNotesListViewController : UIKit.UITableViewDelegate, UIKit.UITableViewDataSource {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, heightForRowAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, estimatedHeightForRowAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, titleForHeaderInSection section: Swift.Int) -> Swift.String?
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, willDisplayHeaderView view: UIKit.UIView, forSection section: Swift.Int)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
}
extension LensCustomerSDK.AnnotationNotesListViewController : LensCustomerSDK.GrowingTextViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func textViewDidChangeHeight(_ textView: LensCustomerSDK.GrowingTextView, height: CoreFoundation.CGFloat)
}
extension LensCustomerSDK.AnnotationNotesListViewController : LensCustomerSDK.AnnotationNotesListUIProtocol {
  @_Concurrency.MainActor @preconcurrency public func onArSelectionCompleted(isSelected: Swift.Bool, annotationId: Swift.String, triggerId: Swift.String)
}
public enum FreezeCurrentStatus {
  case freezeRunningStream(LensCustomerSDK.FreezeCurrentStatus.FreezeBy), freezeSnapshot(LensCustomerSDK.FreezeCurrentStatus.FreezeBy), unfreeze(LensCustomerSDK.FreezeCurrentStatus.FreezeBy)
  public enum FreezeBy {
    case me, other
    public static func == (a: LensCustomerSDK.FreezeCurrentStatus.FreezeBy, b: LensCustomerSDK.FreezeCurrentStatus.FreezeBy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var isFreeze: Swift.Bool {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class InviteTechnicianViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension LensCustomerSDK.LensCustomerSessionController : LensCustomerSDK.LensSignallingProtocol {
  @_Concurrency.MainActor @preconcurrency public func onScanSuccess(scanResult: LensCustomerSDK.ScanModel)
  @_Concurrency.MainActor @preconcurrency public func onScanFailure(scanError: LensCustomerSDK.ScanError)
  @_Concurrency.MainActor @preconcurrency public func conferenceReceived(type: LensCustomerSDK.ConferenceType)
  @_Concurrency.MainActor @preconcurrency public func refreshBottomMenu()
  @_Concurrency.MainActor @preconcurrency public func onTechnicianPerform(draw shape: LensCustomerSDK.DrawingInput.DrawShape)
  @_Concurrency.MainActor @preconcurrency public func didChangeLensConnectionState(state: LensCustomerSDK.AssisLensStates)
  @_Concurrency.MainActor @preconcurrency public func didChange(_ participant: LensCustomerSDK.Participant)
  @_Concurrency.MainActor @preconcurrency public func renderingView(_ view: UIKit.UIView?)
  @_Concurrency.MainActor @preconcurrency public func onSessionValidationDone()
  @_Concurrency.MainActor @preconcurrency public func newFreezeAcknowledgement()
  @_Concurrency.MainActor @preconcurrency public func unFreezeFinalAction()
  @_Concurrency.MainActor @preconcurrency public func showFreezedImage()
  @_Concurrency.MainActor @preconcurrency public func didChangeARState(tracking state: ARKit.ARCamera.TrackingState)
  @_Concurrency.MainActor @preconcurrency public func participantRejoined(clientId: Swift.String)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class LensCustomerSessionController : LensCustomerSDK.LensBaseSessionController {
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any LensCustomerSDK.LensEventProtocol)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency weak public var activityProtocol: (any LensCustomerSDK.LensEventProtocol)?
  @_Concurrency.MainActor @preconcurrency public static func validateSession(sessionid id: Swift.String, base url: Foundation.URL? = nil, completion: @escaping (LensCustomerSDK.SessionValidationResponse) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency convenience public init(connectionParam param: any LensCustomerSDK.CustomerSessionParams, customer name: Swift.String, is_arMode: Swift.Bool, remoteConfigConferenceType: LensCustomerSDK.ConferenceType, customerEmail: Swift.String)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency override public func deviceRotated(_ currentOrientation: UIKit.UIDeviceOrientation)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func dismiss(animated flag: Swift.Bool, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func exitLensSession()
  @_Concurrency.MainActor @preconcurrency public func endCurrentAppCallKit()
  @_Concurrency.MainActor @preconcurrency public func alertJoinAnotherSession()
  @_Concurrency.MainActor @preconcurrency public func selectedOption(option: LensCustomerSDK.AssistMenu)
}
extension LensCustomerSDK.LensCustomerSessionController {
  @objc @IBAction @_Concurrency.MainActor @preconcurrency dynamic public func exit(_ sender: UIKit.UIButton?)
}
extension LensCustomerSDK.LensCustomerSessionController : LensCustomerSDK.LensUICommonDelegates {
  @_Concurrency.MainActor @preconcurrency public func dismissWithError(message: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func show(lottie type: LensCustomerSDK.LensLottieType, message: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func set(loader enabled: Swift.Bool, text: Swift.String?)
  @_Concurrency.MainActor @preconcurrency public func dismissLottie()
  @_Concurrency.MainActor @preconcurrency public func showStatusBar(message: Swift.String, interval: Foundation.TimeInterval = 4)
}
extension LensCustomerSDK.LensCustomerSessionController : LensCustomerSDK.AudioSessionProtocol {
  @_Concurrency.MainActor @preconcurrency public func didChangeRoute(_ audioDescription: AVFAudio.AVAudioSessionRouteDescription, reason: AVFAudio.AVAudioSession.RouteChangeReason)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class AnnotateColorPickViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func presentWithDrawer(controller: UIKit.UIViewController, _ completion: (() -> Swift.Void)? = nil, hideStatusBar: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension LensCustomerSDK.AnnotateColorPickViewController : LensCustomerSDK.DrawerControllerDelegate {
  @_Concurrency.MainActor @preconcurrency public func drawerView(for drawerController: LensCustomerSDK.DrawerViewController) -> UIKit.UIView
  @_Concurrency.MainActor @preconcurrency public func drawer(controller: LensCustomerSDK.DrawerViewController, movingPosition: LensCustomerSDK.DrawerMovingPosition, canChangeDrawerHeight height: CoreFoundation.CGFloat, drawerMinHeight: CoreFoundation.CGFloat, drawerMaximumHeight: CoreFoundation.CGFloat) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func drawer(_ drawer: LensCustomerSDK.DrawerViewController, reachedMinHeight height: CoreFoundation.CGFloat, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func drawerMaximumHieght(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  @_Concurrency.MainActor @preconcurrency public func drawer(dismissed withAnimation: Swift.Bool)
}
extension LensCustomerSDK.AnnotateColorPickViewController : UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegateFlowLayout {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
}
@objc public class ChatData : ObjectiveC.NSObject {
  final public let chat: LensCustomerSDK.Chat
  final public let chatTime: Foundation.Date
  public var isShowNameAndDate: Swift.Bool
  public init(chat: LensCustomerSDK.Chat)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class ScanResultSheet : UIKit.UIViewController, LensCustomerSDK.KeyboardNotificationhandler {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func removeFromParent()
  @_Concurrency.MainActor @preconcurrency public func updateScannedText(text: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func setSendButtonCallback(sendCallback: @escaping ((_ resultText: Swift.String) -> Swift.Void))
  @_Concurrency.MainActor @preconcurrency public func setCopyButtonCallback(sendCallback: @escaping ((_ text: Swift.String) -> Swift.Void))
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension LensCustomerSDK.ScanResultSheet : UIKit.UITextViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func textView(_ textView: UIKit.UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: Foundation.NSRange, interaction: UIKit.UITextItemInteraction) -> Swift.Bool
}
public enum AnnotateIcon : LensCustomerSDK.ATIcon {
  case delete, rectangle, pencil, circle, ellipse, close, annotateMenu, arrow, deleteAll, selectionAnnotation, color, pointer, selectedPointer
  case selectedRectangle, selectedPencil, selectedEllipse, selectedArrow, selectedAnnotation
  case measurement_add, measurementSelected, measurement
  public var iconString: Swift.String {
    get
  }
  public var iconSize: CoreFoundation.CGFloat {
    get
  }
  public var description: Swift.String? {
    get
  }
  public var iconNormalColor: UIKit.UIColor? {
    get
  }
  public var iconSelectedColor: UIKit.UIColor? {
    get
  }
  public var iconDisabledColor: UIKit.UIColor? {
    get
  }
  public func iconFont(size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func == (a: LensCustomerSDK.AnnotateIcon, b: LensCustomerSDK.AnnotateIcon) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct AssistMenuTheme {
  public var cellNormalTheme: LensCustomerSDK.AssistCellTheme
  public var cellDisabledTheme: LensCustomerSDK.AssistCellTheme
  public init()
}
public struct AssistCellTheme {
  public var titleColor: UIKit.UIColor
  public var iconColor: UIKit.UIColor
  public var backgroundColor: UIKit.UIColor
}
public struct AssistMenu : Swift.Identifiable, Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.AssistMenu, rhs: LensCustomerSDK.AssistMenu) -> Swift.Bool
  public var id: Swift.String
  public var featureType: LensCustomerSDK.Features?
  public var icon: any LensCustomerSDK.ATIcon
  public var selectedIcon: (any LensCustomerSDK.ATIcon)?
  public var isEnabled: Swift.Bool
  public var isNewActivtyAvailable: Swift.Bool
  public var color: (Swift.Bool, UIKit.UIColor)
  public init(id: Swift.String, icon: any LensCustomerSDK.ATIcon, selectedIcon: (any LensCustomerSDK.ATIcon)? = nil, color: (Swift.Bool, UIKit.UIColor)? = (false, UIColor.white), isSelectedInitially: Swift.Bool = false, featureType: LensCustomerSDK.Features? = nil)
  public typealias ID = Swift.String
}
extension LensCustomerSDK.AssistMenu : LensCustomerSDK.SheetActionData {
  public var actionTitle: Swift.String {
    get
  }
  public var actionIcon: (any LensCustomerSDK.ATIcon)? {
    get
  }
  public var accessoryIcon: (any LensCustomerSDK.ATIcon)? {
    get
  }
}
public protocol AssistMenuCollectionViewDelegate : AnyObject {
  func didSelectMenu(item: LensCustomerSDK.AssistMenu, hidedMenus: [LensCustomerSDK.AssistMenu])
  func didDeSelectMenu(item: LensCustomerSDK.AssistMenu, hidedMenus: [LensCustomerSDK.AssistMenu])
  func cellSizeFor(collectionView: UIKit.UICollectionView) -> CoreFoundation.CGSize
  func assistMenuItems(collectionView: UIKit.UICollectionView) -> [LensCustomerSDK.AssistMenu]
  func assistMenuMoreItem() -> LensCustomerSDK.AssistMenu
  func maxWidth(collectionView: UIKit.UICollectionView) -> CoreFoundation.CGFloat
  func isSelectedFeatureAvailable(item: LensCustomerSDK.AssistMenu, lensObject: LensCustomerSDK.Lens?) -> Swift.Bool
  var lensObject: LensCustomerSDK.Lens? { get }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class AssistMenuCollectionView : UIKit.UICollectionView {
  @_Concurrency.MainActor @preconcurrency weak public var assistMenuDelegate: (any LensCustomerSDK.AssistMenuCollectionViewDelegate)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var isErrorOccured: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public static var theme: LensCustomerSDK.AssistMenuTheme
  @_Concurrency.MainActor @preconcurrency public func has_action_menu(_ menu: LensCustomerSDK.AssistMenu) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect, collectionViewLayout layout: UIKit.UICollectionViewLayout)
  @_Concurrency.MainActor @preconcurrency public func refreshAllData()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func reloadData()
  @_Concurrency.MainActor @preconcurrency public func updateSelectionState(menu: LensCustomerSDK.AssistMenu, isSelected: Swift.Bool, trigger_select_delegate: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency public func select(menu: LensCustomerSDK.AssistMenu, trigger_select_delegate: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func deSelect(menu: LensCustomerSDK.AssistMenu, trigger_select_delegate: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func hasMenuItem(menu: LensCustomerSDK.AssistMenu) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func isSelected(menu: LensCustomerSDK.AssistMenu) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func set(enabled isEnable: Swift.Bool, for menu: [LensCustomerSDK.AssistMenu], isSelected: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency public func isEnabled(menu: LensCustomerSDK.AssistMenu) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.AssistMenuCollectionView : UIKit.UICollectionViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didDeselectItemAt indexPath: Foundation.IndexPath)
}
extension LensCustomerSDK.AssistMenuCollectionView : UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegateFlowLayout {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class LensBaseSessionController : LensCustomerSDK.OrientationHelperController {
  @_Concurrency.MainActor @preconcurrency public var sessionID: Swift.String? {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency override public func deviceRotated(_ currentOrientation: UIKit.UIDeviceOrientation)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency public func showNotificationView(message: Swift.String, interval: Foundation.TimeInterval = 4)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension LensCustomerSDK.LensBaseSessionController : LensCustomerSDK.AssistMenuCollectionViewDelegate {
  @_Concurrency.MainActor @preconcurrency public var lensObject: LensCustomerSDK.Lens? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func cellSizeFor(collectionView: UIKit.UICollectionView) -> CoreFoundation.CGSize
  @_Concurrency.MainActor @preconcurrency public func maxWidth(collectionView: UIKit.UICollectionView) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public func assistMenuItems(collectionView: UIKit.UICollectionView) -> [LensCustomerSDK.AssistMenu]
  @_Concurrency.MainActor @preconcurrency public func assistMenuMoreItem() -> LensCustomerSDK.AssistMenu
  @_Concurrency.MainActor @preconcurrency public func didSelectMenu(item: LensCustomerSDK.AssistMenu, hidedMenus: [LensCustomerSDK.AssistMenu])
  @_Concurrency.MainActor @preconcurrency public func didDeSelectMenu(item: LensCustomerSDK.AssistMenu, hidedMenus: [LensCustomerSDK.AssistMenu])
  @_Concurrency.MainActor @preconcurrency public func isSelectedFeatureAvailable(item: LensCustomerSDK.AssistMenu, lensObject: LensCustomerSDK.Lens?) -> Swift.Bool
}
public protocol LensEventProtocol : AnyObject {
  func summary(sessionInfo: LensCustomerSDK.SessionDescription, snapshots: [LensCustomerSDK.SnapShotEntity]?, isNotesAvailable: Swift.Bool, chat: [LensCustomerSDK.Chat]?)
  func sessionEvents(_ event: LensCustomerSDK.SessionEvents)
  func showFeedback()
  func showPricingPlans()
  var sessionType: LensCustomerSDK.Participant.Role! { get set }
}
public enum SessionEvents {
  case freeze, unfreeze, freezeFailed, chatRecived, chatSent, clearAnnotaion
  case flash_request(ison: Swift.Bool)
  case flash_failed(ison: Swift.Bool)
  case sessionState(LensCustomerSDK.AssisLensStates)
  case isVideoMuted(Swift.Bool)
  case isAudioMuted(Swift.Bool)
  case isARAvailable(Swift.Bool)
  case customer_action(LensCustomerSDK.CustomerAction)
  case audioRouteDescription(AVFAudio.AVAudioSessionRouteDescription?)
  case annotation(LensCustomerSDK.DrawingInput.DrawShape)
  case participantState(LensCustomerSDK.Participant)
  case notesAdded(LensCustomerSDK.SessionEvents.FileAction, (any Swift.Error)?)
  case inviteCustomer((any Swift.Error)?)
  case inviteTechnician((any Swift.Error)?)
  case snapshotActions(LensCustomerSDK.SessionEvents.FileAction, (any Swift.Error)?)
  case arTrackingState(LensCustomerSDK.AR_TrackingState)
  public enum FileAction : Swift.Int {
    case created, deleted, downloaded
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency public func show(title: Swift.String, alert message: Swift.String? = nil, dismissOnTapOutside isEnable: Swift.Bool = true, actions: [LensCustomerSDK.AssistAlertAction] = [])
  @_Concurrency.MainActor @preconcurrency public func accessDenideRedirectToAppSettings(_ message: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func showInputAlert(message: Swift.String, actions: [LensCustomerSDK.AssistAlertAction] = [], completion: ((_ controller: LensCustomerSDK.AssistBlurAlertController, _ text: Swift.String?, _ action: LensCustomerSDK.AssistAlertAction) -> (Swift.Bool))? = nil)
  @_Concurrency.MainActor @preconcurrency public func networkConnectionAvailable() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func alertToOpenAppstore()
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency public func addLottie(type: LensCustomerSDK.LensLottieType) -> LensCustomerSDK.LottieAnimationView
}
public enum ExternalApp : Swift.String {
  case camera, photo, microphone
  public enum Permission : Swift.String {
    case denied, restricted, authorized
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension LensCustomerSDK.LensCustomerSessionController : LensCustomerSDK.OtherActionProtocol {
  @_Concurrency.MainActor @preconcurrency public func onVideoStateChanged(status: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public var isARSupported: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var isCustomerVideoMuted: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func onTechnicianPerform(action: LensCustomerSDK.TechnicianAction)
  @_Concurrency.MainActor @preconcurrency public func onShareCameraResponse(action: LensCustomerSDK.ShareCameraTechAction, participant: LensCustomerSDK.Participant?)
  @_Concurrency.MainActor @preconcurrency public func showLottieView(lottie: LensCustomerSDK.LensLottieType, show: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func showNotificationBanner(msg: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func onFreezeSuccess(fromUpstreamer: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func onFreezeFailure()
  @_Concurrency.MainActor @preconcurrency public func onUnfreezed()
  @_Concurrency.MainActor @preconcurrency public func didReceiveAnnotation(input: LensCustomerSDK.DrawingInput?, isClear: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func onCameraSwitch(isFront: Swift.Bool)
}
public enum LensLottieType : LensCustomerSDK.LottieType {
  case noNetwork, loader, nochat, oopsWrong, noSearch, waitingForJoin, shareStopped, sessionClosed, sessionExpired, noTechSessionSummary, noCustSessionSummary, secTechWaitingRoom, noneScreenSharing, no_arnotes_cust, no_arnotes_tech, arNotesFreezedState
  case surfaceDetection, anotateTurorial
  case slide1
  public var lottie: LensCustomerSDK.LottieAnimationView {
    get
  }
  public var lottieName: Swift.String {
    get
  }
  public var message: Swift.String? {
    get
  }
  public var size: CoreFoundation.CGSize? {
    get
  }
  public static func == (a: LensCustomerSDK.LensLottieType, b: LensCustomerSDK.LensLottieType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum AssistAlertActionStyle : LensCustomerSDK.AlertStyleConfiguration {
  case `default`, destructive, outlined
  public var backgroundColor: UIKit.UIColor {
    get
  }
  public var titleColor: UIKit.UIColor {
    get
  }
  public var borderColor: UIKit.UIColor? {
    get
  }
  public var borderWidth: CoreFoundation.CGFloat {
    get
  }
  public static func == (a: LensCustomerSDK.AssistAlertActionStyle, b: LensCustomerSDK.AssistAlertActionStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct LottieVector1D : Swift.Hashable, Swift.Sendable {
  public init(_ value: Swift.Double)
  public let value: Swift.Double
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.LottieVector1D, b: LensCustomerSDK.LottieVector1D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct LottieVector3D : Swift.Hashable, Swift.Sendable {
  public let x: Swift.Double
  public let y: Swift.Double
  public let z: Swift.Double
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.LottieVector3D, b: LensCustomerSDK.LottieVector3D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@objc final public class CompatibleAnimation : ObjectiveC.NSObject {
  @objc public init(name: Swift.String, subdirectory: Swift.String? = nil, bundle: Foundation.Bundle = Bundle.main)
  @objc deinit
}
@objc public enum CompatibleRenderingEngineOption : Swift.Int {
  case shared
  case defaultEngine
  case automatic
  case mainThread
  case coreAnimation
  public static func generateLottieConfiguration(_ configuration: LensCustomerSDK.CompatibleRenderingEngineOption) -> LensCustomerSDK.LottieConfiguration
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum CompatibleBackgroundBehavior : Swift.Int {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  case continuePlaying
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor @preconcurrency final public class CompatibleAnimationView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(compatibleAnimation: LensCustomerSDK.CompatibleAnimation)
  @objc @_Concurrency.MainActor @preconcurrency public init(compatibleAnimation: LensCustomerSDK.CompatibleAnimation, compatibleRenderingEngineOption: LensCustomerSDK.CompatibleRenderingEngineOption)
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(url: Foundation.URL)
  @objc @_Concurrency.MainActor @preconcurrency public init(url: Foundation.URL, compatibleRenderingEngineOption: LensCustomerSDK.CompatibleRenderingEngineOption)
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(data: Foundation.Data)
  @objc @_Concurrency.MainActor @preconcurrency public init(data: Foundation.Data, compatibleRenderingEngineOption: LensCustomerSDK.CompatibleRenderingEngineOption)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor @preconcurrency final public var compatibleAnimation: LensCustomerSDK.CompatibleAnimation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var loopAnimationCount: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var compatibleDictionaryTextProvider: LensCustomerSDK.CompatibleDictionaryTextProvider? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var shouldRasterizeWhenIdle: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentProgress: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var duration: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentFrame: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationFrame: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationProgress: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var animationSpeed: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var respectAnimationFrameRate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var isAnimationPlaying: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var backgroundMode: LensCustomerSDK.CompatibleBackgroundBehavior {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public func play()
  @objc @_Concurrency.MainActor @preconcurrency final public func play(completion: ((Swift.Bool) -> Swift.Void)?)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromProgress: CoreFoundation.CGFloat, toProgress: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromFrame: CoreFoundation.CGFloat, toFrame: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromMarker: Swift.String, toMarker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(marker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func stop()
  @objc @_Concurrency.MainActor @preconcurrency final public func pause()
  @objc @_Concurrency.MainActor @preconcurrency final public func reloadImages()
  @objc @_Concurrency.MainActor @preconcurrency final public func forceDisplayUpdate()
  @objc @_Concurrency.MainActor @preconcurrency final public func getValue(for keypath: LensCustomerSDK.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> Any?
  @objc @_Concurrency.MainActor @preconcurrency final public func logHierarchyKeypaths()
  @objc @_Concurrency.MainActor @preconcurrency final public func setColorValue(_ color: UIKit.UIColor, forKeypath keypath: LensCustomerSDK.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor @preconcurrency final public func getColorValue(for keypath: LensCustomerSDK.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> UIKit.UIColor?
  @objc @_Concurrency.MainActor @preconcurrency final public func addSubview(_ subview: LensCustomerSDK.AnimationSubview, forLayerAt keypath: LensCustomerSDK.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(rect: CoreFoundation.CGRect, toLayerAt keypath: LensCustomerSDK.CompatibleAnimationKeypath?) -> CoreFoundation.CGRect
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(point: CoreFoundation.CGPoint, toLayerAt keypath: LensCustomerSDK.CompatibleAnimationKeypath?) -> CoreFoundation.CGPoint
  @objc @_Concurrency.MainActor @preconcurrency final public func progressTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency final public func frameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency final public func durationFrameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc deinit
}
@objc final public class CompatibleDictionaryTextProvider : ObjectiveC.NSObject {
  @objc public init(values: [Swift.String : Swift.String])
  @objc deinit
}
public enum RenderingEngineOption : Swift.Hashable {
  case automatic
  case specific(LensCustomerSDK.RenderingEngine)
  public static var mainThread: LensCustomerSDK.RenderingEngineOption {
    get
  }
  public static var coreAnimation: LensCustomerSDK.RenderingEngineOption {
    get
  }
}
public enum RenderingEngine : Swift.Hashable {
  case mainThread
  case coreAnimation
}
extension LensCustomerSDK.RenderingEngineOption : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension LensCustomerSDK.RenderingEngine : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public class BundleImageProvider : LensCustomerSDK.AnimationImageProvider {
  public init(bundle: Foundation.Bundle, searchPath: Swift.String?, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public func imageForAsset(asset: LensCustomerSDK.ImageAsset) -> CoreGraphics.CGImage?
  public func contentsGravity(for _: LensCustomerSDK.ImageAsset) -> QuartzCore.CALayerContentsGravity
  @objc deinit
}
extension LensCustomerSDK.BundleImageProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.BundleImageProvider, rhs: LensCustomerSDK.BundleImageProvider) -> Swift.Bool
}
public struct SSLClientCertificateError : Foundation.LocalizedError {
  public var errorDescription: Swift.String?
}
public class SSLClientCertificate {
  convenience public init(pkcs12Path: Swift.String, password: Swift.String) throws
  public init(identity: Security.SecIdentity, identityCertificate: Security.SecCertificate)
  convenience public init(pkcs12Url: Foundation.URL, password: Swift.String) throws
  public init(pkcs12Url: Foundation.URL, importOptions: CoreFoundation.CFDictionary) throws
  @objc deinit
}
@available(*, deprecated, message: "Use DefaultAnimationCache instead, which is thread-safe and automatically responds to memory pressure.")
public typealias LRUAnimationCache = LensCustomerSDK.DefaultAnimationCache
@_Concurrency.MainActor @preconcurrency public struct LottieView<Placeholder> where Placeholder : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(animation: LensCustomerSDK.LottieAnimation?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(dotLottieFile: LensCustomerSDK.DotLottieFile?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> LensCustomerSDK.LottieAnimation?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> LensCustomerSDK.LottieAnimation?, @SwiftUICore.ViewBuilder placeholder: @escaping (() -> Placeholder))
  @_Concurrency.MainActor @preconcurrency public init(_ loadDotLottieFile: @escaping () async throws -> LensCustomerSDK.DotLottieFile?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadDotLottieFile: @escaping () async throws -> LensCustomerSDK.DotLottieFile?, @SwiftUICore.ViewBuilder placeholder: @escaping (() -> Placeholder))
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> LensCustomerSDK.LottieAnimationSource?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> LensCustomerSDK.LottieAnimationSource?, @SwiftUICore.ViewBuilder placeholder: @escaping () -> Placeholder)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure<Property>(_ property: Swift.ReferenceWritableKeyPath<LensCustomerSDK.LottieAnimationView, Property>, to value: Property) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func configure<Property>(_ property: Swift.ReferenceWritableKeyPath<LensCustomerSDK.LottieAnimationView, Property>, to value: Property) -> LensCustomerSDK.LottieView<Placeholder> where Property : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func configure(_ configure: @escaping (LensCustomerSDK.LottieAnimationView) -> Swift.Void) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func resizable() -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func intrinsicSize() -> LensCustomerSDK.LottieView<Placeholder>
  @available(*, deprecated, renamed: "playing()", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency public func play() -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func looping() -> LensCustomerSDK.LottieView<Placeholder>
  @available(*, deprecated, renamed: "playing(_:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency public func play(loopMode: LensCustomerSDK.LottieLoopMode = .playOnce) -> LensCustomerSDK.LottieView<Placeholder>
  @available(*, deprecated, renamed: "playbackMode(_:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency public func play(_ playbackMode: LensCustomerSDK.LottiePlaybackMode) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playing(_ mode: LensCustomerSDK.LottiePlaybackMode.PlaybackMode) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playing(loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playing() -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func paused(at state: LensCustomerSDK.LottiePlaybackMode.PausedState = .currentFrame) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playbackMode(_ playbackMode: LensCustomerSDK.LottiePlaybackMode) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func animationSpeed(_ animationSpeed: Swift.Double) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func animationDidLoad(_ animationDidLoad: @escaping (LensCustomerSDK.LottieAnimationSource) -> Swift.Void) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func animationDidFinish(_ animationCompletionHandler: LensCustomerSDK.LottieCompletionBlock?) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func backgroundBehavior(_ value: LensCustomerSDK.LottieBackgroundBehavior) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func accessibilityLabel(_ accessibilityLabel: Swift.String?) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func configuration(_ configuration: LensCustomerSDK.LottieConfiguration) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func logger(_ logger: LensCustomerSDK.LottieLogger) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func imageProvider<ImageProvider>(_ imageProvider: ImageProvider) -> LensCustomerSDK.LottieView<Placeholder> where ImageProvider : LensCustomerSDK.AnimationImageProvider, ImageProvider : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func textProvider<TextProvider>(_ textProvider: TextProvider) -> LensCustomerSDK.LottieView<Placeholder> where TextProvider : LensCustomerSDK.AnimationKeypathTextProvider, TextProvider : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func fontProvider<FontProvider>(_ fontProvider: FontProvider) -> LensCustomerSDK.LottieView<Placeholder> where FontProvider : LensCustomerSDK.AnimationFontProvider, FontProvider : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func valueProvider<ValueProvider>(_ valueProvider: ValueProvider, for keypath: LensCustomerSDK.AnimationKeypath) -> LensCustomerSDK.LottieView<Placeholder> where ValueProvider : LensCustomerSDK.AnyValueProvider, ValueProvider : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func currentProgress(_ currentProgress: LensCustomerSDK.AnimationProgressTime?) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func currentFrame(_ currentFrame: LensCustomerSDK.AnimationFrameTime?) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func currentTime(_ currentTime: Foundation.TimeInterval?) -> LensCustomerSDK.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func reloadAnimationTrigger(_ value: some Equatable, showPlaceholder: Swift.Bool = true) -> LensCustomerSDK.LottieView<Placeholder>
  @available(iOS 15.0, tvOS 15.0, macOS 12.0, *)
  @_Concurrency.MainActor @preconcurrency public func getRealtimeAnimationProgress(_ realtimeAnimationProgress: SwiftUICore.Binding<LensCustomerSDK.AnimationProgressTime>?) -> some SwiftUICore.View
  
  @available(iOS 15.0, tvOS 15.0, macOS 12.0, *)
  @_Concurrency.MainActor @preconcurrency public func getRealtimeAnimationFrame(_ realtimeAnimationFrame: SwiftUICore.Binding<LensCustomerSDK.AnimationFrameTime>?) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func dotLottieConfigurationComponents(_ dotLottieConfigurationComponents: LensCustomerSDK.DotLottieConfigurationComponents) -> LensCustomerSDK.LottieView<Placeholder>
  public typealias Body = @_opaqueReturnTypeOf("$s15LensCustomerSDK10LottieViewV4bodyQrvp", 0) __<Placeholder>
}
final public class SizeValueProvider {
  public init(block: @escaping LensCustomerSDK.SizeValueProvider.SizeValueBlock)
  public init(_ size: CoreFoundation.CGSize)
  public typealias SizeValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  final public var size: CoreFoundation.CGSize {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: LensCustomerSDK.ValueProviderStorage<LensCustomerSDK.LottieVector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.SizeValueProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.SizeValueProvider, rhs: LensCustomerSDK.SizeValueProvider) -> Swift.Bool
}
extension Swift.Bool {
  public var rawValue: Swift.String {
    get
  }
  public var intValue: Swift.Int {
    get
  }
}
@objc @_hasMissingDesignatedInitializers public class LottieAnimationLayer : QuartzCore.CALayer {
  public init(animation: LensCustomerSDK.LottieAnimation?, imageProvider: (any LensCustomerSDK.AnimationImageProvider)? = nil, textProvider: any LensCustomerSDK.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any LensCustomerSDK.AnimationFontProvider = DefaultFontProvider(), configuration: LensCustomerSDK.LottieConfiguration = .shared, logger: LensCustomerSDK.LottieLogger = .shared)
  public init(dotLottie: LensCustomerSDK.DotLottieFile?, animationId: Swift.String? = nil, textProvider: any LensCustomerSDK.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any LensCustomerSDK.AnimationFontProvider = DefaultFontProvider(), configuration: LensCustomerSDK.LottieConfiguration = .shared, logger: LensCustomerSDK.LottieLogger = .shared)
  public init(configuration: LensCustomerSDK.LottieConfiguration = .shared, logger: LensCustomerSDK.LottieLogger = .shared)
  open func play(completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func play(fromProgress: LensCustomerSDK.AnimationProgressTime? = nil, toProgress: LensCustomerSDK.AnimationProgressTime, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func play(fromFrame: LensCustomerSDK.AnimationFrameTime? = nil, toFrame: LensCustomerSDK.AnimationFrameTime, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func play(marker: Swift.String, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func play(markers: [Swift.String], completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func stop()
  open func pause()
  open func pause(at state: LensCustomerSDK.LottiePlaybackMode.PausedState)
  @available(*, deprecated, renamed: "setPlaybackMode(_:completion:)", message: "Will be removed in a future major release.")
  open func play(_ playbackMode: LensCustomerSDK.LottiePlaybackMode, animationCompletionHandler: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func setPlaybackMode(_ playbackMode: LensCustomerSDK.LottiePlaybackMode, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  open func play(_ playbackMode: LensCustomerSDK.LottiePlaybackMode.PlaybackMode, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  public var currentPlaybackMode: LensCustomerSDK.LottiePlaybackMode? {
    get
  }
  public var valueProviders: [LensCustomerSDK.AnimationKeypath : any LensCustomerSDK.AnyValueProvider] {
    get
  }
  public var animationLayerDidLoad: ((_ animationLayer: LensCustomerSDK.LottieAnimationLayer, _ renderingEngine: LensCustomerSDK.RenderingEngineOption) -> Swift.Void)?
  public var configuration: LensCustomerSDK.LottieConfiguration {
    get
    set
  }
  public var animationLayer: QuartzCore.CALayer? {
    get
  }
  public var screenScale: CoreFoundation.CGFloat {
    get
    set
  }
  public var backgroundBehavior: LensCustomerSDK.LottieBackgroundBehavior {
    get
    set
  }
  public var animation: LensCustomerSDK.LottieAnimation? {
    get
    set
  }
  public var animationLoaded: ((_ animationLayer: LensCustomerSDK.LottieAnimationLayer, _ animation: LensCustomerSDK.LottieAnimation) -> Swift.Void)? {
    get
    set
  }
  public var imageProvider: any LensCustomerSDK.AnimationImageProvider {
    get
    set
  }
  public var textProvider: any LensCustomerSDK.AnimationKeypathTextProvider {
    get
    set
  }
  public var fontProvider: any LensCustomerSDK.AnimationFontProvider {
    get
    set
  }
  public var maskAnimationToBounds: Swift.Bool {
    get
    set
  }
  public var isAnimationPlaying: Swift.Bool {
    get
  }
  public var loopMode: LensCustomerSDK.LottieLoopMode {
    get
    set
  }
  public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  public var currentProgress: LensCustomerSDK.AnimationProgressTime {
    get
    set
  }
  public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  public var currentFrame: LensCustomerSDK.AnimationFrameTime {
    get
    set
  }
  public var realtimeAnimationFrame: LensCustomerSDK.AnimationFrameTime {
    get
  }
  public var realtimeAnimationProgress: LensCustomerSDK.AnimationProgressTime {
    get
  }
  public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  public var currentRenderingEngine: LensCustomerSDK.RenderingEngine? {
    get
  }
  public var mainThreadRenderingEngineShouldForceDisplayUpdateOnEachFrame: Swift.Bool {
    get
    set
  }
  public func loadAnimation(_ animationId: Swift.String? = nil, from dotLottieFile: LensCustomerSDK.DotLottieFile)
  public func loadAnimation(atIndex index: Swift.Int, from dotLottieFile: LensCustomerSDK.DotLottieFile)
  public func reloadImages()
  public func forceDisplayUpdate()
  public func setValueProvider(_ valueProvider: any LensCustomerSDK.AnyValueProvider, keypath: LensCustomerSDK.AnimationKeypath)
  public func getValue(for keypath: LensCustomerSDK.AnimationKeypath, atFrame: LensCustomerSDK.AnimationFrameTime?) -> Any?
  public func getOriginalValue(for keypath: LensCustomerSDK.AnimationKeypath, atFrame: LensCustomerSDK.AnimationFrameTime?) -> Any?
  public func logHierarchyKeypaths()
  public func allHierarchyKeypaths() -> [Swift.String]
  public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: LensCustomerSDK.AnimationKeypath?) -> CoreFoundation.CGRect?
  public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: LensCustomerSDK.AnimationKeypath?) -> CoreFoundation.CGPoint?
  public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: LensCustomerSDK.AnimationKeypath)
  public func progressTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationProgressTime?
  public func frameTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationFrameTime?
  public func durationFrameTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationFrameTime?
  public func updateAnimationForBackgroundState()
  public func updateAnimationForForegroundState(wasWaitingToPlayAnimation: Swift.Bool)
  @objc deinit
}
public class FilepathImageProvider : LensCustomerSDK.AnimationImageProvider {
  public init(filepath: Swift.String, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public init(filepath: Foundation.URL, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public func imageForAsset(asset: LensCustomerSDK.ImageAsset) -> CoreGraphics.CGImage?
  public func contentsGravity(for _: LensCustomerSDK.ImageAsset) -> QuartzCore.CALayerContentsGravity
  @objc deinit
}
extension LensCustomerSDK.FilepathImageProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.FilepathImageProvider, rhs: LensCustomerSDK.FilepathImageProvider) -> Swift.Bool
}
public enum LottiePlaybackMode : Swift.Hashable {
  case paused(at: LensCustomerSDK.LottiePlaybackMode.PausedState)
  case playing(_: LensCustomerSDK.LottiePlaybackMode.PlaybackMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case progress(_: LensCustomerSDK.AnimationProgressTime)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case frame(_: LensCustomerSDK.AnimationFrameTime)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case time(_: Foundation.TimeInterval)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case pause
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromProgress(_: LensCustomerSDK.AnimationProgressTime?, toProgress: LensCustomerSDK.AnimationProgressTime, loopMode: LensCustomerSDK.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromFrame(_: LensCustomerSDK.AnimationFrameTime?, toFrame: LensCustomerSDK.AnimationFrameTime, loopMode: LensCustomerSDK.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromMarker(_: Swift.String?, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: LensCustomerSDK.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case marker(_: Swift.String, loopMode: LensCustomerSDK.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case markers(_: [Swift.String])
  public enum PausedState : Swift.Hashable {
    case currentFrame
    case progress(_: LensCustomerSDK.AnimationProgressTime)
    case frame(_: LensCustomerSDK.AnimationFrameTime)
    case time(_: Foundation.TimeInterval)
    case marker(_: Swift.String, position: LensCustomerSDK.LottieMarkerPosition = .start)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: LensCustomerSDK.LottiePlaybackMode.PausedState, b: LensCustomerSDK.LottiePlaybackMode.PausedState) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum PlaybackMode : Swift.Hashable {
    case fromProgress(_: LensCustomerSDK.AnimationProgressTime?, toProgress: LensCustomerSDK.AnimationProgressTime, loopMode: LensCustomerSDK.LottieLoopMode)
    case fromFrame(_: LensCustomerSDK.AnimationFrameTime?, toFrame: LensCustomerSDK.AnimationFrameTime, loopMode: LensCustomerSDK.LottieLoopMode)
    case fromMarker(_: Swift.String?, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: LensCustomerSDK.LottieLoopMode)
    case marker(_: Swift.String, loopMode: LensCustomerSDK.LottieLoopMode)
    case markers(_: [Swift.String])
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: LensCustomerSDK.LottiePlaybackMode.PlaybackMode, b: LensCustomerSDK.LottiePlaybackMode.PlaybackMode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.LottiePlaybackMode, b: LensCustomerSDK.LottiePlaybackMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LensCustomerSDK.LottiePlaybackMode {
  public static var paused: LensCustomerSDK.LottiePlaybackMode {
    get
  }
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toProgress(_ toProgress: LensCustomerSDK.AnimationProgressTime, loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottiePlaybackMode
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toFrame(_ toFrame: LensCustomerSDK.AnimationFrameTime, loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottiePlaybackMode
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toMarker(_ toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottiePlaybackMode
}
extension LensCustomerSDK.LottiePlaybackMode.PlaybackMode {
  public static func toProgress(_ toProgress: LensCustomerSDK.AnimationProgressTime, loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottiePlaybackMode.PlaybackMode
  public static func toFrame(_ toFrame: LensCustomerSDK.AnimationFrameTime, loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottiePlaybackMode.PlaybackMode
  public static func toMarker(_ toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: LensCustomerSDK.LottieLoopMode) -> LensCustomerSDK.LottiePlaybackMode.PlaybackMode
}
public enum LottieMarkerPosition : Swift.Hashable {
  case start
  case end
  public static func == (a: LensCustomerSDK.LottieMarkerPosition, b: LensCustomerSDK.LottieMarkerPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency public func addChildren(viewController: UIKit.UIViewController, containerView: UIKit.UIView? = nil, isSafeArea: Swift.Bool = false)
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
open class ATAbstractDataSource : ObjectiveC.NSObject, LensCustomerSDK.ATDataSource, LensCustomerSDK.ATDelegate {
  public var estimatedRowHeight: CoreFoundation.CGFloat
  public var estimatedSectionHeaderHeight: CoreFoundation.CGFloat
  public var estimatedSectionFooterHeight: CoreFoundation.CGFloat
  public func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  public func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, viewForFooterInSection section: Swift.Int) -> UIKit.UIView?
  public func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, cellForItemAt indexpath: Foundation.IndexPath) -> any LensCustomerSDK.ATReusableCell
  public func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
  public func at_numberOfSections() -> Swift.Int
  public func at_numberOfItems(inSection section: Swift.Int) -> Swift.Int
  public func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, heightForHeaderInSection section: Swift.Int) -> CoreFoundation.CGFloat
  public func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, heightForFooterInSection section: Swift.Int) -> CoreFoundation.CGFloat
  public func at_scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  public func at_scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  public func at_scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  public func at_scrollViewDidEndScroll(_ scrollView: UIKit.UIScrollView)
  public func at_scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  public func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, didDeselectItemAt indexPath: Foundation.IndexPath)
  public func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
  public func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, willDisplay cell: any LensCustomerSDK.ATReusableCell, forItemAt indexPath: Foundation.IndexPath)
  public func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, willDisplayHeaderView view: UIKit.UIView, forSection section: Swift.Int)
  public func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, willDisplayFooterView view: UIKit.UIView, forSection section: Swift.Int)
  public func at_sizeOfCollectionViewHeader(collectionView: any LensCustomerSDK.ATGeneralCollectionView, inSection section: Swift.Int) -> CoreFoundation.CGSize
  public func at_sizeOfcollectionViewFooter(collectionView: any LensCustomerSDK.ATGeneralCollectionView, inSection section: Swift.Int) -> CoreFoundation.CGSize
  public func at_sizeOfcollectionViewFooter(collectionView: any LensCustomerSDK.ATGeneralCollectionView, heightForFooterInSection section: Swift.Int) -> CoreFoundation.CGSize
  public func at_shouldShowMenuController(at indexPath: Foundation.IndexPath) -> Swift.Bool
  public func at_canPerformMenuController(at indexPath: Foundation.IndexPath, selector: ObjectiveC.Selector) -> Swift.Bool
  public func at_perfomMenuController(at indexPath: Foundation.IndexPath, selector: ObjectiveC.Selector)
  @objc override dynamic public init()
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.ATAbstractDataSource : UIKit.UITableViewDelegate, UIKit.UITableViewDataSource {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, heightForRowAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, heightForFooterInSection section: Swift.Int) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, viewForFooterInSection section: Swift.Int) -> UIKit.UIView?
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, didDeselectRowAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, willDisplay cell: UIKit.UITableViewCell, forRowAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, willDisplayFooterView view: UIKit.UIView, forSection section: Swift.Int)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, willDisplayHeaderView view: UIKit.UIView, forSection section: Swift.Int)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, shouldShowMenuForRowAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, canPerformAction action: ObjectiveC.Selector, forRowAt indexPath: Foundation.IndexPath, withSender sender: Any?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, performAction action: ObjectiveC.Selector, forRowAt indexPath: Foundation.IndexPath, withSender sender: Any?)
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.ATAbstractDataSource : UIKit.UICollectionViewDataSource {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func numberOfSections(in collectionView: UIKit.UICollectionView) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, viewForSupplementaryElementOfKind kind: Swift.String, at indexPath: Foundation.IndexPath) -> UIKit.UICollectionReusableView
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, referenceSizeForHeaderInSection section: Swift.Int) -> CoreFoundation.CGSize
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, referenceSizeForFooterInSection section: Swift.Int) -> CoreFoundation.CGSize
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.ATAbstractDataSource : UIKit.UICollectionViewDelegateFlowLayout {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.ATAbstractDataSource : UIKit.UICollectionViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didDeselectItemAt indexPath: Foundation.IndexPath)
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.ATAbstractDataSource {
  @objc dynamic public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @objc dynamic public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @objc dynamic public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @objc dynamic public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
}
@available(iOSApplicationExtension, unavailable)
public protocol ATGeneralCollectionView {
  func at_registerCell(forClass cellClass: Swift.AnyClass, identifier: Swift.String)
  func at_registerCell(forXib nib: UIKit.UINib?, identifier: Swift.String)
  func at_dequeueReusableCell(withIdentifier: Swift.String, indexPath: Foundation.IndexPath) -> any LensCustomerSDK.ATReusableCell
  func at_cellForItemAt(_ indexPath: Foundation.IndexPath) -> (any LensCustomerSDK.ATReusableCell)?
}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UITableView : LensCustomerSDK.ATGeneralCollectionView {
  @_Concurrency.MainActor @preconcurrency public func at_cellForItemAt(_ indexPath: Foundation.IndexPath) -> (any LensCustomerSDK.ATReusableCell)?
  @_Concurrency.MainActor @preconcurrency public func at_registerCell(forXib nib: UIKit.UINib?, identifier: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func at_registerCell(forClass cellClass: Swift.AnyClass, identifier: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func at_dequeueReusableCell(withIdentifier: Swift.String, indexPath: Foundation.IndexPath) -> any LensCustomerSDK.ATReusableCell
}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UICollectionView : LensCustomerSDK.ATGeneralCollectionView {
  @_Concurrency.MainActor @preconcurrency public func at_cellForItemAt(_ indexPath: Foundation.IndexPath) -> (any LensCustomerSDK.ATReusableCell)?
  @_Concurrency.MainActor @preconcurrency public func at_registerCell(forXib nib: UIKit.UINib?, identifier: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func at_registerCell(forClass cellClass: Swift.AnyClass, identifier: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func at_dequeueReusableCell(withIdentifier: Swift.String, indexPath: Foundation.IndexPath) -> any LensCustomerSDK.ATReusableCell
}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func at_useDataSource(_ datasource: LensCustomerSDK.ATAbstractDataSource)
}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UICollectionView {
  @_Concurrency.MainActor @preconcurrency public func at_useDataSource(_ datasource: LensCustomerSDK.ATAbstractDataSource)
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class AssistCollectionDataSource<ItemType, CellType> : LensCustomerSDK.ATAbstractDataSource where CellType : LensCustomerSDK.ATReusableCell {
  public typealias Section = Swift.Int
  @_Concurrency.MainActor @preconcurrency public var sections: [LensCustomerSDK.ATSection<ItemType>] {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var configureCell: ((_ item: ItemType, _ cell: CellType, _ indexPath: Foundation.IndexPath) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var cellIdentifier: ((_ item: ItemType, _ indexPath: Foundation.IndexPath) -> Swift.String)?
  @_Concurrency.MainActor @preconcurrency public var actionHandler: ((LensCustomerSDK.AssistCollectionActionType<ItemType, CellType>) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var handleNoData: ((_ isNodata: Swift.Bool, _ sections: [LensCustomerSDK.ATSection<ItemType>]) -> ())?
  @_Concurrency.MainActor @preconcurrency public var scrollViewDidEndScroll: ((UIKit.UIScrollView) -> ())?
  @_Concurrency.MainActor @preconcurrency public var scrollViewDidScroll: ((UIKit.UIScrollView) -> ())?
  @_Concurrency.MainActor @preconcurrency public var scrollViewWillBeginDragging: ((UIKit.UIScrollView) -> ())?
  @_Concurrency.MainActor @preconcurrency public var scrollViewDidEndDecelerating: ((UIKit.UIScrollView) -> ())?
  @_Concurrency.MainActor @preconcurrency public var scrollViewDidEndDraging: ((_ scrollView: UIKit.UIScrollView, _ isDecelerating: Swift.Bool) -> ())?
  @_Concurrency.MainActor @preconcurrency public var willDisplayCell: ((_ cell: CellType, _ indexPath: Foundation.IndexPath) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var willDisplaySectionFooter: ((_ headerView: UIKit.UIView, _ section: Swift.Int) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var willDisplaySectionHeader: ((_ footerView: UIKit.UIView, _ section: Swift.Int) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var shouldShowMenuController: ((Foundation.IndexPath) -> Swift.Bool)?
  @_Concurrency.MainActor @preconcurrency public var canShowMenuController: ((Foundation.IndexPath, ObjectiveC.Selector) -> Swift.Bool)?
  @_Concurrency.MainActor @preconcurrency public var performMenuController: ((Foundation.IndexPath, ObjectiveC.Selector) -> Swift.Void)?
  override public func at_numberOfSections() -> Swift.Int
  override public func at_numberOfItems(inSection section: Swift.Int) -> Swift.Int
  override public func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, heightForHeaderInSection section: Swift.Int) -> CoreFoundation.CGFloat
  override public func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, heightForFooterInSection section: Swift.Int) -> CoreFoundation.CGFloat
  override public func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  override public func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, viewForFooterInSection section: Swift.Int) -> UIKit.UIView?
  override public func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
  override public func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, cellForItemAt indexpath: Foundation.IndexPath) -> any LensCustomerSDK.ATReusableCell
  override public func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
  override public func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, didDeselectItemAt indexPath: Foundation.IndexPath)
  override public func at_scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  override public func at_scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  override public func at_scrollViewDidEndScroll(_ scrollView: UIKit.UIScrollView)
  override public func at_scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  override public func at_scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  override public func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, willDisplay cell: any LensCustomerSDK.ATReusableCell, forItemAt indexPath: Foundation.IndexPath)
  override public func at_collectionView(_ tableView: any LensCustomerSDK.ATGeneralCollectionView, willDisplayHeaderView view: UIKit.UIView, forSection section: Swift.Int)
  override public func at_collectionView(_ tableView: any LensCustomerSDK.ATGeneralCollectionView, willDisplayFooterView view: UIKit.UIView, forSection section: Swift.Int)
  override public func at_sizeOfCollectionViewHeader(collectionView: any LensCustomerSDK.ATGeneralCollectionView, inSection section: Swift.Int) -> CoreFoundation.CGSize
  override public func at_sizeOfcollectionViewFooter(collectionView: any LensCustomerSDK.ATGeneralCollectionView, inSection section: Swift.Int) -> CoreFoundation.CGSize
  override public func at_canPerformMenuController(at indexPath: Foundation.IndexPath, selector: ObjectiveC.Selector) -> Swift.Bool
  override public func at_shouldShowMenuController(at indexPath: Foundation.IndexPath) -> Swift.Bool
  override public func at_perfomMenuController(at indexPath: Foundation.IndexPath, selector: ObjectiveC.Selector)
  @_Concurrency.MainActor @preconcurrency public func addSection(_ section: LensCustomerSDK.ATSection<ItemType>)
  @_Concurrency.MainActor @preconcurrency public func getItemFor(indexPath: Foundation.IndexPath) -> ItemType
  @_Concurrency.MainActor @preconcurrency public func indexPath(where completion: (ItemType) -> Swift.Bool) -> Foundation.IndexPath?
  @_Concurrency.MainActor @preconcurrency public func getSection(for index: Swift.Int) -> LensCustomerSDK.ATSection<ItemType>
  @discardableResult
  @_Concurrency.MainActor @preconcurrency public func delete(itemAt indexPath: Foundation.IndexPath) -> ItemType
  @_Concurrency.MainActor @preconcurrency public func update(itemAt item: ItemType, for indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency public func insert(itemsAt items: [ItemType], at indexPath: Foundation.IndexPath)
  @discardableResult
  @_Concurrency.MainActor @preconcurrency public func addItems(_ items: [ItemType], at section: LensCustomerSDK.AssistCollectionDataSource<ItemType, CellType>.Section) -> [Foundation.IndexPath]
  @_Concurrency.MainActor @preconcurrency public func insert(section: LensCustomerSDK.ATSection<ItemType>, at index: Swift.Int)
  @_Concurrency.MainActor @preconcurrency public func numberOfRows(forSection section: Swift.Int) -> Swift.Int
  @objc override dynamic public init()
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.AssistCollectionDataSource {
  @_Concurrency.MainActor @preconcurrency public var lastIndexPath: Foundation.IndexPath? {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
public enum AssistCollectionActionType<ItemType, CellType> where CellType : LensCustomerSDK.ATReusableCell {
  case select(item: ItemType, cell: CellType?, indexpath: Foundation.IndexPath)
  case deSelect(item: ItemType, cell: CellType?, indexpath: Foundation.IndexPath)
}
@available(iOSApplicationExtension, unavailable)
public protocol ATDataSource {
  var estimatedRowHeight: CoreFoundation.CGFloat { get set }
  var estimatedSectionHeaderHeight: CoreFoundation.CGFloat { get set }
  var estimatedSectionFooterHeight: CoreFoundation.CGFloat { get set }
  func at_numberOfSections() -> Swift.Int
  func at_numberOfItems(inSection section: Swift.Int) -> Swift.Int
  func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
  func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, cellForItemAt indexpath: Foundation.IndexPath) -> any LensCustomerSDK.ATReusableCell
  func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, heightForHeaderInSection section: Swift.Int) -> CoreFoundation.CGFloat
  func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, heightForFooterInSection section: Swift.Int) -> CoreFoundation.CGFloat
  func at_collectionView(collectionView: any LensCustomerSDK.ATGeneralCollectionView, viewForFooterInSection section: Swift.Int) -> UIKit.UIView?
  func at_sizeOfCollectionViewHeader(collectionView: any LensCustomerSDK.ATGeneralCollectionView, inSection section: Swift.Int) -> CoreFoundation.CGSize
  func at_sizeOfcollectionViewFooter(collectionView: any LensCustomerSDK.ATGeneralCollectionView, inSection section: Swift.Int) -> CoreFoundation.CGSize
}
@available(iOSApplicationExtension, unavailable)
public protocol ATDelegate : LensCustomerSDK.ATScrollDelegate {
  func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
  func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, willDisplay cell: any LensCustomerSDK.ATReusableCell, forItemAt indexPath: Foundation.IndexPath)
  func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, willDisplayHeaderView view: UIKit.UIView, forSection section: Swift.Int)
  func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, willDisplayFooterView view: UIKit.UIView, forSection section: Swift.Int)
  func at_collectionView(_ collectionView: any LensCustomerSDK.ATGeneralCollectionView, didDeselectItemAt indexPath: Foundation.IndexPath)
  func at_shouldShowMenuController(at indexPath: Foundation.IndexPath) -> Swift.Bool
  func at_canPerformMenuController(at indexPath: Foundation.IndexPath, selector: ObjectiveC.Selector) -> Swift.Bool
  func at_perfomMenuController(at indexPath: Foundation.IndexPath, selector: ObjectiveC.Selector)
}
@available(iOSApplicationExtension, unavailable)
public protocol ATScrollDelegate {
  func at_scrollViewDidEndScroll(_ scrollView: UIKit.UIScrollView)
  func at_scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  func at_scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  func at_scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  func at_scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
}
@available(iOSApplicationExtension, unavailable)
open class ATSection<ItemType> {
  public var identifier: Swift.String?
  open var items: [ItemType]
  open var title: Swift.String?
  open var sizeForItem: ((_ section: LensCustomerSDK.ATSection<ItemType>, _ indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize)?
  open var heightForSectionHeader: ((LensCustomerSDK.ATSection<ItemType>) -> CoreFoundation.CGFloat)?
  open var heightForSectionFooter: ((LensCustomerSDK.ATSection<ItemType>) -> CoreFoundation.CGFloat)?
  open var headerViewForSection: ((LensCustomerSDK.ATSection<ItemType>) -> UIKit.UIView?)?
  open var footerViewForSection: ((LensCustomerSDK.ATSection<ItemType>) -> UIKit.UIView?)?
  open var sizeForSectionHeader: ((LensCustomerSDK.ATSection<ItemType>) -> CoreFoundation.CGSize)?
  open var sizeForSectionFooter: ((LensCustomerSDK.ATSection<ItemType>) -> CoreFoundation.CGSize)?
  public init(title: Swift.String? = nil, items: [ItemType] = [])
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
public protocol ATReusableCell {
}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UITableViewCell : LensCustomerSDK.ATReusableCell {
}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UICollectionViewCell : LensCustomerSDK.ATReusableCell {
}
public typealias AnimationFrameTime = CoreFoundation.CGFloat
public typealias AnimationProgressTime = CoreFoundation.CGFloat
@_hasMissingDesignatedInitializers public class VMJsonManager {
  public class func convertToDictionary(text: Swift.String) -> [Swift.String : Any]?
  public class func data(jsonObject: Any) -> Foundation.Data?
  public class func formData(jsonObject: [Swift.String : Any]?) -> Foundation.Data?
  public class func json(data: Foundation.Data) -> Any
  public class func isValid(json: Any) -> Swift.Bool
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency open class OrientationHelperController : UIKit.UIViewController, LensCustomerSDK.OrientationHandler {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency open func deviceRotated(_ currentOrientation: UIKit.UIDeviceOrientation)
  @_Concurrency.MainActor @preconcurrency open func supportedOrientation() -> LensCustomerSDK.At_Orientation
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
public enum At_Orientation {
  case landscape, landscapeLeft, landscapeRight, portrait, all, allButUpsideDown
  public var orientationMask: UIKit.UIInterfaceOrientationMask {
    get
  }
  public static func at_orientaion(deviceOrientation: UIKit.UIDeviceOrientation) -> LensCustomerSDK.At_Orientation
  public static func at_orientaion(orientationMask: UIKit.UIInterfaceOrientationMask) -> LensCustomerSDK.At_Orientation
  public var interfaceOrientation: UIKit.UIInterfaceOrientation {
    get
  }
  public static func == (a: LensCustomerSDK.At_Orientation, b: LensCustomerSDK.At_Orientation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
public protocol OrientationChanger {
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.OrientationChanger {
  public func changeOriantaion(atoriantation: LensCustomerSDK.At_Orientation)
  public func changeOriantaion(deviceOriantation: UIKit.UIDeviceOrientation)
  public func changeOriantaion(oriantationMask: UIKit.UIInterfaceOrientationMask)
}
@available(iOSApplicationExtension, unavailable)
public protocol OrientationHandler : LensCustomerSDK.OrientationChanger {
  func supportedOrientation() -> LensCustomerSDK.At_Orientation
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.OrientationHandler where Self : UIKit.UIViewController {
  public func supportedOrientation() -> LensCustomerSDK.At_Orientation
  public var currentOrientation: LensCustomerSDK.At_Orientation {
    get
  }
}
public protocol SSLTrustValidator {
  func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
}
open class SSLCert {
  public init(data: Foundation.Data)
  public init(key: Security.SecKey)
  @objc deinit
}
open class SSLSecurity : LensCustomerSDK.SSLTrustValidator {
  public var validatedDN: Swift.Bool
  public var validateEntireChain: Swift.Bool
  convenience public init(usePublicKeys: Swift.Bool = false)
  public init(certs: [LensCustomerSDK.SSLCert], usePublicKeys: Swift.Bool)
  open func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
  public func extractPublicKey(_ data: Foundation.Data) -> Security.SecKey?
  public func extractPublicKey(_ cert: Security.SecCertificate, policy: Security.SecPolicy) -> Security.SecKey?
  public func certificateChain(_ trust: Security.SecTrust) -> [Foundation.Data]
  public func publicKeyChain(_ trust: Security.SecTrust) -> [Security.SecKey]
  @objc deinit
}
public enum LottieBackgroundBehavior {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  case continuePlaying
  public static func `default`(for renderingEngine: LensCustomerSDK.RenderingEngine) -> LensCustomerSDK.LottieBackgroundBehavior
  public static func == (a: LensCustomerSDK.LottieBackgroundBehavior, b: LensCustomerSDK.LottieBackgroundBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LottieLoopMode : Swift.Hashable {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LensCustomerSDK.LottieLoopMode : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.LottieLoopMode, rhs: LensCustomerSDK.LottieLoopMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor @preconcurrency open class LottieAnimationView : LensCustomerSDK.LottieAnimationViewBase {
  @_Concurrency.MainActor @preconcurrency public init(animation: LensCustomerSDK.LottieAnimation?, imageProvider: (any LensCustomerSDK.AnimationImageProvider)? = nil, textProvider: any LensCustomerSDK.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any LensCustomerSDK.AnimationFontProvider = DefaultFontProvider(), configuration: LensCustomerSDK.LottieConfiguration = .shared, logger: LensCustomerSDK.LottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency public init(dotLottie: LensCustomerSDK.DotLottieFile?, animationId: Swift.String? = nil, textProvider: any LensCustomerSDK.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any LensCustomerSDK.AnimationFontProvider = DefaultFontProvider(), configuration: LensCustomerSDK.LottieConfiguration = .shared, logger: LensCustomerSDK.LottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency public init(configuration: LensCustomerSDK.LottieConfiguration = .shared, logger: LensCustomerSDK.LottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency open func play(_ mode: LensCustomerSDK.LottiePlaybackMode.PlaybackMode, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(fromProgress: LensCustomerSDK.AnimationProgressTime? = nil, toProgress: LensCustomerSDK.AnimationProgressTime, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(fromFrame: LensCustomerSDK.AnimationFrameTime? = nil, toFrame: LensCustomerSDK.AnimationFrameTime, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(marker: Swift.String, loopMode: LensCustomerSDK.LottieLoopMode? = nil, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(markers: [Swift.String], completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func stop()
  @_Concurrency.MainActor @preconcurrency open func pause()
  @available(*, deprecated, renamed: "setPlaybackMode(_:completion:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency open func play(_ playbackMode: LensCustomerSDK.LottiePlaybackMode, animationCompletionHandler: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func setPlaybackMode(_ playbackMode: LensCustomerSDK.LottiePlaybackMode, completion: LensCustomerSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency public var animateLayoutChangesWithCurrentCoreAnimationContext: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var configuration: LensCustomerSDK.LottieConfiguration {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var valueProviders: [LensCustomerSDK.AnimationKeypath : any LensCustomerSDK.AnyValueProvider] {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var backgroundBehavior: LensCustomerSDK.LottieBackgroundBehavior {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animation: LensCustomerSDK.LottieAnimation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animationLoaded: ((_ animationView: LensCustomerSDK.LottieAnimationView, _ animation: LensCustomerSDK.LottieAnimation) -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var imageProvider: any LensCustomerSDK.AnimationImageProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var textProvider: any LensCustomerSDK.AnimationKeypathTextProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var fontProvider: any LensCustomerSDK.AnimationFontProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var maskAnimationToBounds: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var isAnimationPlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var isAnimationQueued: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var loopMode: LensCustomerSDK.LottieLoopMode {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentProgress: LensCustomerSDK.AnimationProgressTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentFrame: LensCustomerSDK.AnimationFrameTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var realtimeAnimationFrame: LensCustomerSDK.AnimationFrameTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var realtimeAnimationProgress: LensCustomerSDK.AnimationProgressTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var viewportFrame: CoreFoundation.CGRect? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency public var currentRenderingEngine: LensCustomerSDK.RenderingEngine? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var currentPlaybackMode: LensCustomerSDK.LottiePlaybackMode? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var mainThreadRenderingEngineShouldForceDisplayUpdateOnEachFrame: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func loadAnimation(_ animationId: Swift.String? = nil, from dotLottieFile: LensCustomerSDK.DotLottieFile)
  @_Concurrency.MainActor @preconcurrency public func loadAnimation(atIndex index: Swift.Int, from dotLottieFile: LensCustomerSDK.DotLottieFile)
  @_Concurrency.MainActor @preconcurrency public func reloadImages()
  @_Concurrency.MainActor @preconcurrency public func forceDisplayUpdate()
  @_Concurrency.MainActor @preconcurrency public func setValueProvider(_ valueProvider: any LensCustomerSDK.AnyValueProvider, keypath: LensCustomerSDK.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public func getValue(for keypath: LensCustomerSDK.AnimationKeypath, atFrame: LensCustomerSDK.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor @preconcurrency public func getOriginalValue(for keypath: LensCustomerSDK.AnimationKeypath, atFrame: LensCustomerSDK.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor @preconcurrency public func logHierarchyKeypaths()
  @_Concurrency.MainActor @preconcurrency public func allHierarchyKeypaths() -> [Swift.String]
  @_Concurrency.MainActor @preconcurrency public func addSubview(_ subview: LensCustomerSDK.AnimationSubview, forLayerAt keypath: LensCustomerSDK.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: LensCustomerSDK.AnimationKeypath?) -> CoreFoundation.CGRect?
  @_Concurrency.MainActor @preconcurrency public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: LensCustomerSDK.AnimationKeypath?) -> CoreFoundation.CGPoint?
  @_Concurrency.MainActor @preconcurrency public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: LensCustomerSDK.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public func progressTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationProgressTime?
  @_Concurrency.MainActor @preconcurrency public func frameTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationFrameTime?
  @_Concurrency.MainActor @preconcurrency public func durationFrameTime(forMarker named: Swift.String) -> LensCustomerSDK.AnimationFrameTime?
  @objc deinit
}
public class DotLottieCache : LensCustomerSDK.DotLottieCacheProvider {
  public init()
  public static let sharedCache: LensCustomerSDK.DotLottieCache
  public var cacheSize: Swift.Int {
    get
    set
  }
  public func clearCache()
  public func file(forKey key: Swift.String) -> LensCustomerSDK.DotLottieFile?
  public func setFile(_ lottie: LensCustomerSDK.DotLottieFile, forKey key: Swift.String)
  @objc deinit
}
extension LensCustomerSDK.DotLottieCache : @unchecked Swift.Sendable {
}
public protocol AnimationCacheProvider : AnyObject, Swift.Sendable {
  func animation(forKey: Swift.String) -> LensCustomerSDK.LottieAnimation?
  func setAnimation(_ animation: LensCustomerSDK.LottieAnimation, forKey: Swift.String)
  func clearCache()
}
@available(iOSApplicationExtension, unavailable)
public enum OverlayViewType {
  case blurView, normalView
  public static func == (a: LensCustomerSDK.OverlayViewType, b: LensCustomerSDK.OverlayViewType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency open class OverlayViewController : LensCustomerSDK.OrientationHelperController {
  @_Concurrency.MainActor @preconcurrency public var isTapOutsideDissmissEnabled: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var overlayType: LensCustomerSDK.OverlayViewType
  @_Concurrency.MainActor @preconcurrency public var overlayStyle: LensCustomerSDK.OverlayViewStyle
  @_Concurrency.MainActor @preconcurrency public var overlayColorTint: UIKit.UIColor?
  @_Concurrency.MainActor @preconcurrency public var overlayColorTintAlpha: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public var overlayAlpha: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func didReceiveMemoryWarning()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func dismiss(animated flag: Swift.Bool, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func dismissOverlayController(animated flag: Swift.Bool, completion: (() -> Swift.Void)? = nil)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
public enum OverlayViewStyle : Swift.Int {
  case extraLight
  case light
  case dark
  case extraDark
  public init?(rawValue: Swift.Int)
  @available(iOSApplicationExtension, unavailable)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension Foundation.TimeZone {
  public func hoursFromGMT() -> Swift.String
  public func hoursFromGMTWithSign() -> Swift.String
}
@_Concurrency.MainActor @preconcurrency public struct LottieButton {
  @_Concurrency.MainActor @preconcurrency public init(animation: LensCustomerSDK.LottieAnimation?, action: @escaping () -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure(_ configure: @escaping (LensCustomerSDK.AnimatedButton) -> Swift.Void) -> LensCustomerSDK.LottieButton
  @_Concurrency.MainActor @preconcurrency public func configuration(_ configuration: LensCustomerSDK.LottieConfiguration) -> LensCustomerSDK.LottieButton
  @_Concurrency.MainActor @preconcurrency public func animate(fromProgress: LensCustomerSDK.AnimationProgressTime, toProgress: LensCustomerSDK.AnimationProgressTime, on event: LensCustomerSDK.LottieControlEvent) -> LensCustomerSDK.LottieButton
  @_Concurrency.MainActor @preconcurrency public func animate(fromMarker: Swift.String, toMarker: Swift.String, on event: LensCustomerSDK.LottieControlEvent) -> LensCustomerSDK.LottieButton
  @_Concurrency.MainActor @preconcurrency public func valueProvider<ValueProvider>(_ valueProvider: ValueProvider, for keypath: LensCustomerSDK.AnimationKeypath) -> LensCustomerSDK.LottieButton where ValueProvider : LensCustomerSDK.AnyValueProvider, ValueProvider : Swift.Equatable
  public typealias Body = @_opaqueReturnTypeOf("$s15LensCustomerSDK12LottieButtonV4bodyQrvp", 0) __
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ImageAsset : LensCustomerSDK.Asset {
  final public let name: Swift.String
  final public let directory: Swift.String
  final public let width: Swift.Double
  final public let height: Swift.Double
  override final public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func makeCornerRadius(with value: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency public func makeBlendEdge(withPoint: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency public func makeBlendEdge(heightDevideBy: CoreFoundation.CGFloat = 06)
  @_Concurrency.MainActor @preconcurrency public var isCircle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func layoutIfNeededWithAnimation()
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var safeAreaInsets_Below11Also: UIKit.UIEdgeInsets {
    get
  }
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func makeSecure()
}
public protocol AssistSocketProtocol : AnyObject {
  func didSocketConnected()
  func didSocketDisconnected(_ error: (any Swift.Error)?)
  func didReceive(_ data: Foundation.Data)
  func didReceive(_ string: Swift.String)
  func custom_socket(call_back listerner: any LensCustomerSDK.WebSocketCallBack) -> (any LensCustomerSDK.WebSocketProtocol)?
  var canReceiveData: Swift.Bool { get set }
}
public protocol WebSocketCallBack : AnyObject {
  func onConnect()
  func onDisconnect(error: (any Swift.Error)?)
  func onTextReceive(_ text: Swift.String)
  func onDataReceive(_ data: Foundation.Data)
}
public protocol WebSocketProtocol : AnyObject {
  var disableSSLCertValidation: Swift.Bool { get set }
  var is_connected: Swift.Bool { get }
  func disconnect()
  func write(data: Foundation.Data)
  func write(string: Swift.String)
  func connect(websocket url: Foundation.URLRequest)
  func lostNetwork()
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor @preconcurrency public var isIPad: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var isHighResIPad: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var modelName: Swift.String {
    get
  }
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor @preconcurrency public var isIPhone5: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var isMaxOrPlusDevice: Swift.Bool {
    get
  }
  public enum ScreenType : Swift.String {
    case iPhone4_4S
    case iPhones_5_5s_5c_SE
    case iPhones_6_6s_7_8
    case iPhones_6Plus_6sPlus_7Plus_8Plus
    case iPhoneXR
    case iPhoneX_iPhoneXS
    case iPhoneXSMax
    case unknown
    public init?(rawValue: Swift.String)
    @available(iOS 2.0, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var screenType: UIKit.UIDevice.ScreenType {
    get
  }
}
extension UIKit.UIScreen {
  @_Concurrency.MainActor @preconcurrency public var screenSizeBasedOnOrientaion: CoreFoundation.CGSize {
    get
  }
}
@_Concurrency.MainActor @preconcurrency public struct LottieSwitch {
  @_Concurrency.MainActor @preconcurrency public init(animation: LensCustomerSDK.LottieAnimation?)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure(_ configure: @escaping (LensCustomerSDK.AnimatedSwitch) -> Swift.Void) -> LensCustomerSDK.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func configuration(_ configuration: LensCustomerSDK.LottieConfiguration) -> LensCustomerSDK.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func isOn(_ binding: SwiftUICore.Binding<Swift.Bool>) -> LensCustomerSDK.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func onAnimation(fromProgress onStartProgress: LensCustomerSDK.AnimationProgressTime, toProgress onEndProgress: LensCustomerSDK.AnimationProgressTime) -> LensCustomerSDK.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func offAnimation(fromProgress offStartProgress: LensCustomerSDK.AnimationProgressTime, toProgress offEndProgress: LensCustomerSDK.AnimationProgressTime) -> LensCustomerSDK.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func valueProvider<ValueProvider>(_ valueProvider: ValueProvider, for keypath: LensCustomerSDK.AnimationKeypath) -> LensCustomerSDK.LottieSwitch where ValueProvider : LensCustomerSDK.AnyValueProvider, ValueProvider : Swift.Equatable
  public typealias Body = @_opaqueReturnTypeOf("$s15LensCustomerSDK12LottieSwitchV4bodyQrvp", 0) __
}
extension LensCustomerSDK.DotLottieFile {
  public enum SynchronouslyBlockingCurrentThread {
    public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache) -> Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>
    public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache) -> Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>
    public static func loadedFrom(data: Foundation.Data, filename: Swift.String) -> Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>
  }
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> LensCustomerSDK.DotLottieFile
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> LensCustomerSDK.DotLottieFile
  public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func asset(named name: Swift.String, bundle: Foundation.Bundle = Bundle.main, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> LensCustomerSDK.DotLottieFile
  public static func asset(named name: Swift.String, bundle: Foundation.Bundle = Bundle.main, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> LensCustomerSDK.DotLottieFile
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, handleResult: @escaping (Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func loadedFrom(data: Foundation.Data, filename: Swift.String, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<LensCustomerSDK.DotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func loadedFrom(data: Foundation.Data, filename: Swift.String, dispatchQueue: Dispatch.DispatchQueue = .dotLottie) async throws -> LensCustomerSDK.DotLottieFile
}
extension Dispatch.DispatchQueue {
  public static let dotLottie: Dispatch.DispatchQueue
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedButton : LensCustomerSDK.AnimatedControl {
  @_Concurrency.MainActor @preconcurrency override public init(animation: LensCustomerSDK.LottieAnimation?, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency public var performAction: (() -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public func setPlayRange(fromProgress: LensCustomerSDK.AnimationProgressTime, toProgress: LensCustomerSDK.AnimationProgressTime, event: LensCustomerSDK.LottieControlEvent)
  @_Concurrency.MainActor @preconcurrency public func setPlayRange(fromMarker fromName: Swift.String, toMarker toName: Swift.String, event: LensCustomerSDK.LottieControlEvent)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
public protocol AssistChatParticipant {
  var displayName: Foundation.NSAttributedString { get }
  var uniqueId: Swift.String { get }
}
@available(iOSApplicationExtension, unavailable)
public protocol AssistChatProtocol {
  var chatText: Foundation.NSAttributedString { get }
  var chatTime: Foundation.Date { get }
  var chatParticipant: any LensCustomerSDK.AssistChatParticipant { get }
}
@available(iOSApplicationExtension, unavailable)
public struct OtherChatActivity {
  public let activityString: Foundation.NSAttributedString
  public let date: Foundation.Date
  public var color: UIKit.UIColor?
  public init(activity: Foundation.NSAttributedString, date: Foundation.Date, color: UIKit.UIColor? = nil)
}
@available(iOSApplicationExtension, unavailable)
public enum AssistChatActivityType {
  case chatSent(chat: any LensCustomerSDK.AssistChatProtocol), chatRecieved(chat: any LensCustomerSDK.AssistChatProtocol), otherActivity(otherActivity: LensCustomerSDK.OtherChatActivity)
}
@objc @available(iOSApplicationExtension, unavailable)
public class AssistChatActivity : ObjectiveC.NSObject {
  public var showNameDateTime: Swift.Bool
  public var activityTime: Foundation.Date {
    get
  }
  public var activityType: LensCustomerSDK.AssistChatActivityType
  public init(activity: LensCustomerSDK.AssistChatActivityType)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
public enum AssistChatResponse<AnyTpe> {
  case success(value: AnyTpe), failure(message: Swift.String)
}
@available(iOSApplicationExtension, unavailable)
public protocol AssistChatControllerDelegate : AnyObject {
  func assistChatController(send message: Swift.String, completion: @escaping ((LensCustomerSDK.AssistChatResponse<any LensCustomerSDK.AssistChatProtocol>) -> ()))
  func assistChatController(configureSendButton: UIKit.UIButton)
  func assistChatController(placeHolderTextFor: UIKit.UITextView) -> Swift.String?
  func assistChatController(needTitle for: LensCustomerSDK.AssistChatController) -> Swift.String?
  func assistChatController(noDataView for: LensCustomerSDK.AssistChatController) -> UIKit.UIView?
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency open class AssistChatController : LensCustomerSDK.DrawerChildTableViewController, LensCustomerSDK.KeyboardNotificationhandler, LensCustomerSDK.OrientationHandler {
  @_Concurrency.MainActor @preconcurrency public static var assistChatTheme: LensCustomerSDK.AssistChatTheme
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak open var tableView: UIKit.UITableView!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var sendButton: UIKit.UIButton!
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any LensCustomerSDK.AssistChatControllerDelegate)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency required convenience public init(delegate: (any LensCustomerSDK.AssistChatControllerDelegate)?, chatMode: Swift.Bool? = true)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func removeFromParent()
  @_Concurrency.MainActor @preconcurrency open func setChatComponents(hidden: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency open func resetData()
  @_Concurrency.MainActor @preconcurrency public func handleNoData()
  @_Concurrency.MainActor @preconcurrency override open func drawerView(for drawer: LensCustomerSDK.DrawerViewController) -> UIKit.UIView
  @_Concurrency.MainActor @preconcurrency override open func drawer(movingPosition: LensCustomerSDK.DrawerMovingPosition, drawerChangedHeight height: CoreFoundation.CGFloat, drawerMinHeight: CoreFoundation.CGFloat, drawerMaximumHeight: CoreFoundation.CGFloat, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency override open func drawer(_ drawer: LensCustomerSDK.DrawerViewController, reachedMinHeight height: CoreFoundation.CGFloat, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency override open func drawer(_ drawer: LensCustomerSDK.DrawerViewController, reachedMaximumHeight height: CoreFoundation.CGFloat, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency open func send(chat: any LensCustomerSDK.AssistChatProtocol)
  @_Concurrency.MainActor @preconcurrency open func received(chat: any LensCustomerSDK.AssistChatProtocol)
  @_Concurrency.MainActor @preconcurrency open func registerOther(chatActivity: LensCustomerSDK.OtherChatActivity)
  @_Concurrency.MainActor @preconcurrency public func scrollToEnd()
  @_Concurrency.MainActor @preconcurrency override open func drawerWidth(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
public struct AssistChatTheme {
  public var sentChatCellTheme: LensCustomerSDK.AssistChatCellTheme
  public var recievedChatCellTheme: LensCustomerSDK.AssistChatCellTheme
  public var textFieldTheme: LensCustomerSDK.AssistChatTextFieldTheme
  public init(sentCellTheme: LensCustomerSDK.AssistChatCellTheme = AssistChatCellTheme.defaultSentCellTheme, recievedCellTheme: LensCustomerSDK.AssistChatCellTheme = AssistChatCellTheme.defaultRecievedCellTheme, textFieldTheme: LensCustomerSDK.AssistChatTextFieldTheme = AssistChatTextFieldTheme.defaultTextFieldTheme)
}
@available(iOSApplicationExtension, unavailable)
public struct AssistChatCellTheme {
  public var nameColor: UIKit.UIColor
  public var dateColor: UIKit.UIColor
  public var chatTextColor: UIKit.UIColor
  public var chatBackgroundColor: UIKit.UIColor
  public init(nameColor: UIKit.UIColor, dateColor: UIKit.UIColor, chatTextColor: UIKit.UIColor, chatBackgroundColor: UIKit.UIColor)
  public static var defaultSentCellTheme: LensCustomerSDK.AssistChatCellTheme {
    get
  }
  public static var defaultRecievedCellTheme: LensCustomerSDK.AssistChatCellTheme {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
public struct AssistChatTextFieldTheme {
  public init(textFieldBorderColor: UIKit.UIColor, textColor: UIKit.UIColor, placeHolder: UIKit.UIColor, textFieldBackgroundColor: UIKit.UIColor)
  public init()
  public static var defaultTextFieldTheme: LensCustomerSDK.AssistChatTextFieldTheme {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
public struct AssistChatNavigationBarTheme {
  public var navBarBackgroundColor: UIKit.UIColor?
  public var navBarTitleColor: UIKit.UIColor?
  public init(navigationBarBackgroundColor: UIKit.UIColor? = nil, navigationTitleColor: UIKit.UIColor? = nil)
}
@available(iOSApplicationExtension, unavailable)
public struct AssistChatControl {
  public var pause: UIKit.UIImage?
  public var resume: UIKit.UIImage?
  public var sendChat: UIKit.UIImage?
  public var exitSession: UIKit.UIImage?
  public var technician: UIKit.UIImage?
  public var iconTintColor: UIKit.UIColor?
  public init(pause: UIKit.UIImage? = nil, resume: UIKit.UIImage? = nil, sendChat: UIKit.UIImage? = nil, exitSession: UIKit.UIImage? = nil, technician: UIKit.UIImage? = nil, iconTintColor: UIKit.UIColor? = nil)
}
public enum AssistSocketErrorState : Swift.Error {
  case nointernet, writeTimeoutError, invalidSSLError, compressionError, outputStreamWriteError, protocolError, upgradeError, closeError, connectionTimeOut
  public static func == (a: LensCustomerSDK.AssistSocketErrorState, b: LensCustomerSDK.AssistSocketErrorState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class DisposableObserver : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.DisposableObserver, rhs: LensCustomerSDK.DisposableObserver) -> Swift.Bool
  public init(value: Swift.AnyObject)
  @objc deinit
}
public protocol DotLottieCacheProvider : Swift.Sendable {
  func file(forKey: Swift.String) -> LensCustomerSDK.DotLottieFile?
  func setFile(_ lottie: LensCustomerSDK.DotLottieFile, forKey: Swift.String)
  func clearCache()
}
extension UIKit.UISearchBar {
  @_Concurrency.MainActor @preconcurrency public var at_searchTextField: UIKit.UITextField? {
    get
  }
}
public class VMResponseSerialization {
  public var responseType: LensCustomerSDK.VMResponseType
  public init()
  @objc deinit
}
public struct LottieConfiguration : Swift.Hashable {
  public init(renderingEngine: LensCustomerSDK.RenderingEngineOption = .automatic, decodingStrategy: LensCustomerSDK.DecodingStrategy = .dictionaryBased, colorSpace: CoreGraphics.CGColorSpace = CGColorSpaceCreateDeviceRGB(), reducedMotionOption: LensCustomerSDK.ReducedMotionOption = .systemReducedMotionToggle)
  public static var shared: LensCustomerSDK.LottieConfiguration
  public var renderingEngine: LensCustomerSDK.RenderingEngineOption
  public var decodingStrategy: LensCustomerSDK.DecodingStrategy
  public var reducedMotionOption: LensCustomerSDK.ReducedMotionOption
  public var colorSpace: CoreGraphics.CGColorSpace
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.LottieConfiguration, b: LensCustomerSDK.LottieConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class AnimationSubview : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public enum LottieAnimationCache {
  public static var shared: (any LensCustomerSDK.AnimationCacheProvider)?
}
public enum LottieAnimationSource : Swift.Sendable {
  case lottieAnimation(LensCustomerSDK.LottieAnimation)
  case dotLottieFile(LensCustomerSDK.DotLottieFile)
}
extension LensCustomerSDK.LottieAnimation {
  final public var animationSource: LensCustomerSDK.LottieAnimationSource {
    get
  }
}
extension LensCustomerSDK.DotLottieFile {
  final public var animationSource: LensCustomerSDK.LottieAnimationSource {
    get
  }
}
public class DefaultAnimationCache : LensCustomerSDK.AnimationCacheProvider {
  public init()
  public static let sharedCache: LensCustomerSDK.DefaultAnimationCache
  public var cacheSize: Swift.Int {
    get
    set
  }
  public func clearCache()
  public func animation(forKey key: Swift.String) -> LensCustomerSDK.LottieAnimation?
  public func setAnimation(_ animation: LensCustomerSDK.LottieAnimation, forKey key: Swift.String)
  @objc deinit
}
extension LensCustomerSDK.DefaultAnimationCache : @unchecked Swift.Sendable {
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class NotificationView : UIKit.UIView {
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var messageLabel: UIKit.UILabel!
  @_Concurrency.MainActor @preconcurrency public static func getNotificationView() -> LensCustomerSDK.NotificationView?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency public func show()
  @_Concurrency.MainActor @preconcurrency public func dismiss(completion: (() -> ())? = nil)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UIView {
  public enum NotificationBannerStyle {
    case banner
    case toast
    public static func == (a: UIKit.UIView.NotificationBannerStyle, b: UIKit.UIView.NotificationBannerStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public func showNotificationInWindow(message: Swift.String, bgColor: UIKit.UIColor? = nil, textColor: UIKit.UIColor? = nil, show duration: Foundation.TimeInterval = 4, style: UIKit.UIView.NotificationBannerStyle = .banner, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func showNotificationBanner(message: Swift.String, bgColor: UIKit.UIColor? = nil, textColor: UIKit.UIColor? = nil, show duration: Foundation.TimeInterval = 4, style: UIKit.UIView.NotificationBannerStyle = .banner, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func dismissNotificationView()
}
extension LensCustomerSDK.LottieType {
  public static var ALL_LOTTIE_ANIMATION_VIEW_TAG: Swift.Int {
    get
  }
  public func getLottie(withName: Swift.String, bundle: Foundation.Bundle) -> LensCustomerSDK.LottieAnimationView
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class LottieMessageView : UIKit.UIView {
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var lottieContainer: UIKit.UIView!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var lottieContainerHeight: UIKit.NSLayoutConstraint!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var lottieContainerWidth: UIKit.NSLayoutConstraint!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var messageLabel: UIKit.UILabel!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var actionButton: UIKit.UIButton!
  @_Concurrency.MainActor @preconcurrency public var lottie: LensCustomerSDK.LottieAnimationView? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public static func instance(lottieType: any LensCustomerSDK.LottieType, messageLabelConfig: ((UIKit.UILabel) -> Swift.Void)? = nil, customView: UIKit.UIView? = nil, actionButtonConfiguration: ((UIKit.UIButton) -> (() -> Swift.Void)?)? = nil) -> LensCustomerSDK.LottieMessageView
  @_Concurrency.MainActor @preconcurrency public static func instance(with lottieType: any LensCustomerSDK.LottieType, withCustomMessage message: Swift.String? = nil, lineCount: Swift.Int? = -1, customView: UIKit.UIView? = nil, actionButtonConfiguration: ((UIKit.UIButton) -> (() -> Swift.Void)?)? = nil) -> LensCustomerSDK.LottieMessageView
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func awakeFromNib()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
final public class GradientValueProvider {
  public init(block: @escaping LensCustomerSDK.GradientValueProvider.ColorsValueBlock, locations: LensCustomerSDK.GradientValueProvider.ColorLocationsBlock? = nil)
  public init(_ colors: [LensCustomerSDK.LottieColor], locations: [Swift.Double] = [])
  public typealias ColorsValueBlock = (CoreFoundation.CGFloat) -> [LensCustomerSDK.LottieColor]
  public typealias ColorLocationsBlock = (CoreFoundation.CGFloat) -> [Swift.Double]
  final public var colors: [LensCustomerSDK.LottieColor] {
    get
    set
  }
  final public var locations: [Swift.Double] {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: LensCustomerSDK.ValueProviderStorage<[Swift.Double]> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.GradientValueProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.GradientValueProvider, rhs: LensCustomerSDK.GradientValueProvider) -> Swift.Bool
}
extension UIKit.UIColor {
  convenience public init(red: Swift.Int, green: Swift.Int, blue: Swift.Int)
  convenience public init(rgb: Swift.Int)
  public class func color(dark: UIKit.UIColor, light: UIKit.UIColor) -> UIKit.UIColor
}
public enum DecodingStrategy : Swift.Hashable {
  case legacyCodable
  case dictionaryBased
  public static func == (a: LensCustomerSDK.DecodingStrategy, b: LensCustomerSDK.DecodingStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.String {
  public var isEmailID: Swift.Bool {
    get
  }
  public var intValue: Swift.Int {
    get
  }
  public var floatValue: CoreFoundation.CGFloat {
    get
  }
  public func subString(fromIndex: Swift.Int) -> Swift.String
  public func subString(toIndex: Swift.Int) -> Swift.String
  public static func < (lhs: Swift.String, rhs: Swift.Int) -> Swift.String
  public func copyInClipboard()
  public var utf8Data: Foundation.Data? {
    get
  }
  public var isoLatin1Data: Foundation.Data? {
    get
  }
  public var asciiData: Foundation.Data? {
    get
  }
  public func data(encode: Swift.String.Encoding) -> Foundation.Data?
  public var splitByNewLine: [Swift.String] {
    get
  }
  public var splitBySpace: [Swift.String] {
    get
  }
}
extension UIKit.UIBarButtonItem {
  @_Concurrency.MainActor @preconcurrency public var frame: CoreFoundation.CGRect {
    get
  }
}
public enum ContentType : Swift.String {
  case jsonType, formType
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class VMRequestSerialization {
  public typealias HTTPField = Swift.String
  public var timeOutInterval: Foundation.TimeInterval
  public var HTTPHeaders: [Swift.String : Swift.String?]
  public var contentType: Swift.String {
    get
    set(newValue)
  }
  public init(timeOutInterval: Foundation.TimeInterval = 60)
  public func setValue(_ value: Swift.String?, forHTTPField: Swift.String)
  public func value(_ forHTTPField: Swift.String) -> Swift.String?
  public func setValues(_ values: [LensCustomerSDK.VMRequestSerialization.HTTPField : Swift.String])
  public func addValue(_ value: Swift.String, forHTTPField key: Swift.String)
  public func addValues(_ values: [Swift.String], forHttpField key: Swift.String)
  @objc deinit
}
extension Foundation.Data {
  public func write(fileName: Swift.String, appendIntermediateDir path: Swift.String? = nil) throws -> Foundation.URL?
  public var mbSize: CoreFoundation.CGFloat {
    get
  }
  public var sizeWithUnit: Swift.String {
    get
  }
}
public protocol AnimationImageProvider {
  var cacheEligible: Swift.Bool { get }
  func imageForAsset(asset: LensCustomerSDK.ImageAsset) -> CoreGraphics.CGImage?
  func contentsGravity(for asset: LensCustomerSDK.ImageAsset) -> QuartzCore.CALayerContentsGravity
}
extension LensCustomerSDK.AnimationImageProvider {
  public var cacheEligible: Swift.Bool {
    get
  }
  public func contentsGravity(for _: LensCustomerSDK.ImageAsset) -> QuartzCore.CALayerContentsGravity
}
public enum DotLottieError : Swift.Error {
  case noDataLoaded
  case assetNotFound(name: Swift.String, bundle: Foundation.Bundle?)
  case loadingFromAssetNotSupported
  @available(*, deprecated, message: "Unused")
  case invalidFileFormat
  @available(*, deprecated, message: "Unused")
  case invalidData
  @available(*, deprecated, message: "Unused")
  case animationNotAvailable
}
final public class PointValueProvider {
  public init(block: @escaping LensCustomerSDK.PointValueProvider.PointValueBlock)
  public init(_ point: CoreFoundation.CGPoint)
  public typealias PointValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  final public var point: CoreFoundation.CGPoint {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: LensCustomerSDK.ValueProviderStorage<LensCustomerSDK.LottieVector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.PointValueProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.PointValueProvider, rhs: LensCustomerSDK.PointValueProvider) -> Swift.Bool
}
final public class Keyframe<T> {
  public init(_ value: T, spatialInTangent: LensCustomerSDK.LottieVector3D? = nil, spatialOutTangent: LensCustomerSDK.LottieVector3D? = nil)
  public init(value: T, time: LensCustomerSDK.AnimationFrameTime, isHold: Swift.Bool = false, inTangent: LensCustomerSDK.LottieVector2D? = nil, outTangent: LensCustomerSDK.LottieVector2D? = nil, spatialInTangent: LensCustomerSDK.LottieVector3D? = nil, spatialOutTangent: LensCustomerSDK.LottieVector3D? = nil)
  final public let value: T
  final public let time: LensCustomerSDK.AnimationFrameTime
  final public let isHold: Swift.Bool
  final public let inTangent: LensCustomerSDK.LottieVector2D?
  final public let outTangent: LensCustomerSDK.LottieVector2D?
  final public let spatialInTangent: LensCustomerSDK.LottieVector3D?
  final public let spatialOutTangent: LensCustomerSDK.LottieVector3D?
  @objc deinit
}
extension LensCustomerSDK.Keyframe : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.Keyframe<T>, rhs: LensCustomerSDK.Keyframe<T>) -> Swift.Bool
}
extension LensCustomerSDK.Keyframe : Swift.Hashable where T : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension LensCustomerSDK.Keyframe : Swift.Sendable where T : Swift.Sendable {
}
extension UIKit.UIPopoverArrowDirection {
  public func defaultSourceRect(from view: UIKit.UIView) -> CoreFoundation.CGRect?
  public var isVerticalDirection: Swift.Bool {
    get
  }
}
extension UIKit.UIViewController {
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func openShareSheet(_ data: [Any], popFromView view: UIKit.UIView, completionHandler completionBlock: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func openShareSheet(_ data: [Any], popFromView barbutton: UIKit.UIBarButtonItem, completionHandler completionBlock: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func prepareAsPopoverController(from view: UIKit.UIView, soruceRect: CoreFoundation.CGRect?, preferedSize contentSize: CoreFoundation.CGSize = .zero, permittedArrowDirections directions: UIKit.UIPopoverArrowDirection = .down)
  @_Concurrency.MainActor @preconcurrency public func prepareAsPopoverController(from barButton: UIKit.UIBarButtonItem, soruceRect: CoreFoundation.CGRect?, preferedSize contentSize: CoreFoundation.CGSize = .zero, permittedArrowDirections directions: UIKit.UIPopoverArrowDirection = .down)
  @_Concurrency.MainActor @preconcurrency public func dismissPopoverIfExist()
}
extension UIKit.UIViewController : UIKit.UIPopoverPresentationControllerDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic open func popoverPresentationController(_ popoverPresentationController: UIKit.UIPopoverPresentationController, willRepositionPopoverTo rect: Swift.UnsafeMutablePointer<CoreFoundation.CGRect>, in view: Swift.AutoreleasingUnsafeMutablePointer<UIKit.UIView>)
  @_Concurrency.MainActor @preconcurrency @objc dynamic open func prepareForPopoverPresentation(_ popoverPresentationController: UIKit.UIPopoverPresentationController)
  @_Concurrency.MainActor @preconcurrency @objc dynamic open func popoverPresentationControllerDidDismissPopover(_ popoverPresentationController: UIKit.UIPopoverPresentationController)
}
extension Swift.Int {
  public var cgfloat: CoreFoundation.CGFloat {
    get
  }
}
public protocol CommonIntUtility {
  var isNegative: Swift.Bool { get }
  var isZero: Swift.Bool { get }
  var string: Swift.String { get }
}
extension LensCustomerSDK.CommonIntUtility where Self : Swift.SignedInteger {
  public var string: Swift.String {
    get
  }
  public func string(maximumNumber: Swift.Int) -> Swift.String
  public var isNegative: Swift.Bool {
    get
  }
  public var isZero: Swift.Bool {
    get
  }
  public var convertFileSizeWithUnit: Swift.String {
    get
  }
  public var fileSizeWithUnit: Swift.String {
    get
  }
}
extension Swift.Int : LensCustomerSDK.CommonIntUtility {
}
extension Swift.Int32 : LensCustomerSDK.CommonIntUtility {
}
extension Swift.Int64 : LensCustomerSDK.CommonIntUtility {
}
extension Swift.Int16 : LensCustomerSDK.CommonIntUtility {
}
infix operator +| : DefaultPrecedence
infix operator +- : DefaultPrecedence
final public class FloatValueProvider {
  public init(block: @escaping LensCustomerSDK.FloatValueProvider.CGFloatValueBlock)
  public init(_ float: CoreFoundation.CGFloat)
  public typealias CGFloatValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var float: CoreFoundation.CGFloat {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: LensCustomerSDK.ValueProviderStorage<LensCustomerSDK.LottieVector1D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.FloatValueProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.FloatValueProvider, rhs: LensCustomerSDK.FloatValueProvider) -> Swift.Bool
}
public protocol NotesViewDelegate : AnyObject {
  func getNotes(completion: @escaping ((LensCustomerSDK.Notes?) -> Swift.Void))
  func updateNotes(noteTitle: Swift.String, notes: Swift.String)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class NotesViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any LensCustomerSDK.NotesViewDelegate)?
  @_Concurrency.MainActor @preconcurrency public static func getNotesController() -> LensCustomerSDK.NotesViewController
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func showToast(message: Swift.String, show duration: Foundation.TimeInterval = 3, dismissOnTap: Swift.Bool = true, lottie type: (any LensCustomerSDK.LottieType)? = nil, onTap: ((LensCustomerSDK.Toast) -> Swift.Void)? = nil, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func dismissToastView()
  @_Concurrency.MainActor @preconcurrency public func makeCircular()
}
public struct FloatingMenuItem : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.FloatingMenuItem, rhs: LensCustomerSDK.FloatingMenuItem) -> Swift.Bool
  public var id: Swift.String
  public var icon: (any LensCustomerSDK.ATIcon)?
  public var isSelectionNeeded: Swift.Bool
  public var handler: ((_ menuItem: LensCustomerSDK.FloatingMenuItem, _ isSelected: Swift.Bool) -> ())?
  public var iconSize: CoreFoundation.CGFloat?
  public init(id: Swift.String, icon: (any LensCustomerSDK.ATIcon)?, handler: ((_ menuItem: LensCustomerSDK.FloatingMenuItem, _ isSelected: Swift.Bool) -> ())?)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class FloatingMenu : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var collapseIcon: (any LensCustomerSDK.ATIcon)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var revielIcon: (any LensCustomerSDK.ATIcon)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var floatingMenuToggleButton: UIKit.UIButton?
  @_Concurrency.MainActor @preconcurrency public var floatingMenuItems: [LensCustomerSDK.FloatingMenuItem]
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var isHidden: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public init(collapse cicon: any LensCustomerSDK.ATIcon, reviel ricon: any LensCustomerSDK.ATIcon)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class ATCopyLabel : UIKit.UILabel {
  @_Concurrency.MainActor @preconcurrency public var copyClipBoardCompletion: ((Swift.String) -> Swift.String)?
  @_Concurrency.MainActor @preconcurrency public var isCopyToClipBoardEnabled: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct FreezeData {
  public let freezeImage: UIKit.UIImage
  public var id: Swift.Int
}
@_hasMissingDesignatedInitializers public class FreezeHandler : LensCustomerSDK.FreezeProtocol {
  public func onFreezeCancelled(id: Swift.String)
  public func onFreezeCompleted(id: Swift.String)
  public func onFreezeStart(id: Swift.String)
  public func progress(id: Swift.String, sendBytes: Swift.Int, totalBytes: Swift.Int)
  public func liveStreamingPaused(_ freezeBy: LensCustomerSDK.FreezeCurrentStatus.FreezeBy)
  public func onUnfreezed(_ unFreezeBy: LensCustomerSDK.FreezeCurrentStatus.FreezeBy)
  public func freezeConfiguration(status: LensCustomerSDK.RecodingStatus?)
  @objc deinit
}
extension LensCustomerSDK.LensSessionController : LensCustomerSDK.NotesViewDelegate {
  @_Concurrency.MainActor @preconcurrency public func getNotes(completion: @escaping ((LensCustomerSDK.Notes?) -> Swift.Void))
  @_Concurrency.MainActor @preconcurrency public func updateNotes(noteTitle: Swift.String, notes: Swift.String)
}
public protocol SnapShotViewDelegate : AnyObject {
  func snapShotClick(completion: @escaping (_ snapshot: any LensCustomerSDK.SnapShotObject) -> Swift.Void)
  func downloadSnapShot(_ snapShots: [any LensCustomerSDK.SnapShotObject]?, sender: UIKit.UIButton, completion: @escaping (_ isDownloadSuccess: Swift.Bool) -> Swift.Void)
  func freeze(snapShot: any LensCustomerSDK.SnapShotObject, completion: @escaping (_ isFreezeSuccess: Swift.Bool) -> Swift.Void)
  func unfreezeSnapShot(completion: @escaping (_ isUnfreezeSuccess: Swift.Bool) -> Swift.Void)
  func deleteSnapShot(_ snapshots: [any LensCustomerSDK.SnapShotObject], completion: @escaping (_ isDownloadSuccess: Swift.Bool) -> Swift.Void)
  func newsnapShotFreeze(fileId: Swift.String, image: UIKit.UIImage)
  func newsnapShotUnFreeze()
  func alertForFreezeSnapshot()
}
@objc @_Concurrency.MainActor @preconcurrency public class SnapShotView : UIKit.UIView, LensCustomerSDK.ViewResuable {
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any LensCustomerSDK.SnapShotViewDelegate)?
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @available(iOS 14, *)
@_Concurrency.MainActor @preconcurrency public class ZLInviteTechnicianController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency public var technicianInviteCallBack: ((_ external: Swift.Bool, _ Email: Swift.String) -> ())?
  @_Concurrency.MainActor @preconcurrency public init(techJoinUrl: Foundation.URL?, sessionKey: Swift.String)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @objc deinit
}
@available(iOS 14, *)
extension LensCustomerSDK.ZLInviteTechnicianController : LensCustomerSDK.OrientationHandler {
  @_Concurrency.MainActor @preconcurrency public func supportedOrientation() -> LensCustomerSDK.At_Orientation
}
extension LensCustomerSDK.LensSessionController : LensCustomerSDK.SnapShotViewDelegate {
  @_Concurrency.MainActor @preconcurrency public func snapShotClick(completion: @escaping (any LensCustomerSDK.SnapShotObject) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public func deleteSnapShot(_ snapshots: [any LensCustomerSDK.SnapShotObject], completion: @escaping (Swift.Bool) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public func freeze(snapShot: any LensCustomerSDK.SnapShotObject, completion: @escaping (Swift.Bool) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public func downloadSnapShot(_ snapShots: [any LensCustomerSDK.SnapShotObject]?, sender: UIKit.UIButton, completion: @escaping (Swift.Bool) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public func unfreezeSnapShot(completion: @escaping (Swift.Bool) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public func addSnapShotUI()
  @_Concurrency.MainActor @preconcurrency public func hideSnapShotUI(flag: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func newsnapShotFreeze(fileId: Swift.String, image: UIKit.UIImage)
  @_Concurrency.MainActor @preconcurrency public func newsnapShotUnFreeze()
  @_Concurrency.MainActor @preconcurrency public func alertForFreezeSnapshot()
}
public protocol SnapShotObject {
  var snapShotId: Swift.String { get }
  var snapShotImage: UIKit.UIImage { get }
}
extension LensCustomerSDK.Chat : LensCustomerSDK.AssistChatProtocol {
  public var chatText: Foundation.NSAttributedString {
    get
  }
  public var chatTime: Foundation.Date {
    get
  }
  public var chatParticipant: any LensCustomerSDK.AssistChatParticipant {
    get
  }
}
extension LensCustomerSDK.Chat : LensCustomerSDK.AssistChatParticipant {
  public var displayName: Foundation.NSAttributedString {
    get
  }
  public var uniqueId: Swift.String {
    get
  }
}
extension LensCustomerSDK.Participant : LensCustomerSDK.AssistChatParticipant {
  public var displayName: Foundation.NSAttributedString {
    get
  }
  public var uniqueId: Swift.String {
    get
  }
}
extension Foundation.URLResponse : Swift.Error {
}
public class APIResponseManger {
  public init(_ delegate: any LensCustomerSDK.LensUICommonDelegates, networkingDelegate: (any LensCustomerSDK.LensSessionNetworkProtocol)?, eventProtocol: (any LensCustomerSDK.LensEventProtocol)?)
  public func updateNotes(title: Swift.String?, note: Swift.String?, sys_client_id: Swift.String, sessionToken: Swift.String, clientToken: Swift.String)
  public func fetchNotes(sys_client_id: Swift.String, sessionToken: Swift.String, clientToken: Swift.String, completion: @escaping ((LensCustomerSDK.Notes?) -> Swift.Void))
  public func deleteScreenshot(fileId: [Swift.Int], sessionToken: Swift.String, clientToken: Swift.String, completion: @escaping (Swift.Bool) -> Swift.Void)
  public func deleteAllScreenshot(sys_id: Swift.String, sessionToken: Swift.String, clientToken: Swift.String, completion: @escaping (Swift.Bool) -> Swift.Void)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class WaitingRoomViewController : UIKit.UIViewController, LensCustomerSDK.ControllerReusable {
  @_Concurrency.MainActor @preconcurrency public static var at_storyBoardId: Swift.String
  @_Concurrency.MainActor @preconcurrency public static var at_storyBoard: UIKit.UIStoryboard
  @_Concurrency.MainActor @preconcurrency public static func waitingVC() -> LensCustomerSDK.WaitingRoomViewController?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didReceiveMemoryWarning()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public struct Notes : Swift.Codable {
  public var notes: Swift.String?
  public var context_title: Swift.String?
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case notes
    case file_name
    case notes_last_edit_time
    case notes_added_time
    case notes_owner_name
    case notes_edited_user_name
    case notes_owner_email
    case notes_edited_user_email
    case context_identity
    case context_title
    case context_edited_time
    case context_added_time
    case department_id
    case context_owner_name
    case context_edited_user_name
    case context_owner_email
    case context_edited_user_email
    case notes_edit_permission
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct SnapShotEntity : LensCustomerSDK.SnapShotObject {
  public let uploadID: Swift.String
  public var snapShotId: Swift.String {
    get
  }
  public var snapShotImage: UIKit.UIImage {
    get
  }
}
public struct SessionDescription {
  public var sessionID: Swift.String
  public var sys_id: Swift.String?
  public var startDate: Foundation.Date?
  public var endDate: Foundation.Date?
  public var duration: Foundation.TimeInterval? {
    get
  }
  public let sessionToken: Swift.String
  public let clientToken: Swift.String
  public var participantsParticipant: LensCustomerSDK.Participant?
}
extension Swift.String {
  public func encodeURLString() -> Swift.String
  public func decodeUrl() -> Swift.String?
  public func isValidEmailID() -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class LensChatController : LensCustomerSDK.AssistChatController {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency override open func drawerView(for drawer: LensCustomerSDK.DrawerViewController) -> UIKit.UIView
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension LensCustomerSDK.LensChatController : LensCustomerSDK.AssistChatControllerDelegate {
  @_Concurrency.MainActor @preconcurrency public func assistChatController(send message: Swift.String, completion: @escaping ((LensCustomerSDK.AssistChatResponse<any LensCustomerSDK.AssistChatProtocol>) -> ()))
  @_Concurrency.MainActor @preconcurrency public func assistChatController(configureExitButton: UIKit.UIButton) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func assistChatController(configureSendButton: UIKit.UIButton)
  @_Concurrency.MainActor @preconcurrency public func assistChatController(placeHolderTextFor: UIKit.UITextView) -> Swift.String?
  @_Concurrency.MainActor @preconcurrency public func assistChatController(needTitle for: LensCustomerSDK.AssistChatController) -> Swift.String?
  @_Concurrency.MainActor @preconcurrency public func assistChatController(noDataView for: LensCustomerSDK.AssistChatController) -> UIKit.UIView?
}
@_hasMissingDesignatedInitializers public class LensTechnician : LensCustomerSDK.Lens {
  weak public var freezeProtocol: (any LensCustomerSDK.FreezeProtocol)?
  weak public var actionProtocol: (any LensCustomerSDK.OtherActionsProtocol)?
  weak public var otherTechnicianAction: (any LensCustomerSDK.OtherTechnicianAction)?
  weak public var technicianCommonProtocol: (any LensCustomerSDK.TechnicianCommonProtocol)?
  final public let currentUserZuid: Swift.String
  public var recording_status: LensCustomerSDK.RecodingStatus? {
    get
  }
  public var recording_control_mode: LensCustomerSDK.RecordingControlMode? {
    get
  }
  public var technicianConnectionParam: any LensCustomerSDK.TechnicianSessionParams {
    get
  }
  public init(connectionParam: any LensCustomerSDK.TechnicianSessionParams, name: Swift.String, email: Swift.String, zuid: Swift.String)
  public static func validateSession(sessionKey key: Swift.String?, digest: Swift.String?, is_scheduled: Swift.Bool, role: LensCustomerSDK.RoleEnum, networkDelegate: (any LensCustomerSDK.LensSessionNetworkProtocol)?, completion: @escaping (LensCustomerSDK.SessionValidationResponse) -> Swift.Void)
  public func startSession()
  public func screenShot() -> LensCustomerSDK.FreezeData?
  public func isInSessionRecording() -> Swift.Bool
  public func startInSessionRecording()
  public func stopInSessionRecording()
  @discardableResult
  public func freeze() -> Swift.Bool
  public func set(freeze buffer: LensCustomerSDK.FreezeData) -> Swift.Bool
  public func unfreeze() -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.LensTechnician {
  @discardableResult
  public func muteAudio() -> Swift.Bool?
  @discardableResult
  public func unmuteAudio() -> Swift.Bool?
  @discardableResult
  public func exitSession() -> Swift.Bool
}
extension LensCustomerSDK.LensTechnician {
  public func getSnapShotImage(fileDigestId: Swift.String, completion: @escaping ((UIKit.UIImage?) -> Swift.Void))
}
extension LensCustomerSDK.AssistMenu : LensCustomerSDK.SheetSelectionData {
  public var uniqueIdentifier: Swift.String {
    get
  }
  public var title: Swift.String {
    get
  }
}
extension LensCustomerSDK.LensSessionController : LensCustomerSDK.AudioSessionProtocol {
  @_Concurrency.MainActor @preconcurrency public func didChangeRoute(_ audioDescription: AVFAudio.AVAudioSessionRouteDescription, reason: AVFAudio.AVAudioSession.RouteChangeReason)
}
public protocol LensUICommonDelegates : AnyObject {
  func set(loader enabled: Swift.Bool, text: Swift.String?)
  func show(lottie type: LensCustomerSDK.LensLottieType, message: Swift.String)
  func dismissLottie()
  func showStatusBar(message: Swift.String, interval: Foundation.TimeInterval)
  func dismissWithError(message: Swift.String)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class LensSessionController : LensCustomerSDK.LensBaseSessionController, LensCustomerSDK.ControllerReusable {
  @_Concurrency.MainActor @preconcurrency public static var at_storyBoardId: Swift.String
  @_Concurrency.MainActor @preconcurrency public static var at_storyBoard: UIKit.UIStoryboard
  @_Concurrency.MainActor @preconcurrency public var networkDelegate: (any LensCustomerSDK.LensSessionNetworkProtocol)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency weak public var activityProtocol: (any LensCustomerSDK.LensEventProtocol)?
  @_Concurrency.MainActor @preconcurrency public var sessionTitle: Swift.String
  @_Concurrency.MainActor @preconcurrency public var isSessionHost: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var snapShotView: LensCustomerSDK.SnapShotView?
  @_Concurrency.MainActor @preconcurrency public var apiResponseManager: LensCustomerSDK.APIResponseManger? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var freezeManager: LensCustomerSDK.FreezeHandler? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var isARSupported: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency public static func getLensController(connection param: any LensCustomerSDK.TechnicianSessionParams, technician email: Swift.String, customer cutemail: Swift.String? = nil, techName: Swift.String, sys_id: Swift.String, isCxAlreadyInSession: Swift.Bool = false, isARMode: Swift.Bool, remoteConfigConferenceType: LensCustomerSDK.ConferenceType, zuid: Swift.String) -> LensCustomerSDK.LensSessionController?
  @_Concurrency.MainActor @preconcurrency override public func deviceRotated(_ currentOrientation: UIKit.UIDeviceOrientation)
  @_Concurrency.MainActor @preconcurrency public func alertForJoinAnotherTechSession()
  @_Concurrency.MainActor @preconcurrency public func selectedOption(option: LensCustomerSDK.AssistMenu)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension LensCustomerSDK.LensSessionController : LensCustomerSDK.LensUICommonDelegates {
  @_Concurrency.MainActor @preconcurrency public func showStatusBar(message: Swift.String, interval: Foundation.TimeInterval = 4)
  @_Concurrency.MainActor @preconcurrency public func dismissWithError(message: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func show(lottie type: LensCustomerSDK.LensLottieType, message: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func set(loader enabled: Swift.Bool, text: Swift.String?)
  @_Concurrency.MainActor @preconcurrency public func dismissLottie()
}
extension LensCustomerSDK.LensSessionController {
  @_Concurrency.MainActor @preconcurrency public func participantRejoined(clientId: Swift.String)
}
extension LensCustomerSDK.LensSessionController : LensCustomerSDK.TechnicianCommonProtocol {
  @_Concurrency.MainActor @preconcurrency public func seconderyTechWaitingForCustomerUIUpdate()
  @_Concurrency.MainActor @preconcurrency public func secondaryTechnicianApprovalRequest(email: Swift.String, clientId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func secondaryTechnicianApprovalResponse(isAccepted: Swift.Bool, email: Swift.String, clientId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func onReceiveShareCameraRequest(participant: LensCustomerSDK.Participant?)
  @_Concurrency.MainActor @preconcurrency public func onCameraSwitch(isFront: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func onSessionRecordResponseCompletion()
  @_Concurrency.MainActor @preconcurrency public func onShareCameraResponse(action: LensCustomerSDK.ShareCameraTechAction, participant: LensCustomerSDK.Participant?)
  @_Concurrency.MainActor @preconcurrency public func notifyUserWith(msg: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func refreshBottomMenu()
  @_Concurrency.MainActor @preconcurrency public func showLottieView(lottie: LensCustomerSDK.LensLottieType, show: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func showStatusBarNotifyBanner(msg: Swift.String, show: Foundation.TimeInterval)
  @_Concurrency.MainActor @preconcurrency public func onCustomerAction(action: LensCustomerSDK.CustomerAction)
}
extension LensCustomerSDK.LensSessionController {
  @_Concurrency.MainActor @preconcurrency public func endCurrentAppCallKit()
}
extension LensCustomerSDK.LensSessionController {
  @_Concurrency.MainActor @preconcurrency public func getCurrentState() -> [Swift.String : Any]
}
extension LensCustomerSDK.LensSessionController : LensCustomerSDK.ARProtocol {
  @_Concurrency.MainActor @preconcurrency public func onAnchorSelectionChanged(annotationId: Swift.String, state: LensCustomerSDK.AnnotationSelection, triggerId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func onAnchorRemoved(annotationId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func onAnchorPlaced(annotationId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func onArCommentsReceived(annotationNode: LensCustomerSDK.AnnotationNotify)
  @_Concurrency.MainActor @preconcurrency public func onArNewNodeCreated()
  @_Concurrency.MainActor @preconcurrency public func onArNodeRemoved()
  @_Concurrency.MainActor @preconcurrency public func updateAnnotationNotesListViewControllerifPresenting()
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class VisualEffectView : UIKit.UIVisualEffectView {
  @_Concurrency.MainActor @preconcurrency open var colorTint: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var colorTintAlpha: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var blurRadius: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var scale: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(effect: UIKit.UIVisualEffect?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class Toast : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency required convenience public init(message: Swift.String, lottie type: (any LensCustomerSDK.LottieType)? = nil)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc required convenience dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func removeFromSuperview()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class InviteViewController : UIKit.UIViewController {
  public struct InviteVCData {
    public let title: Swift.String
    public let titleDescription: Swift.String?
    public let textViewPlaceHolder: Swift.String
    public let linkDescription: Swift.String?
    public let copyTextTitle: Swift.String
    public let copyURL: Foundation.URL
    public let inviteButtonTitle: Swift.String
    public var controllerTitle: Swift.String?
    public init(title: Swift.String, titleDescription: Swift.String?, textViewPlaceHolder: Swift.String, linkDescription: Swift.String?, inviteButtonTitle: Swift.String, copyTextTitle: Swift.String, copyURL: Foundation.URL)
  }
  @_Concurrency.MainActor @preconcurrency public static var at_storyBoardId: Swift.String
  @_Concurrency.MainActor @preconcurrency public static var at_storyBoard: UIKit.UIStoryboard
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var inviteTextView: UIKit.UITextField!
  @_Concurrency.MainActor @preconcurrency public var inviteData: LensCustomerSDK.InviteViewController.InviteVCData?
  @_Concurrency.MainActor @preconcurrency public var onInvite: ((Swift.String) -> ())?
  @_Concurrency.MainActor @preconcurrency public var customerEmail: Swift.String?
  @_Concurrency.MainActor @preconcurrency public var copyClipBoardCompletion: ((Swift.String) -> Swift.String)?
  @_Concurrency.MainActor @preconcurrency public static func inviteVC() -> LensCustomerSDK.InviteViewController?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didReceiveMemoryWarning()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension LensCustomerSDK.InviteViewController : UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
}
extension LensCustomerSDK.InviteViewController : LensCustomerSDK.KeyboardNotificationhandler {
}
extension LensCustomerSDK.InviteViewController : LensCustomerSDK.ControllerReusable {
}
public protocol LensSessionNetworkProtocol : AnyObject {
  var departmentID: Swift.String { get }
  var baseURL: Foundation.URL { get }
  var multiOrgEnabled: Swift.Bool { get }
  var orgId: Swift.Int { get }
  func setAuthorizationHeader(requestSerializer: LensCustomerSDK.VMRequestSerialization, completion: @escaping (Swift.Bool) -> ())
}
public protocol OtherActionsProtocol : AnyObject {
  func onCustomer(performs action: LensCustomerSDK.CustomerAction)
  func onSwitchCameraChanged(isFrontCam: Swift.Bool)
}
public protocol FreezeProtocol : AnyObject {
  func onFreezeStart(id: Swift.String)
  func onFreezeCompleted(id: Swift.String)
  func onFreezeCancelled(id: Swift.String)
  func progress(id: Swift.String, sendBytes: Swift.Int, totalBytes: Swift.Int)
  func liveStreamingPaused(_ freezeBy: LensCustomerSDK.FreezeCurrentStatus.FreezeBy)
  func onUnfreezed(_ unFreezeBy: LensCustomerSDK.FreezeCurrentStatus.FreezeBy)
  func freezeConfiguration(status: LensCustomerSDK.RecodingStatus?)
}
public protocol OtherTechnicianAction : AnyObject {
  func unlockFreeze(by: LensCustomerSDK.Participant?)
  func freezeRunningStream()
  func freezedSnapshotInitiated()
  func snapshotDownloadProgress(totalReceived: Swift.Int, totalSize: Swift.Int)
  func snapshotFreezeCompleted()
  func snapshotFreezeCancel()
  func updateNote()
}
public protocol TechnicianCommonProtocol : AnyObject {
  func onCameraSwitch(isFront: Swift.Bool)
  func onSessionRecordResponseCompletion()
  func onReceiveShareCameraRequest(participant: LensCustomerSDK.Participant?)
  func onShareCameraResponse(action: LensCustomerSDK.ShareCameraTechAction, participant: LensCustomerSDK.Participant?)
  func notifyUserWith(msg: Swift.String)
  func refreshBottomMenu()
  func showLottieView(lottie: LensCustomerSDK.LensLottieType, show: Swift.Bool)
  func showStatusBarNotifyBanner(msg: Swift.String, show: Foundation.TimeInterval)
  func onCustomerAction(action: LensCustomerSDK.CustomerAction)
  func secondaryTechnicianApprovalRequest(email: Swift.String, clientId: Swift.String)
  func secondaryTechnicianApprovalResponse(isAccepted: Swift.Bool, email: Swift.String, clientId: Swift.String)
  func seconderyTechWaitingForCustomerUIUpdate()
}
extension LensCustomerSDK.LottieAnimationView {
  @_Concurrency.MainActor @preconcurrency convenience public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, imageProvider: (any LensCustomerSDK.AnimationImageProvider)? = nil, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(filePath: Swift.String, imageProvider: (any LensCustomerSDK.AnimationImageProvider)? = nil, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(url: Foundation.URL, imageProvider: (any LensCustomerSDK.AnimationImageProvider)? = nil, session: Foundation.URLSession = .shared, closure: @escaping LensCustomerSDK.LottieAnimationView.DownloadClosure, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(asset name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: (any LensCustomerSDK.AnimationImageProvider)? = nil, animationCache: (any LensCustomerSDK.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieName name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationId: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: LensCustomerSDK.LottieConfiguration = .shared, completion: ((LensCustomerSDK.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieFilePath filePath: Swift.String, animationId: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: LensCustomerSDK.LottieConfiguration = .shared, completion: ((LensCustomerSDK.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieUrl url: Foundation.URL, animationId: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: LensCustomerSDK.LottieConfiguration = .shared, session: Foundation.URLSession = .shared, completion: ((LensCustomerSDK.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieAsset name: Swift.String, bundle: Foundation.Bundle = Bundle.main, animationId: Swift.String? = nil, dotLottieCache: (any LensCustomerSDK.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: LensCustomerSDK.LottieConfiguration = .shared, completion: ((LensCustomerSDK.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  public typealias DownloadClosure = ((any Swift.Error)?) -> Swift.Void
}
public struct DotLottieConfiguration {
  public var id: Swift.String
  public var loopMode: LensCustomerSDK.LottieLoopMode
  public var speed: Swift.Double
  public var imageProvider: (any LensCustomerSDK.AnimationImageProvider)? {
    get
  }
}
public struct DotLottieConfigurationComponents : Swift.OptionSet {
  public init(rawValue: Swift.Int)
  public static let imageProvider: LensCustomerSDK.DotLottieConfigurationComponents
  public static let loopMode: LensCustomerSDK.DotLottieConfigurationComponents
  public static let animationSpeed: LensCustomerSDK.DotLottieConfigurationComponents
  public static let all: LensCustomerSDK.DotLottieConfigurationComponents
  public static let none: LensCustomerSDK.DotLottieConfigurationComponents
  public let rawValue: Swift.Int
  public typealias ArrayLiteralElement = LensCustomerSDK.DotLottieConfigurationComponents
  public typealias Element = LensCustomerSDK.DotLottieConfigurationComponents
  public typealias RawValue = Swift.Int
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class SheetSelectionCell : UIKit.UITableViewCell {
  @_Concurrency.MainActor @preconcurrency public static var nib: UIKit.UINib {
    get
  }
  @_Concurrency.MainActor @preconcurrency public static var identifier: Swift.String {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var iconSet: LensCustomerSDK.SelectionSheetIconSet?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func setSelected(_ selected: Swift.Bool, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func configure(_ data: any LensCustomerSDK.SheetSelectionData, iconSet: LensCustomerSDK.SelectionSheetIconSet?)
  @available(iOS 3.0, *)
  @available(iOSApplicationExtension, unavailable)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol SheetSelectionData {
  var uniqueIdentifier: Swift.String { get }
  var title: Swift.String { get }
  var selectedColor: UIKit.UIColor { get }
  var unselectedColor: UIKit.UIColor { get }
}
extension LensCustomerSDK.SheetSelectionData {
  public var unselectedColor: UIKit.UIColor {
    get
  }
  public var selectedColor: UIKit.UIColor {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
public enum SheetActionCellType {
  case actionIconCell, actionImageCell
  public static func == (a: LensCustomerSDK.SheetActionCellType, b: LensCustomerSDK.SheetActionCellType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class SheetActionCell : UIKit.UITableViewCell {
  @_Concurrency.MainActor @preconcurrency public static func nib(for type: LensCustomerSDK.SheetActionCellType) -> UIKit.UINib
  @_Concurrency.MainActor @preconcurrency public static func identifier(for type: LensCustomerSDK.SheetActionCellType) -> Swift.String
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func setSelected(_ selected: Swift.Bool, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func configure(_ data: any LensCustomerSDK.SheetActionData)
  @available(iOS 3.0, *)
  @available(iOSApplicationExtension, unavailable)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class GenericOnBoardingDescriptiorCell : UIKit.UICollectionViewCell, LensCustomerSDK.CellResuable {
  @_Concurrency.MainActor @preconcurrency public static var identifier: Swift.String
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var moduleLabel: UIKit.UILabel!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var descriptionLabel: UIKit.UILabel!
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
public struct BarViewStyleConfigure {
  public var barViewHeight: CoreFoundation.CGFloat
  public var barViewBackgroundColor: UIKit.UIColor
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency open class ATCustomPageController<CellDataType, CellType> : LensCustomerSDK.HeaderAccessoryBarViewMakerController where CellType : LensCustomerSDK.ATBarViewCell {
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak open var barView: UIKit.UICollectionView!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak open var barViewHeightConstraint: UIKit.NSLayoutConstraint!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var middleViewContainer: UIKit.UIView!
  @_Concurrency.MainActor @preconcurrency public var barViewStyle: LensCustomerSDK.BarViewStyleConfigure {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var middleView: UIKit.UIView?
  @_Concurrency.MainActor @preconcurrency public var cellIdentifier: Swift.String?
  @_Concurrency.MainActor @preconcurrency public var cellNib: UIKit.UINib?
  @_Concurrency.MainActor @preconcurrency public var cellItems: [CellDataType]
  @_Concurrency.MainActor @preconcurrency public var cellConfigure: ((_ item: CellDataType, _ cell: CellType, _ indexPath: Foundation.IndexPath) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var cellSizeFor: ((_ item: CellDataType, _ indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize)?
  @_Concurrency.MainActor @preconcurrency public var viewControllers: [UIKit.UIViewController]
  @_Concurrency.MainActor @preconcurrency public var currentIndex: Swift.Int
  @_Concurrency.MainActor @preconcurrency public var didChangeController: ((_ currentPageIndex: Swift.Int, _ currentPage: UIKit.UIViewController) -> ())?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func didReceiveMemoryWarning()
  @_Concurrency.MainActor @preconcurrency public func setController(controllerIndex: Swift.Int, animated: Swift.Bool = true)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class DatePickerController : LensCustomerSDK.OverlayViewController {
  public enum Mode : Swift.Int {
    case time, date, dateAndTime
    public var originMode: UIKit.UIDatePicker.Mode {
      get
    }
    public init?(rawValue: Swift.Int)
    @available(iOSApplicationExtension, unavailable)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var tintColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public var titleColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public var datePickerBacgroundColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public var barBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public var timeZone: Foundation.TimeZone
  @_Concurrency.MainActor @preconcurrency public var datePickerMode: LensCustomerSDK.DatePickerController.Mode
  @_Concurrency.MainActor @preconcurrency public var minimumDate: Foundation.Date?
  @_Concurrency.MainActor @preconcurrency public var maximumDate: Foundation.Date?
  @_Concurrency.MainActor @preconcurrency public var completionHandler: ((_ oldDate: Foundation.Date?, _ newDate: Foundation.Date?) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var defaultDate: Foundation.Date?
  @_Concurrency.MainActor @preconcurrency public var minuteInterval: Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.DatePickerController {
  @_Concurrency.MainActor @preconcurrency public func presentDateControllerAsPopOver(controller: UIKit.UIViewController?, fromView soruceView: UIKit.UIView, popoverDirection direction: UIKit.UIPopoverArrowDirection)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func popoverPresentationControllerDidDismissPopover(_ popoverPresentationController: UIKit.UIPopoverPresentationController)
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class ActionSheetController<SheetDataType> : LensCustomerSDK.SheetController where SheetDataType : LensCustomerSDK.SheetActionData {
  public typealias SectionTuple = (sectionTitle: Swift.String?, rows: [LensCustomerSDK.SheetAction<SheetDataType>])
  @_Concurrency.MainActor @preconcurrency public var sections: [LensCustomerSDK.ActionSheetController<SheetDataType>.SectionTuple]
  @_Concurrency.MainActor @preconcurrency public var canShowSectionSeparator: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var canDismissAutomaticaly: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func addSection(_ section: LensCustomerSDK.ActionSheetController<SheetDataType>.SectionTuple)
  @_Concurrency.MainActor @preconcurrency public func addSections(_ sections: [LensCustomerSDK.ActionSheetController<SheetDataType>.SectionTuple])
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency public func reloadActions()
  @_Concurrency.MainActor @preconcurrency public func reloadAction(section: Swift.Int, action: SheetDataType)
  @_Concurrency.MainActor @preconcurrency @objc override public func searchBar(_ searchBar: UIKit.UISearchBar, textDidChange searchText: Swift.String)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func drawer(dismissed withAnimation: Swift.Bool)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public struct SheetSelectionSection<DataType> where DataType : LensCustomerSDK.SheetSelectionData {
  public var sectionTitle: Swift.String?
  public var rows: [LensCustomerSDK.SheetSelection<DataType>]
  public var isSelectAllButtonEnabled: Swift.Bool
  public var isSelectedAll: Swift.Bool {
    get
  }
  public init(title: Swift.String? = nil, _ rows: [LensCustomerSDK.SheetSelection<DataType>] = [], _ selectionButtonEnabled: Swift.Bool = true)
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class ATPageViewController : UIKit.UIPageViewController {
  @_Concurrency.MainActor @preconcurrency public var pages: [UIKit.UIViewController]
  @_Concurrency.MainActor @preconcurrency public var didChangePage: ((_ currentPageIndex: Swift.Int, _ currentPage: UIKit.UIViewController) -> ())?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func setViewControllers(_ viewControllers: [UIKit.UIViewController]?, direction: UIKit.UIPageViewController.NavigationDirection, animated: Swift.Bool, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(transitionStyle style: UIKit.UIPageViewController.TransitionStyle, navigationOrientation: UIKit.UIPageViewController.NavigationOrientation, options: [UIKit.UIPageViewController.OptionsKey : Any]? = nil)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.ATPageViewController : UIKit.UIPageViewControllerDataSource {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func pageViewController(_ pageViewController: UIKit.UIPageViewController, viewControllerAfter viewController: UIKit.UIViewController) -> UIKit.UIViewController?
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func pageViewController(_ pageViewController: UIKit.UIPageViewController, viewControllerBefore viewController: UIKit.UIViewController) -> UIKit.UIViewController?
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.ATPageViewController : UIKit.UIPageViewControllerDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func pageViewController(_ pageViewController: UIKit.UIPageViewController, willTransitionTo pendingViewControllers: [UIKit.UIViewController])
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func pageViewController(_ pageViewController: UIKit.UIPageViewController, didFinishAnimating finished: Swift.Bool, previousViewControllers: [UIKit.UIViewController], transitionCompleted completed: Swift.Bool)
}
public protocol SheetActionData {
  var actionTitle: Swift.String { get }
  var actionIcon: (any LensCustomerSDK.ATIcon)? { get }
  var actionIconColor: UIKit.UIColor { get }
  var actionCustomIcon: UIKit.UIView? { get }
  var accessoryIcon: (any LensCustomerSDK.ATIcon)? { get }
  var accessoryIconColor: UIKit.UIColor { get }
  var promotionIcon: UIKit.UIImage? { get }
}
extension LensCustomerSDK.SheetActionData {
  public var actionCustomIcon: UIKit.UIView? {
    get
  }
  public var promotionIcon: UIKit.UIImage? {
    get
  }
}
extension LensCustomerSDK.SheetActionData {
  public var accessoryIconColor: UIKit.UIColor {
    get
  }
  public var actionIconColor: UIKit.UIColor {
    get
  }
}
public class SimpleSheetData : LensCustomerSDK.SheetActionData {
  public var promotionIcon: UIKit.UIImage?
  public var actionTitle: Swift.String
  public var actionIcon: (any LensCustomerSDK.ATIcon)?
  public var accessoryIcon: (any LensCustomerSDK.ATIcon)?
  public init(title: Swift.String)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency open class SheetController : UIKit.UIViewController, LensCustomerSDK.HeaderAccessoryBarViewMaker, UIKit.UISearchBarDelegate {
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak open var leftBarContainerView: UIKit.UIView!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak open var rightBarContainerView: UIKit.UIView!
  @_Concurrency.MainActor @preconcurrency open var leftBarViews: [UIKit.UIView]
  @_Concurrency.MainActor @preconcurrency open var rightBarViews: [UIKit.UIView]
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak open var tableview: UIKit.UITableView!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak open var searchBar: UIKit.UISearchBar!
  @_Concurrency.MainActor @preconcurrency public var isSearchBarEnabled: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var enableSearchWithConfiguration: ((UIKit.UISearchBar) -> Swift.Bool)?
  @_Concurrency.MainActor @preconcurrency public var sheetTitle: Swift.String? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var canScrollTable: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var isAutomaticHeightEnabled: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc convenience dynamic public init()
  @_Concurrency.MainActor @preconcurrency convenience public init(title: Swift.String)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency public func displacementAnimate(view: UIKit.UIView, delay: Swift.Int)
  @_Concurrency.MainActor @preconcurrency public func presentWithDrawer(controller: UIKit.UIViewController?, barButtonView soruceView: UIKit.UIBarButtonItem, popoverDirection direction: UIKit.UIPopoverArrowDirection, contentSize size: CoreFoundation.CGSize = .zero, hideStatusBar: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency @objc public func adaptivePresentationStyle(for controller: UIKit.UIPresentationController) -> UIKit.UIModalPresentationStyle
  @_Concurrency.MainActor @preconcurrency public func presentWithDrawer(controller: UIKit.UIViewController?, fromView soruceView: UIKit.UIView?, popoverDirection direction: UIKit.UIPopoverArrowDirection, contentSize size: CoreFoundation.CGSize = .zero, hideStatusBar: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency @objc public func searchBarCancelButtonClicked(_ searchBar: UIKit.UISearchBar)
  @_Concurrency.MainActor @preconcurrency @objc open func searchBar(_ searchBar: UIKit.UISearchBar, textDidChange searchText: Swift.String)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.SheetController : LensCustomerSDK.DrawerControllerDelegate {
  @_Concurrency.MainActor @preconcurrency public func drawerView(for drawer: LensCustomerSDK.DrawerViewController) -> UIKit.UIView
  @_Concurrency.MainActor @preconcurrency public func drawerMaximumHieght(for drawer: LensCustomerSDK.DrawerViewController, _ orientation: UIKit.UIDeviceOrientation) -> CoreFoundation.CGFloat?
  @_Concurrency.MainActor @preconcurrency public func drawer(controller: LensCustomerSDK.DrawerViewController, movingPosition: LensCustomerSDK.DrawerMovingPosition, canChangeDrawerHeight height: CoreFoundation.CGFloat, drawerMinHeight: CoreFoundation.CGFloat, drawerMaximumHeight: CoreFoundation.CGFloat) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func drawer(movingPosition: LensCustomerSDK.DrawerMovingPosition, drawerChangedHeight height: CoreFoundation.CGFloat, drawerMinHeight: CoreFoundation.CGFloat, drawerMaximumHeight: CoreFoundation.CGFloat, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func drawer(_ drawer: LensCustomerSDK.DrawerViewController, reachedMinHeight height: CoreFoundation.CGFloat, animated: Swift.Bool)
  @objc @_Concurrency.MainActor @preconcurrency dynamic open func drawer(dismissed withAnimation: Swift.Bool)
}
public class SheetSelection<SelectionData> : ObjectiveC.NSObject where SelectionData : LensCustomerSDK.SheetSelectionData {
  public var data: SelectionData
  public var isSelected: Swift.Bool
  public init(_ data: SelectionData, isSelected: Swift.Bool = false)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
public protocol HeaderAccessoryBarViewMaker {
  var leftBarContainerView: UIKit.UIView! { get set }
  var rightBarContainerView: UIKit.UIView! { get set }
  var leftBarViews: [UIKit.UIView] { get set }
  var rightBarViews: [UIKit.UIView] { get set }
  func pinLeftBarViews()
  func pinRightBarViews()
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.HeaderAccessoryBarViewMaker where Self : UIKit.UIViewController {
  public func pinLeftBarViews()
  public func pinRightBarViews()
}
@available(iOSApplicationExtension, unavailable)
public struct ToastTheme {
  public init(textColor: SwiftUICore.Color, bgColor: SwiftUICore.Color)
}
@available(iOSApplicationExtension, unavailable)
public enum ToastPosition {
  case top
  case bottom
  public static func == (a: LensCustomerSDK.ToastPosition, b: LensCustomerSDK.ToastPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct SelectionSheetIconSet {
  public var selectionIcon: any LensCustomerSDK.ATIcon {
    get
  }
  public var unSelectionIcon: any LensCustomerSDK.ATIcon {
    get
  }
  public init(_ selectionIcon: any LensCustomerSDK.ATIcon, _ unSelectionIcon: any LensCustomerSDK.ATIcon)
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency open class SelectionSheetController<DataType> : LensCustomerSDK.SheetController where DataType : LensCustomerSDK.SheetSelectionData {
  public enum SelectionMode {
    case single, multy
    public static func == (a: LensCustomerSDK.SelectionSheetController<DataType>.SelectionMode, b: LensCustomerSDK.SelectionSheetController<DataType>.SelectionMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var datasource: LensCustomerSDK.AssistCollectionDataSource<LensCustomerSDK.SheetSelection<DataType>, LensCustomerSDK.SheetSelectionCell>?
  @_Concurrency.MainActor @preconcurrency public var sections: [LensCustomerSDK.SheetSelectionSection<DataType>]
  public typealias CompletionHandlerTuple = (section: Swift.Int, selectedItems: [DataType])
  @_Concurrency.MainActor @preconcurrency public var selectionCompletionHandler: (([LensCustomerSDK.SelectionSheetController<DataType>.CompletionHandlerTuple]) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var mode: LensCustomerSDK.SelectionSheetController<DataType>.SelectionMode
  @_Concurrency.MainActor @preconcurrency public var canShowSectionSeparator: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var noDataLottie: (any LensCustomerSDK.LottieType)?
  @_Concurrency.MainActor @preconcurrency public var iconSet: LensCustomerSDK.SelectionSheetIconSet?
  @_Concurrency.MainActor @preconcurrency public func addSection(_ section: LensCustomerSDK.SheetSelectionSection<DataType>)
  @_Concurrency.MainActor @preconcurrency public func addSections(_ sections: [LensCustomerSDK.SheetSelectionSection<DataType>])
  @_Concurrency.MainActor @preconcurrency public func insert(selection: LensCustomerSDK.SheetSelection<DataType>, in indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency public func update(selection: LensCustomerSDK.SheetSelection<DataType>, in indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency public func delete(selectionAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency public func delete(uniqueId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func insertSection(_ section: LensCustomerSDK.SheetSelectionSection<DataType>, at sectionIndex: Swift.Int)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func reloadSelections()
  @_Concurrency.MainActor @preconcurrency open func initSectionDataSource(_ sectionsArray: [LensCustomerSDK.SheetSelectionSection<DataType>])
  @_Concurrency.MainActor @preconcurrency open func reloadSelectionDataSource(_ _sections: [LensCustomerSDK.SheetSelectionSection<DataType>])
  @_Concurrency.MainActor @preconcurrency open func reloadAsssistDataSource(_ _sections: [LensCustomerSDK.SheetSelectionSection<DataType>])
  @_Concurrency.MainActor @preconcurrency @objc override open func searchBar(_ searchBar: UIKit.UISearchBar, textDidChange searchText: Swift.String)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func dismiss(animated flag: Swift.Bool, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func drawer(dismissed withAnimation: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func popoverPresentationControllerDidDismissPopover(_ popoverPresentationController: UIKit.UIPopoverPresentationController)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency open class HeaderAccessoryBarViewMakerController : UIKit.UIViewController, LensCustomerSDK.HeaderAccessoryBarViewMaker {
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var leftBarContainerView: UIKit.UIView!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var rightBarContainerView: UIKit.UIView!
  @_Concurrency.MainActor @preconcurrency public var leftBarViews: [UIKit.UIView]
  @_Concurrency.MainActor @preconcurrency public var rightBarViews: [UIKit.UIView]
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class SheetSectionFooter : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public static var nibView: LensCustomerSDK.SheetSectionFooter? {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
public enum SheetActionStyle {
  case `default`
  case cancel
  case destructive
  public static func == (a: LensCustomerSDK.SheetActionStyle, b: LensCustomerSDK.SheetActionStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
public struct SheetAction<SheetDataType> {
  public var sheetData: SheetDataType
  public typealias SheetCompletion = ((LensCustomerSDK.SheetAction<SheetDataType>) -> Swift.Void)
  public var handler: LensCustomerSDK.SheetAction<SheetDataType>.SheetCompletion?
  public var style: LensCustomerSDK.SheetActionStyle
  public init(_ data: SheetDataType, handler: LensCustomerSDK.SheetAction<SheetDataType>.SheetCompletion? = nil, style: LensCustomerSDK.SheetActionStyle = SheetActionStyle.default)
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class GenericLottieOnBoardDesciptionController<CellType> : LensCustomerSDK.OrientationHelperController, UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegateFlowLayout, UIKit.UICollectionViewDelegate where CellType : UIKit.UICollectionViewCell {
  public class CellDescription {
    public init(nib: UIKit.UINib, identifier: Swift.String, cofiguration: ((CellType, Foundation.IndexPath) -> Swift.Void)?)
    @objc deinit
  }
  @_Concurrency.MainActor @preconcurrency public var numberOfScenes: Swift.Int
  @_Concurrency.MainActor @preconcurrency public var cellDescription: LensCustomerSDK.GenericLottieOnBoardDesciptionController<CellType>.CellDescription?
  @_Concurrency.MainActor @preconcurrency public var animationSpeed: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public var lottieAnimationView: LensCustomerSDK.LottieAnimationView?
  @_Concurrency.MainActor @preconcurrency public var enablePageController: ((UIKit.UIPageControl) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency convenience public init(lottie: LensCustomerSDK.LottieAnimationView, numberOfScenes: Swift.Int, cellDescription: LensCustomerSDK.GenericLottieOnBoardDesciptionController<CellType>.CellDescription)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency override public func deviceRotated(_ currentOrientation: UIKit.UIDeviceOrientation)
  @_Concurrency.MainActor @preconcurrency @objc public func numberOfSections(in collectionView: UIKit.UICollectionView) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor @preconcurrency @objc public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
  @_Concurrency.MainActor @preconcurrency @objc public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency public func reloadData()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class SheetSectionHeader : UIKit.UITableViewHeaderFooterView {
  @_Concurrency.MainActor @preconcurrency public static var nibView: LensCustomerSDK.SheetSectionHeader? {
    get
  }
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var titleLabel: UIKit.UILabel!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var containerView: UIKit.UIView!
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var LeftAccessoryContainerView: UIKit.UIView!
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor @preconcurrency public func setTitle(_ text: Swift.String)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(reuseIdentifier: Swift.String?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
public class QLPreviewHandler {
  public var previewObjects: [any QuickLook.QLPreviewItem] {
    get
    set
  }
  public init(previewData: [any QuickLook.QLPreviewItem])
  public func appendPreview(_ data: [any QuickLook.QLPreviewItem], fromIndex: Swift.Int? = nil)
  public func showQL(from vc: UIKit.UIViewController, index: Swift.Int = 0)
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.QLPreviewHandler : QuickLook.QLPreviewControllerDataSource {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func numberOfPreviewItems(in controller: QuickLook.QLPreviewController) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func previewController(_ controller: QuickLook.QLPreviewController, previewItemAt index: Swift.Int) -> any QuickLook.QLPreviewItem
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency open class ATBarViewCell : UIKit.UICollectionViewCell {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency open func cellSelected(_ flag: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
postfix operator |-|
postfix operator |=|
infix operator |-| : DefaultPrecedence
infix operator |=| : DefaultPrecedence
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency postfix public static func |-| (argument: UIKit.UIView)
  @_Concurrency.MainActor @preconcurrency public static func |-| (lhs: UIKit.UIView, rhs: UIKit.UIView)
  @_Concurrency.MainActor @preconcurrency public static func |-| (lhs: UIKit.UIView, padding: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency postfix public static func |=| (argument: UIKit.UIView)
  @_Concurrency.MainActor @preconcurrency public static func |=| (lhs: UIKit.UIView, rhs: UIKit.UIView)
}
@objc @_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency public class AssistBlurAlertController : LensCustomerSDK.OverlayViewController, LensCustomerSDK.KeyboardNotificationhandler {
  @objc @IBOutlet @_Concurrency.MainActor @preconcurrency weak public var textField: UIKit.UITextField!
  @_Concurrency.MainActor @preconcurrency public var actions: [LensCustomerSDK.AssistAlertAction]
  @_Concurrency.MainActor @preconcurrency public var enableTextFieldWithConfiguration: ((UIKit.UITextField) -> Swift.Bool)?
  @_Concurrency.MainActor @preconcurrency public var enablesliderWithConfiguration: ((UIKit.UISlider) -> Swift.Bool)?
  @_Concurrency.MainActor @preconcurrency public var configureButtonUI: ((UIKit.UIButton) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var textFieldValidationHandler: ((_ controller: LensCustomerSDK.AssistBlurAlertController, _ text: Swift.String?, _ action: LensCustomerSDK.AssistAlertAction) -> (Swift.Bool))?
  @_Concurrency.MainActor @preconcurrency public var isTextFieldEnabled: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc convenience dynamic public init()
  @_Concurrency.MainActor @preconcurrency convenience public init(title: Swift.String?, description: Swift.String? = nil)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency public func showError(message: Swift.String, resetTime: Foundation.TimeInterval = 1)
  @_Concurrency.MainActor @preconcurrency public func addAction(_ action: LensCustomerSDK.AssistAlertAction)
  @_Concurrency.MainActor @preconcurrency public func addActions(_ actions: [LensCustomerSDK.AssistAlertAction])
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didReceiveMemoryWarning()
  @objc deinit
  @_Concurrency.MainActor @preconcurrency override public func supportedOrientation() -> LensCustomerSDK.At_Orientation
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func shake()
}
@available(iOSApplicationExtension, unavailable)
public protocol AlertStyleConfiguration {
  var backgroundColor: UIKit.UIColor { get }
  var titleColor: UIKit.UIColor { get }
  var borderColor: UIKit.UIColor? { get }
  var borderWidth: CoreFoundation.CGFloat { get }
}
@available(iOSApplicationExtension, unavailable)
public enum AlertStyle : LensCustomerSDK.AlertStyleConfiguration {
  case `default`, destructive, outlined
  public var backgroundColor: UIKit.UIColor {
    get
  }
  public var titleColor: UIKit.UIColor {
    get
  }
  public var borderColor: UIKit.UIColor? {
    get
  }
  public var borderWidth: CoreFoundation.CGFloat {
    get
  }
  public static func == (a: LensCustomerSDK.AlertStyle, b: LensCustomerSDK.AlertStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
public struct AssistAlertAction {
  public typealias AssistCompletionHandler = ((LensCustomerSDK.AssistAlertAction, LensCustomerSDK.AssistBlurAlertController) -> ())
  public var title: Swift.String?
  public var completionHandler: LensCustomerSDK.AssistAlertAction.AssistCompletionHandler?
  public var styleConfiguration: any LensCustomerSDK.AlertStyleConfiguration
  public init(title titleText: Swift.String?, style: any LensCustomerSDK.AlertStyleConfiguration = AlertStyle.default, handler: LensCustomerSDK.AssistAlertAction.AssistCompletionHandler?)
}
@objc final public class CompatibleAnimationKeypath : ObjectiveC.NSObject {
  @objc public init(keypath: Swift.String)
  @objc public init(keys: [Swift.String])
  final public let animationKeypath: LensCustomerSDK.AnimationKeypath
  @objc deinit
}
public protocol AnimationFontProvider {
  func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
}
final public class DefaultFontProvider : LensCustomerSDK.AnimationFontProvider {
  public init()
  final public func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
  @objc deinit
}
extension LensCustomerSDK.DefaultFontProvider : Swift.Equatable {
  public static func == (_: LensCustomerSDK.DefaultFontProvider, _: LensCustomerSDK.DefaultFontProvider) -> Swift.Bool
}
extension CoreFoundation.CGFloat {
  public var quarter: CoreFoundation.CGFloat {
    get
  }
  public var half: CoreFoundation.CGFloat {
    get
  }
  public var Threequarter: CoreFoundation.CGFloat {
    get
  }
}
extension CoreFoundation.CGFloat {
  public func rounded(toPlaces places: Swift.Int) -> CoreFoundation.CGFloat
}
public enum ColorFormatDenominator : Swift.Hashable {
  case One
  case OneHundred
  case TwoFiftyFive
  public static func == (a: LensCustomerSDK.ColorFormatDenominator, b: LensCustomerSDK.ColorFormatDenominator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct LottieColor : Swift.Hashable {
  public var r: Swift.Double
  public var g: Swift.Double
  public var b: Swift.Double
  public var a: Swift.Double
  public init(r: Swift.Double, g: Swift.Double, b: Swift.Double, a: Swift.Double, denominator: LensCustomerSDK.ColorFormatDenominator = .One)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.LottieColor, b: LensCustomerSDK.LottieColor) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AnyValueProvider {
  var valueType: any Any.Type { get }
  var typeErasedStorage: LensCustomerSDK.AnyValueProviderStorage { get }
  func hasUpdate(frame: LensCustomerSDK.AnimationFrameTime) -> Swift.Bool
}
extension LensCustomerSDK.AnyValueProvider {
  public func value(frame: LensCustomerSDK.AnimationFrameTime) -> Any
}
public enum ValueProviderStorage<T> where T : LensCustomerSDK.AnyInterpolatable {
  case singleValue(T)
  case keyframes([LensCustomerSDK.Keyframe<T>])
  case closure((LensCustomerSDK.AnimationFrameTime) -> T)
}
public enum AnyValueProviderStorage {
  case singleValue(Any)
  case keyframes([LensCustomerSDK.Keyframe<Any>], interpolate: (LensCustomerSDK.AnimationFrameTime) -> Any)
  case closure((LensCustomerSDK.AnimationFrameTime) -> Any)
}
@_hasMissingDesignatedInitializers final public class DotLottieFile {
  public struct Animation {
    public let animation: LensCustomerSDK.LottieAnimation
    public let configuration: LensCustomerSDK.DotLottieConfiguration
  }
  final public var animations: [LensCustomerSDK.DotLottieFile.Animation] {
    get
  }
  @objc deinit
}
extension LensCustomerSDK.DotLottieFile : @unchecked Swift.Sendable {
}
extension LensCustomerSDK.LottieVector1D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct LottieVector2D : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.LottieVector2D, b: LensCustomerSDK.LottieVector2D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LensCustomerSDK.LottieVector3D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension LensCustomerSDK.LottieVector3D {
  public var pointValue: CoreFoundation.CGPoint {
    get
  }
  public var sizeValue: CoreFoundation.CGSize {
    get
  }
}
public struct AnimationKeypath : Swift.Hashable, Swift.ExpressibleByStringLiteral {
  public init(keypath: Swift.String)
  public init(stringLiteral: Swift.String)
  public init(keys: [Swift.String])
  public var keys: [Swift.String] {
    get
  }
  public var string: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LensCustomerSDK.AnimationKeypath, b: LensCustomerSDK.AnimationKeypath) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedSwitch : LensCustomerSDK.AnimatedControl {
  @_Concurrency.MainActor @preconcurrency override public init(animation: LensCustomerSDK.LottieAnimation?, configuration: LensCustomerSDK.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency override open func animationDidSet()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  public enum CancelBehavior {
    case reverse
    case none
    public static func == (a: LensCustomerSDK.AnimatedSwitch.CancelBehavior, b: LensCustomerSDK.AnimatedSwitch.CancelBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var cancelBehavior: LensCustomerSDK.AnimatedSwitch.CancelBehavior
  @_Concurrency.MainActor @preconcurrency public var animateUpdateWhenChangingAnimation: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public var stateUpdated: ((_ isOn: Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var isOn: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func setIsOn(_ isOn: Swift.Bool, animated: Swift.Bool, shouldFireHaptics: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func setProgressForState(fromProgress: LensCustomerSDK.AnimationProgressTime, toProgress: LensCustomerSDK.AnimationProgressTime, forOnState: Swift.Bool)
  @objc deinit
}
extension Foundation.URL {
  public var params: [(Swift.String, Swift.String)] {
    get
  }
  public func appendNewQueryParams(param: [Swift.String : Any]) -> Foundation.URL?
  public func appendParams(param: [Swift.String : Swift.String]) -> Foundation.URL?
  public static func constructURLString(API: Swift.String, service: Swift.String, protocol protocolString: Swift.String, domain: Swift.String) -> Swift.String
  public static func constructURL(API: Swift.String, service: Swift.String, protocol protocolString: Swift.String, domain: Swift.String) -> Foundation.URL?
}
extension UIKit.UIScrollView {
  @_Concurrency.MainActor @preconcurrency public func didScrollToEnd() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func tryingToViewMore(_ range: CoreFoundation.CGFloat = 50) -> Swift.Bool
}
extension UIKit.UIScrollView {
  public enum ATViewSide {
    case left, right, bottom, top
    public static func == (a: UIKit.UIScrollView.ATViewSide, b: UIKit.UIScrollView.ATViewSide) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public func contentSize(withSafeArea side: UIKit.UIScrollView.ATViewSide) -> CoreFoundation.CGSize
}
extension Swift.Array {
  public mutating func removeElements(_ filter: (Element) -> Swift.Bool)
}
extension Swift.Array where Element : Swift.Equatable {
  public func contains(_ element: Element) -> Swift.Bool
  public func index(of element: Element) -> Swift.Int?
  public mutating func remove(element: Element)
}
public protocol Interpolatable : LensCustomerSDK.AnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
public protocol SpatialInterpolatable : LensCustomerSDK.AnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
public protocol AnyInterpolatable {
  func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
extension LensCustomerSDK.Interpolatable {
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent _: CoreFoundation.CGPoint?, spatialInTangent _: CoreFoundation.CGPoint?) -> Self
}
extension LensCustomerSDK.SpatialInterpolatable {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
extension Swift.Double : LensCustomerSDK.Interpolatable {
}
extension CoreFoundation.CGFloat : LensCustomerSDK.Interpolatable {
}
extension Swift.Float : LensCustomerSDK.Interpolatable {
}
extension LensCustomerSDK.Interpolatable where Self : Swift.BinaryFloatingPoint {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
extension CoreFoundation.CGRect : LensCustomerSDK.Interpolatable {
  public func interpolate(to: CoreFoundation.CGRect, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGRect
}
extension CoreFoundation.CGSize : LensCustomerSDK.Interpolatable {
  public func interpolate(to: CoreFoundation.CGSize, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
}
extension CoreFoundation.CGPoint : LensCustomerSDK.SpatialInterpolatable {
  public func interpolate(to: CoreFoundation.CGPoint, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> CoreFoundation.CGPoint
}
extension LensCustomerSDK.LottieColor : LensCustomerSDK.Interpolatable {
  public func interpolate(to: LensCustomerSDK.LottieColor, amount: CoreFoundation.CGFloat) -> LensCustomerSDK.LottieColor
}
extension LensCustomerSDK.LottieVector1D : LensCustomerSDK.Interpolatable {
  public func interpolate(to: LensCustomerSDK.LottieVector1D, amount: CoreFoundation.CGFloat) -> LensCustomerSDK.LottieVector1D
}
extension LensCustomerSDK.LottieVector2D : LensCustomerSDK.SpatialInterpolatable {
  public func interpolate(to: LensCustomerSDK.LottieVector2D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> LensCustomerSDK.LottieVector2D
}
extension LensCustomerSDK.LottieVector3D : LensCustomerSDK.SpatialInterpolatable {
  public func interpolate(to: LensCustomerSDK.LottieVector3D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> LensCustomerSDK.LottieVector3D
}
extension Swift.Array : LensCustomerSDK.Interpolatable, LensCustomerSDK.AnyInterpolatable where Element : LensCustomerSDK.Interpolatable {
  public func interpolate(to: [Element], amount: CoreFoundation.CGFloat) -> [Element]
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : LensCustomerSDK.Interpolatable, LensCustomerSDK.AnyInterpolatable where Wrapped : LensCustomerSDK.Interpolatable {
  public func interpolate(to: Wrapped?, amount: CoreFoundation.CGFloat) -> Wrapped?
}
#else
extension Swift.Optional : LensCustomerSDK.Interpolatable, LensCustomerSDK.AnyInterpolatable where Wrapped : LensCustomerSDK.Interpolatable {
  public func interpolate(to: Wrapped?, amount: CoreFoundation.CGFloat) -> Wrapped?
}
#endif
@available(iOSApplicationExtension, unavailable)
public protocol KeyboardNotificationhandler {
  func addKeyboardChange(observer: Any?, selector: ObjectiveC.Selector)
  func removeKeyboardChange(observer: Any?)
}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.KeyboardNotificationhandler {
  public func getKeyboardDetails(for notification: Foundation.Notification) -> (frame: CoreFoundation.CGRect?, duration: Foundation.TimeInterval, option: UIKit.UIView.AnimationOptions)
  public func addKeyboardChange(observer: Any?, selector: ObjectiveC.Selector)
  public func removeKeyboardChange(observer: Any?)
}
public typealias LottieControlType = UIKit.UIControl
public typealias LottieControlState = UIKit.UIControl.State
public typealias LottieControlEvent = UIKit.UIControl.Event
final public class ColorValueProvider {
  public init(block: @escaping LensCustomerSDK.ColorValueProvider.ColorValueBlock)
  public init(_ color: LensCustomerSDK.LottieColor)
  public init(_ keyframes: [LensCustomerSDK.Keyframe<LensCustomerSDK.LottieColor>])
  public typealias ColorValueBlock = (CoreFoundation.CGFloat) -> LensCustomerSDK.LottieColor
  final public var color: LensCustomerSDK.LottieColor {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: LensCustomerSDK.ValueProviderStorage<LensCustomerSDK.LottieColor> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.ColorValueProvider : Swift.Equatable {
  public static func == (lhs: LensCustomerSDK.ColorValueProvider, rhs: LensCustomerSDK.ColorValueProvider) -> Swift.Bool
}
public class SocketHandler {
  public var socket: (any LensCustomerSDK.WebSocketProtocol)?
  public var timeOut: Swift.Double
  public var reachability: LensCustomerSDK.Reachability?
  public var gateWayUrlRequest: Foundation.URLRequest!
  final public let writeQoS: Foundation.QualityOfService
  final public let readQoS: Foundation.QualityOfService
  public init(_ url: Foundation.URLRequest, writeQoS: Foundation.QualityOfService, readQoS: Foundation.QualityOfService)
  public var disableSSLCertValidation: Swift.Bool {
    get
    set
  }
  public var isConnected: Swift.Bool {
    get
  }
  public func start()
  public func addListerner(_ object: any LensCustomerSDK.AssistSocketProtocol) -> LensCustomerSDK.DisposableObserver
  public func removeListerner(_ object: LensCustomerSDK.DisposableObserver)
  public func reset()
  public func write(_ string: Swift.String?)
  public func write(_ data: Foundation.Data?)
  public func disconnect()
  @objc deinit
}
extension LensCustomerSDK.SocketHandler : LensCustomerSDK.WebSocketCallBack {
  public func onConnect()
  public func onDisconnect(error: (any Swift.Error)?)
  public func onTextReceive(_ text: Swift.String)
  public func onDataReceive(_ data: Foundation.Data)
}
public protocol LottieType {
  var lottie: LensCustomerSDK.LottieAnimationView { get }
  var size: CoreFoundation.CGSize? { get }
  var message: Swift.String? { get }
}
public enum LensAnnotationType : Swift.String {
  case none, measurement, rectangle, ellipse, pencil, arrow, pointer
  public var isArrow: Swift.Bool {
    get
  }
  public var isMeasurement: Swift.Bool {
    get
  }
  public var isPencil: Swift.Bool {
    get
  }
  public var isPointer: Swift.Bool {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum FreeStyleState : Swift.CustomStringConvertible {
  case mouse_move, mouse_up
  public var description: Swift.String {
    get
  }
  public static func == (a: LensCustomerSDK.FreeStyleState, b: LensCustomerSDK.FreeStyleState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public enum ARFrameMode : Swift.Int {
  case auto
  case aspectFit
  case aspectFill
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum ARVideoOrientation : Swift.Int {
  case auto
  case alwaysPortrait
  case alwaysLandscape
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum RecordARMicrophonePermission : Swift.Int {
  case auto
  case manual
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum RecordARStatus : Swift.Int {
  case unknown
  case readyToRecord
  case recording
  case paused
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum RecordARMicrophoneStatus : Swift.Int {
  case unknown
  case enabled
  case disabled
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum VideoResolution : CoreFoundation.CGFloat {
  case resolution_720p
  case resolution_480p
  case resolution_360p
  public init?(rawValue: CoreFoundation.CGFloat)
  public typealias RawValue = CoreFoundation.CGFloat
  public var rawValue: CoreFoundation.CGFloat {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class ARRenderView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency weak public var arVideoDelegate: (any LensCustomerSDK.ARVideoDelegate)?
  @_Concurrency.MainActor @preconcurrency public var sceneView: ARKit.ARSCNView!
  @_Concurrency.MainActor @preconcurrency public var selectedARTool: LensCustomerSDK.LensAnnotationType {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc convenience dynamic public init()
  @_Concurrency.MainActor @preconcurrency convenience public init(arDelegate: (any LensCustomerSDK.ARViewDelegate)? = nil, triggerId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func setUserName(name: Swift.String)
  @objc @_Concurrency.MainActor @preconcurrency public func resumeARSCNViewSession(isSessionStart: Swift.Bool = true, callWithDelay: Swift.Bool = false)
  @objc @_Concurrency.MainActor @preconcurrency public func pauseARSCNViewSession()
  @objc @_Concurrency.MainActor @preconcurrency public func pauseARSCNViewSession(forBackgroundTransition: Swift.Bool)
  @objc @_Concurrency.MainActor @preconcurrency public func isARSCNViewSessionPaused() -> Swift.Bool
  @objc @_Concurrency.MainActor @preconcurrency public func pauseARSCNViewSessionInHD(SessionPauseCallback callback: @escaping () -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public func snapshot() -> UIKit.UIImage
  @_Concurrency.MainActor @preconcurrency public func getRawCameraImageBuffer() -> CoreVideo.CVPixelBuffer?
  @_Concurrency.MainActor @preconcurrency public func getRawCameraImage() -> UIKit.UIImage?
  @objc deinit
}
extension LensCustomerSDK.ARRenderView {
  @_Concurrency.MainActor @preconcurrency public func updateSelectedARTool(tool: LensCustomerSDK.LensAnnotationType)
}
extension LensCustomerSDK.ARRenderView {
  @_Concurrency.MainActor @preconcurrency public func drawLine(withId id: Swift.String, withLineColor color: UIKit.UIColor = UIColor(red: 0.129, green: 0.639, blue: 0.356, alpha: 1), atPoint point: CoreFoundation.CGPoint, triggerId: Swift.String, freeStyle: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func placeArrow(withId id: Swift.String = Node.DEFAULT_USER_ID, atPoint originalPoint: CoreFoundation.CGPoint, withArrowColor arrowColor: UIKit.UIColor = UIColor(red: 0.129, green: 0.639, blue: 0.356, alpha: 1), triggerId: Swift.String, isCustomer: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency public func placePointer(withId id: Swift.String = Node.DEFAULT_USER_ID, atPoint originalPoint: CoreFoundation.CGPoint, withLabel userName: Swift.String, fadeOutDelay: Swift.Int = Pointer.DEFAULT_FADE_OUT_DELAY, withPointerColor pointerColor: UIKit.UIColor = UIColor(red: 0.129, green: 0.639, blue: 0.356, alpha: 1), triggerId: Swift.String, isCustomer: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency public func drawRectangle(withId id: Swift.String, color: UIKit.UIColor = UIColor(red: 0.129, green: 0.639, blue: 0.356, alpha: 1), startPoint: CoreFoundation.CGPoint, endPoint: CoreFoundation.CGPoint, triggerId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func drawEllipse(withId id: Swift.String, color: UIKit.UIColor = UIColor(red: 0.129, green: 0.639, blue: 0.356, alpha: 1), startPoint: CoreFoundation.CGPoint, endPoint: CoreFoundation.CGPoint, triggerId: Swift.String)
}
extension LensCustomerSDK.ARRenderView {
  @_Concurrency.MainActor @preconcurrency public func setVideoFPS(fps: Swift.Int)
  @_Concurrency.MainActor @preconcurrency public func renderPointCloud(_ flag: Swift.Bool, callback: ((_ flag: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func isRenderingPointCloud() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func renderPlanes(_ flag: Swift.Bool, callback: ((_ flag: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func isRenderingPlanes() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var isHDStreaming: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func setHighResolution(_ flag: Swift.Bool, callback: ((_ flag: Swift.Bool) -> Swift.Void)? = nil)
  @available(*, deprecated, renamed: "getCustomerAnchorCount")
  @_Concurrency.MainActor @preconcurrency public func getAnchorCount() -> Swift.Int
  @_Concurrency.MainActor @preconcurrency public func getCustomerAnchorCount() -> Swift.Int
  @_Concurrency.MainActor @preconcurrency public func getTechnicianAnchorCount() -> Swift.Int
  @_Concurrency.MainActor @preconcurrency public func getMaxAnchorCount() -> Swift.Int
  @available(*, deprecated, renamed: "removeFirstCustomerAnchor")
  @_Concurrency.MainActor @preconcurrency public func removeFirstAnchor(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func removeFirstCustomerAnchor(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @available(*, deprecated, renamed: "removeLastCustomerAnchor")
  @_Concurrency.MainActor @preconcurrency public func removeLastAnchor(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func removeLastCustomerAnchor(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func removeLastTechnicianAnchor(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @available(*, deprecated, renamed: "removeAllCustomerAnchors")
  @_Concurrency.MainActor @preconcurrency public func removeAllAnchors(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func removeAllCustomerAnchors(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func removeAllTechnicianAnchors(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func removeSelectedCustomerAnchor(callback: ((_ remainingAnchorCount: Swift.Int) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func isAnyCustomerAnchorSelected() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func isAnyTechnicianAnchorSelected() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func selectTechnicianAnchor(atPoint originalPoint: CoreFoundation.CGPoint, triggerId: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency public func setAnchorSelectionListener(listener: any LensCustomerSDK.AnnotationSelectionListener)
  @_Concurrency.MainActor @preconcurrency public func setAnchorStateListener(listener: any LensCustomerSDK.AnchorStateListener)
  @_Concurrency.MainActor @preconcurrency public func updateNodeAnchor(annotateId: Swift.String, text: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func selectNodeAnchor(annotateId: Swift.String, senderTriggerId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func deselectNodeAnchor(annotateId: Swift.String, triggerId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func removeNodeAnchor(annotateId: Swift.String)
}
extension LensCustomerSDK.ARRenderView {
  @_Concurrency.MainActor @preconcurrency public class func checkARKitCompatibility() -> Swift.Bool
}
extension LensCustomerSDK.ARRenderView : ARKit.ARSessionDelegate, ARKit.ARSCNViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func sessionWasInterrupted(_ session: ARKit.ARSession)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func sessionInterruptionEnded(_ session: ARKit.ARSession)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func session(_ session: ARKit.ARSession, cameraDidChangeTrackingState camera: ARKit.ARCamera)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func session(_ session: ARKit.ARSession, didFailWithError error: any Swift.Error)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func renderer(_ renderer: any SceneKit.SCNSceneRenderer, didAdd node: SceneKit.SCNNode, for anchor: ARKit.ARAnchor)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func renderer(_ renderer: any SceneKit.SCNSceneRenderer, didUpdate node: SceneKit.SCNNode, for anchor: ARKit.ARAnchor)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func session(_ session: ARKit.ARSession, didUpdate frame: ARKit.ARFrame)
}
@objc @available(iOS 11.0, *)
public class ARRecorder : ObjectiveC.NSObject {
  @objc public var delegate: (any LensCustomerSDK.RecordARDelegate)?
  @objc public var renderAR: (any LensCustomerSDK.RenderARDelegate)?
  @objc public var status: LensCustomerSDK.RecordARStatus {
    get
  }
  @objc public var micStatus: LensCustomerSDK.RecordARMicrophoneStatus {
    get
  }
  @objc public var requestMicPermission: LensCustomerSDK.RecordARMicrophonePermission {
    @objc get
    @objc set
  }
  public var videoResolution: LensCustomerSDK.VideoResolution {
    get
    set
  }
  @objc public var videoOrientation: LensCustomerSDK.ARVideoOrientation
  @objc public var contentMode: LensCustomerSDK.ARFrameMode
  @objc public var onlyRenderWhileRecording: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var enableAudio: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var enableMixWithOthers: Swift.Bool
  @objc public var adjustVideoForSharing: Swift.Bool
  @objc public var deleteCacheWhenExported: Swift.Bool
  @objc public var enableAdjustEnvironmentLighting: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var retainTechnique: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public init(ARSceneKit: ARKit.ARSCNView)
  @objc deinit
  public func isVideoRecording() -> Swift.Bool
  @objc public func record(at url: Foundation.URL? = nil)
  @objc public func record(at url: Foundation.URL? = nil, forDuration duration: Foundation.TimeInterval, _ finished: ((_ videoPath: Foundation.URL) -> Swift.Void)? = nil)
  @objc public func pause()
  @objc public func stopAndExport(_ finished: ((_ videoAsset: Photos.PHAsset?, _ videoPath: Foundation.URL?, _ permissionStatus: Photos.PHAuthorizationStatus, _ exported: Swift.Bool) -> Swift.Void)? = nil)
  @objc public func stop(_ finished: ((_ videoPath: Foundation.URL) -> Swift.Void)? = nil)
  @objc public func cancel()
  @objc public func export(video path: Foundation.URL, _ finished: ((_ videoAsset: Photos.PHAsset?, _ videoPath: Foundation.URL?, _ exported: Swift.Bool, _ permissionStatus: Photos.PHAuthorizationStatus) -> Swift.Void)? = nil)
  @objc public func requestMicrophonePermission(_ finished: ((_ status: Swift.Bool) -> Swift.Void)? = nil)
}
@available(iOS 11.0, *)
@objc extension LensCustomerSDK.ARRecorder {
  @objc dynamic public func prepare(_ configuration: ARKit.ARConfiguration? = nil)
}
@available(iOS 11.0, *)
@objc public protocol RecordARDelegate {
  @objc func recorder(didEndRecording path: Foundation.URL, with noError: Swift.Bool)
  @objc func recorder(didFailRecording error: (any Swift.Error)?, and status: Swift.String)
  @objc optional func recorder(didCancelRecording status: Swift.String)
  @objc optional func recorder(didUpdateRecording duration: Foundation.TimeInterval)
  @objc func recorder(willEnterBackground status: LensCustomerSDK.RecordARStatus)
}
public enum StreamingType : Swift.String {
  case none
  case down
  case up
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum QRRetryMode {
  case NONE
  case RETRY_CONTINOUSLY
  case RETRY_UNTIL_TIME_LIMIT
  public static func == (a: LensCustomerSDK.QRRetryMode, b: LensCustomerSDK.QRRetryMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Lens {
  public var lensSignallingDelegate: (any LensCustomerSDK.LensSignallingProtocol)? {
    get
    set
  }
  public static var isVerbose: Swift.Bool
  public var isCameraFacingFront: Swift.Bool
  weak public var chatDelegate: (any LensCustomerSDK.ChatProtocol)?
  public var participants: [LensCustomerSDK.Participant] {
    get
  }
  public var sessionKey: Swift.String {
    get
  }
  public var clientRole: Swift.Int {
    get
  }
  public var clientToken: Swift.String {
    get
  }
  public var clientID: Swift.String? {
    get
  }
  public var displayName: Swift.String? {
    get
  }
  public var customerObject: LensCustomerSDK.Participant? {
    get
  }
  public var creatorZUID: Foundation.NSNumber? {
    get
  }
  public var technicianObjects: [LensCustomerSDK.Participant] {
    get
  }
  public var selfEmail: Swift.String {
    get
  }
  public var selfName: Swift.String {
    get
  }
  public var edition: LensCustomerSDK.Edition? {
    get
  }
  public var supportedfeatures: [LensCustomerSDK.Features]? {
    get
  }
  public var connectionParam: any LensCustomerSDK.CommonConnectionParams {
    get
  }
  public var isFreezedState: Swift.Bool {
    get
    set
  }
  public var isSnapshotFreezeEnabled: Swift.Bool
  public var isARSupported: Swift.Bool {
    get
    set
  }
  public var isFrontCamAvailable: Swift.Bool {
    get
  }
  @discardableResult
  public func swapToFrontCamera() -> Swift.Bool
  @discardableResult
  public func swapToBackCamera() -> Swift.Bool
  public var lens_protocol_delegate: (any LensCustomerSDK.LensSessionProtocolDelegate)?
  public var arRenderView: LensCustomerSDK.ARRenderView? {
    get
  }
  public var videoResolution: CoreFoundation.CGSize?
  public var arNodesNotifyList: [LensCustomerSDK.AnnotationNotify] {
    get
  }
  weak public var arDelegate: (any LensCustomerSDK.ARProtocol)?
  @objc deinit
}
extension LensCustomerSDK.Lens {
  public func onArNewNodeCreationReceived(annotationId: Swift.String)
  public func onArNodeRemovedReceived(annotationId: Swift.String)
  public func annotationSelected(annotationId: Swift.String, state: LensCustomerSDK.AnnotationSelection, triggerId: Swift.String)
}
extension LensCustomerSDK.Lens : LensCustomerSDK.AnnotationSelectionListener, LensCustomerSDK.AnchorStateListener {
  public func onAnnotationSelected(id: Swift.String, triggerId: Swift.String)
  public func onAnnotationDeselected(id: Swift.String, triggerId: Swift.String)
  public func onAnchorPlaced(annotationId: Swift.String, annotationColor: UIKit.UIColor, annotationType: Swift.String, annotationNumber: Swift.Int, triggerId: Swift.String, length: Swift.String? = nil)
  public func onAnchorRemoved(annotationId: Swift.String)
}
extension LensCustomerSDK.Lens {
  public func isToolSupported(tool: LensCustomerSDK.SupportedTools) -> Swift.Bool
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (LensCustomerSDK.Reachability) -> ()
  public typealias NetworkUnreachable = (LensCustomerSDK.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: LensCustomerSDK.Reachability.NetworkStatus, b: LensCustomerSDK.Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    @available(*, deprecated, renamed: "unavailable")
    public static let none: LensCustomerSDK.Reachability.Connection
    public static func == (a: LensCustomerSDK.Reachability.Connection, b: LensCustomerSDK.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: LensCustomerSDK.Reachability.NetworkReachable?
  public var whenUnreachable: LensCustomerSDK.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: LensCustomerSDK.Reachability.Connection {
    get
  }
  public var connection: LensCustomerSDK.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension LensCustomerSDK.Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class AnnotationNotes : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class AnnotaionNote : Swift.Codable {
  public var data: Swift.String
  final public let triggerID: Swift.String
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class AnnotationNotify : Swift.Codable {
  public var annotationObjectID: Swift.Int?
  final public let triggerID: Swift.String?
  public var notes: [LensCustomerSDK.AnnotaionNote]?
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class NotificationHandler {
  public static func removeAllNotificaion()
  public static func register(categories: [LensCustomerSDK.UserNotificationCategory])
  public static func schedule(notification configuration: LensCustomerSDK.UserNotificationScheduleConfiguration, completion: ((Swift.Bool) -> Swift.Void)?)
  @objc deinit
}
public struct OCRData {
  public var ocrText: Swift.String
  public var confidence: Swift.String
}
public struct QRData {
  public var qrText: Swift.String
}
public struct UserNotificationScheduleConfiguration {
  public let body: Swift.String
  public let title: Swift.String?
  public var uniqueID: Swift.String
  public let scheduleDate: Foundation.Date
  public var category: LensCustomerSDK.NotificationCategoryIdentifier?
}
public struct NotificationCategoryIdentifier : Swift.RawRepresentable {
  public var rawValue: Swift.String
  public static var chat: LensCustomerSDK.NotificationCategoryIdentifier
  public init(rawValue: Swift.String)
  public init(_ rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public struct UserNotificationCategory {
  public static var chat: LensCustomerSDK.UserNotificationCategory {
    get
  }
  public var categoryId: LensCustomerSDK.NotificationCategoryIdentifier
  public var actions: [LensCustomerSDK.UserNotificationAction]
  public init(_ cid: LensCustomerSDK.NotificationCategoryIdentifier, actions: [LensCustomerSDK.UserNotificationAction])
}
public struct UserNotificationAction {
  public enum ActionType {
    case actionButton(title: Swift.String)
    case inputField(title: Swift.String, textFieldplaceHolder: Swift.String, inputActionTitle: Swift.String)
  }
  public let actionType: LensCustomerSDK.UserNotificationAction.ActionType
  public let actionID: Swift.String
}
extension LensCustomerSDK.Lens {
  @discardableResult
  public func send(_ message: Swift.String) -> Swift.Bool
  @discardableResult
  public func send(_ chat: LensCustomerSDK.Chat) -> Swift.Bool
}
public enum CanvasBoardSettings : Swift.String {
  case ellipse, pencil, rectangle, arrow, pointer, none
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum FlashActionType : Swift.String {
  case turn_On, turn_Off
  public init(boolean: Swift.Bool)
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FlashSupportEvent : LensCustomerSDK.BaseParser {
  public var is_flash_supported: Swift.Bool
  public var current_flash_status: LensCustomerSDK.FlashActionType
  @objc deinit
}
public class ResolutionHandler {
  public var videoFrame: CoreFoundation.CGRect!
  public var videoRes: CoreFoundation.CGSize! {
    get
    set
  }
  public var viewRect: CoreFoundation.CGRect
  public init(fromView rect: CoreFoundation.CGRect)
  public func getVideoFrame(for input: LensCustomerSDK.DrawingInput) -> CoreFoundation.CGRect
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class Participant : LensCustomerSDK.BaseParser {
  public enum Role : Swift.String {
    case technician, customer, secondary_technician, external_technician
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Status : Swift.String {
    case UP, DOWN
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ParticpantOSType : Swift.String {
    case ios, android
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var clientId: Foundation.NSNumber?
  final public let role: LensCustomerSDK.Participant.Role?
  final public let email: Swift.String?
  public var status: LensCustomerSDK.Participant.Status?
  final public let zuid: Foundation.NSNumber?
  public var name: Swift.String? {
    get
  }
  public var time: Swift.Int?
  public var platformType: LensCustomerSDK.Participant.ParticpantOSType?
  final public let app_version: Swift.String?
  public init(selfEmail: Swift.String?, role: LensCustomerSDK.Participant.Role, status: LensCustomerSDK.Participant.Status?, zuid: Foundation.NSNumber?, display_name: Swift.String?, app_version: Swift.String?, joiningTime: Swift.Int?)
  public static func == (lhs: LensCustomerSDK.Participant, rhs: LensCustomerSDK.Participant) -> Swift.Bool
  @objc deinit
}
extension LensCustomerSDK.SessionValidationResponse.SessionValidationError : Swift.Equatable {}
extension LensCustomerSDK.SessionValidationResponse.SessionValidationError : Swift.Hashable {}
extension LensCustomerSDK.Edition : Swift.Equatable {}
extension LensCustomerSDK.Edition : Swift.Hashable {}
extension LensCustomerSDK.Edition : Swift.RawRepresentable {}
extension LensCustomerSDK.Features : Swift.Equatable {}
extension LensCustomerSDK.Features : Swift.Hashable {}
extension LensCustomerSDK.Features : Swift.RawRepresentable {}
extension LensCustomerSDK.AssisLensStates.AssistLensDisconnectState : Swift.Equatable {}
extension LensCustomerSDK.AssisLensStates.AssistLensDisconnectState : Swift.Hashable {}
extension LensCustomerSDK.SessionValidation : Swift.Equatable {}
extension LensCustomerSDK.SessionValidation : Swift.Hashable {}
extension LensCustomerSDK.SessionValidation : Swift.RawRepresentable {}
extension LensCustomerSDK.ConnectionProcessType : Swift.Equatable {}
extension LensCustomerSDK.ConnectionProcessType : Swift.Hashable {}
extension LensCustomerSDK.ConnectionProcessType : Swift.RawRepresentable {}
extension LensCustomerSDK.TechnicianAction : Swift.Equatable {}
extension LensCustomerSDK.TechnicianAction : Swift.Hashable {}
extension LensCustomerSDK.TechnicianAction : Swift.RawRepresentable {}
extension LensCustomerSDK.RecodingStatus : Swift.Equatable {}
extension LensCustomerSDK.RecodingStatus : Swift.Hashable {}
extension LensCustomerSDK.RecodingStatus : Swift.RawRepresentable {}
extension LensCustomerSDK.RecordingControlMode : Swift.Equatable {}
extension LensCustomerSDK.RecordingControlMode : Swift.Hashable {}
extension LensCustomerSDK.RecordingControlMode : Swift.RawRepresentable {}
extension LensCustomerSDK.CustomerAction : Swift.Equatable {}
extension LensCustomerSDK.CustomerAction : Swift.Hashable {}
extension LensCustomerSDK.CustomerAction : Swift.RawRepresentable {}
extension LensCustomerSDK.ConferenceType : Swift.Equatable {}
extension LensCustomerSDK.ConferenceType : Swift.Hashable {}
extension LensCustomerSDK.ConferenceType : Swift.RawRepresentable {}
extension LensCustomerSDK.LensOpreationError : Swift.Equatable {}
extension LensCustomerSDK.LensOpreationError : Swift.Hashable {}
extension LensCustomerSDK.ShareCameraActionType : Swift.Equatable {}
extension LensCustomerSDK.ShareCameraActionType : Swift.Hashable {}
extension LensCustomerSDK.ShareCameraActionType : Swift.RawRepresentable {}
extension LensCustomerSDK.ShareCameraTechAction : Swift.Equatable {}
extension LensCustomerSDK.ShareCameraTechAction : Swift.Hashable {}
extension LensCustomerSDK.ShareCameraTechAction : Swift.RawRepresentable {}
extension LensCustomerSDK.SnapShotAction : Swift.Equatable {}
extension LensCustomerSDK.SnapShotAction : Swift.Hashable {}
extension LensCustomerSDK.SnapShotAction : Swift.RawRepresentable {}
extension LensCustomerSDK.ScanType : Swift.Equatable {}
extension LensCustomerSDK.ScanType : Swift.Hashable {}
extension LensCustomerSDK.ScanType : Swift.RawRepresentable {}
extension LensCustomerSDK.RoleEnum : Swift.Equatable {}
extension LensCustomerSDK.RoleEnum : Swift.Hashable {}
extension LensCustomerSDK.RoleEnum : Swift.RawRepresentable {}
extension LensCustomerSDK.MonitorActionEnum : Swift.Equatable {}
extension LensCustomerSDK.MonitorActionEnum : Swift.Hashable {}
extension LensCustomerSDK.MonitorActionEnum : Swift.RawRepresentable {}
extension LensCustomerSDK.AnnotationObjectType : Swift.Equatable {}
extension LensCustomerSDK.AnnotationObjectType : Swift.Hashable {}
extension LensCustomerSDK.AnnotationObjectType : Swift.RawRepresentable {}
extension LensCustomerSDK.ClearAction : Swift.Equatable {}
extension LensCustomerSDK.ClearAction : Swift.Hashable {}
extension LensCustomerSDK.ClearAction : Swift.RawRepresentable {}
extension LensCustomerSDK.AnnotationSelection : Swift.Equatable {}
extension LensCustomerSDK.AnnotationSelection : Swift.Hashable {}
extension LensCustomerSDK.AnnotationSelection : Swift.RawRepresentable {}
extension LensCustomerSDK.AR_TrackingState : Swift.Equatable {}
extension LensCustomerSDK.AR_TrackingState : Swift.Hashable {}
extension LensCustomerSDK.SupportedTools : Swift.Equatable {}
extension LensCustomerSDK.SupportedTools : Swift.Hashable {}
extension LensCustomerSDK.SupportedTools : Swift.RawRepresentable {}
extension LensCustomerSDK.MexType : Swift.Equatable {}
extension LensCustomerSDK.MexType : Swift.Hashable {}
extension LensCustomerSDK.MexType : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Session : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Session : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Session : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Session.Scan : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Session.Scan : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Session.Scan : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Chat : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Chat : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Chat : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.InviteUser : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.InviteUser : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.InviteUser : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.InviteUser.Error : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.InviteUser.Error : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.InviteUser.Error : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.ErrorMsg : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.ErrorMsg : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.ErrorMsg : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Notes : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Notes : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Notes : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Common : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Common : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Common : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.ARErroMessage : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.ARErroMessage : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.ARErroMessage : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Snapshot : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Snapshot : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Snapshot : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.CustomerActionContent : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.CustomerActionContent : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.CustomerActionContent : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.ShareCamera : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.ShareCamera : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.ShareCamera : Swift.RawRepresentable {}
extension LensCustomerSDK.LensSessionContent.Flash : Swift.Equatable {}
extension LensCustomerSDK.LensSessionContent.Flash : Swift.Hashable {}
extension LensCustomerSDK.LensSessionContent.Flash : Swift.RawRepresentable {}
extension LensCustomerSDK.SDKLensLottieType : Swift.Equatable {}
extension LensCustomerSDK.SDKLensLottieType : Swift.Hashable {}
extension LensCustomerSDK.ImageScrollView.ContentMode : Swift.Equatable {}
extension LensCustomerSDK.ImageScrollView.ContentMode : Swift.Hashable {}
extension LensCustomerSDK.ImageScrollView.ContentMode : Swift.RawRepresentable {}
extension LensCustomerSDK.ImageScrollView.Offset : Swift.Equatable {}
extension LensCustomerSDK.ImageScrollView.Offset : Swift.Hashable {}
extension LensCustomerSDK.ImageScrollView.Offset : Swift.RawRepresentable {}
extension LensCustomerSDK.DrawingInput.DrawShape : Swift.Equatable {}
extension LensCustomerSDK.DrawingInput.DrawShape : Swift.Hashable {}
extension LensCustomerSDK.DrawingInput.DrawShape : Swift.RawRepresentable {}
extension LensCustomerSDK.DrawingInput.FreeStyleState : Swift.Equatable {}
extension LensCustomerSDK.DrawingInput.FreeStyleState : Swift.Hashable {}
extension LensCustomerSDK.DrawingInput.FreeStyleState : Swift.RawRepresentable {}
extension LensCustomerSDK.LensFlashError : Swift.Equatable {}
extension LensCustomerSDK.LensFlashError : Swift.Hashable {}
extension LensCustomerSDK.LensFlashError : Swift.RawRepresentable {}
extension LensCustomerSDK.Node : Swift.Sendable {}
extension LensCustomerSDK.ARInputViewOrientation : Swift.Equatable {}
extension LensCustomerSDK.ARInputViewOrientation : Swift.Hashable {}
extension LensCustomerSDK.ARInputViewOrientation : Swift.RawRepresentable {}
extension LensCustomerSDK.VMHTTPMethod : Swift.Equatable {}
extension LensCustomerSDK.VMHTTPMethod : Swift.Hashable {}
extension LensCustomerSDK.VMHTTPMethod : Swift.RawRepresentable {}
extension LensCustomerSDK.VMSessionError : Swift.Equatable {}
extension LensCustomerSDK.VMSessionError : Swift.Hashable {}
extension LensCustomerSDK.VMSessionError : Swift.RawRepresentable {}
extension LensCustomerSDK.VMResponseType : Swift.Equatable {}
extension LensCustomerSDK.VMResponseType : Swift.Hashable {}
extension LensCustomerSDK.LayerType : Swift.Equatable {}
extension LensCustomerSDK.LayerType : Swift.Hashable {}
extension LensCustomerSDK.LayerType : Swift.RawRepresentable {}
extension LensCustomerSDK.MatteType : Swift.Equatable {}
extension LensCustomerSDK.MatteType : Swift.Hashable {}
extension LensCustomerSDK.MatteType : Swift.RawRepresentable {}
extension LensCustomerSDK.BlendMode : Swift.Equatable {}
extension LensCustomerSDK.BlendMode : Swift.Hashable {}
extension LensCustomerSDK.BlendMode : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.DrawerMovingPosition : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.DrawerMovingPosition : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.DrawerMovingPosition : Swift.RawRepresentable {}
extension LensCustomerSDK.positionType : Swift.Equatable {}
extension LensCustomerSDK.positionType : Swift.Hashable {}
extension LensCustomerSDK.positionType : Swift.RawRepresentable {}
extension Foundation.Date.Weekday : Swift.Equatable {}
extension Foundation.Date.Weekday : Swift.Hashable {}
extension Foundation.Date.Weekday : Swift.RawRepresentable {}
extension Foundation.Date.SearchDirection : Swift.Equatable {}
extension Foundation.Date.SearchDirection : Swift.Hashable {}
extension LensCustomerSDK.CoordinateSpace : Swift.Equatable {}
extension LensCustomerSDK.CoordinateSpace : Swift.Hashable {}
extension LensCustomerSDK.CoordinateSpace : Swift.RawRepresentable {}
extension ObjectiveC.NSObject.AssistImpactFeedbackStyle : Swift.Equatable {}
extension ObjectiveC.NSObject.AssistImpactFeedbackStyle : Swift.Hashable {}
extension LensCustomerSDK.CloseCode : Swift.Equatable {}
extension LensCustomerSDK.CloseCode : Swift.Hashable {}
extension LensCustomerSDK.CloseCode : Swift.RawRepresentable {}
extension LensCustomerSDK.ErrorType : Swift.Equatable {}
extension LensCustomerSDK.ErrorType : Swift.Hashable {}
extension LensCustomerSDK.WebSocket.OpCode : Swift.Equatable {}
extension LensCustomerSDK.WebSocket.OpCode : Swift.Hashable {}
extension LensCustomerSDK.WebSocket.OpCode : Swift.RawRepresentable {}
extension LensCustomerSDK.FreezeCurrentStatus.FreezeBy : Swift.Equatable {}
extension LensCustomerSDK.FreezeCurrentStatus.FreezeBy : Swift.Hashable {}
extension LensCustomerSDK.CanvasBoardSettings : Swift.Equatable {}
extension LensCustomerSDK.CanvasBoardSettings : Swift.Hashable {}
extension LensCustomerSDK.CanvasBoardSettings : Swift.RawRepresentable {}
extension LensCustomerSDK.LensAnnotationType : Swift.Equatable {}
extension LensCustomerSDK.LensAnnotationType : Swift.Hashable {}
extension LensCustomerSDK.LensAnnotationType : Swift.RawRepresentable {}
extension LensCustomerSDK.AnnotateIcon : Swift.Equatable {}
extension LensCustomerSDK.AnnotateIcon : Swift.Hashable {}
extension LensCustomerSDK.SessionEvents.FileAction : Swift.Equatable {}
extension LensCustomerSDK.SessionEvents.FileAction : Swift.Hashable {}
extension LensCustomerSDK.SessionEvents.FileAction : Swift.RawRepresentable {}
extension LensCustomerSDK.ExternalApp : Swift.Equatable {}
extension LensCustomerSDK.ExternalApp : Swift.Hashable {}
extension LensCustomerSDK.ExternalApp : Swift.RawRepresentable {}
extension LensCustomerSDK.ExternalApp.Permission : Swift.Equatable {}
extension LensCustomerSDK.ExternalApp.Permission : Swift.Hashable {}
extension LensCustomerSDK.ExternalApp.Permission : Swift.RawRepresentable {}
extension LensCustomerSDK.LensLottieType : Swift.Equatable {}
extension LensCustomerSDK.LensLottieType : Swift.Hashable {}
extension LensCustomerSDK.AssistAlertActionStyle : Swift.Equatable {}
extension LensCustomerSDK.AssistAlertActionStyle : Swift.Hashable {}
extension LensCustomerSDK.CompatibleRenderingEngineOption : Swift.Equatable {}
extension LensCustomerSDK.CompatibleRenderingEngineOption : Swift.Hashable {}
extension LensCustomerSDK.CompatibleRenderingEngineOption : Swift.RawRepresentable {}
extension LensCustomerSDK.CompatibleBackgroundBehavior : Swift.Equatable {}
extension LensCustomerSDK.CompatibleBackgroundBehavior : Swift.Hashable {}
extension LensCustomerSDK.CompatibleBackgroundBehavior : Swift.RawRepresentable {}
extension LensCustomerSDK.LottieView : SwiftUICore.View {}
extension LensCustomerSDK.LottieView : Swift.Sendable {}
extension LensCustomerSDK.SizeValueProvider : LensCustomerSDK.AnyValueProvider {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.AssistCollectionDataSource : Swift.Sendable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.At_Orientation : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.At_Orientation : Swift.Hashable {}
extension LensCustomerSDK.LottieBackgroundBehavior : Swift.Equatable {}
extension LensCustomerSDK.LottieBackgroundBehavior : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.OverlayViewType : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.OverlayViewType : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.OverlayViewStyle : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.OverlayViewStyle : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.OverlayViewStyle : Swift.RawRepresentable {}
extension LensCustomerSDK.LottieButton : SwiftUICore.View {}
extension LensCustomerSDK.LottieButton : Swift.Sendable {}
extension UIKit.UIDevice.ScreenType : Swift.Equatable {}
extension UIKit.UIDevice.ScreenType : Swift.Hashable {}
extension UIKit.UIDevice.ScreenType : Swift.RawRepresentable {}
extension LensCustomerSDK.LottieSwitch : SwiftUICore.View {}
extension LensCustomerSDK.LottieSwitch : Swift.Sendable {}
extension LensCustomerSDK.AssistSocketErrorState : Swift.Equatable {}
extension LensCustomerSDK.AssistSocketErrorState : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UIView.NotificationBannerStyle : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension UIKit.UIView.NotificationBannerStyle : Swift.Hashable {}
extension LensCustomerSDK.GradientValueProvider : LensCustomerSDK.AnyValueProvider {}
extension LensCustomerSDK.ContentType : Swift.Equatable {}
extension LensCustomerSDK.ContentType : Swift.Hashable {}
extension LensCustomerSDK.ContentType : Swift.RawRepresentable {}
extension LensCustomerSDK.PointValueProvider : LensCustomerSDK.AnyValueProvider {}
extension LensCustomerSDK.FloatValueProvider : LensCustomerSDK.AnyValueProvider {}
extension LensCustomerSDK.Notes.CodingKeys : Swift.Equatable {}
extension LensCustomerSDK.Notes.CodingKeys : Swift.Hashable {}
extension LensCustomerSDK.Notes.CodingKeys : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.SheetActionCellType : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.SheetActionCellType : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.DatePickerController.Mode : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.DatePickerController.Mode : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.DatePickerController.Mode : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.ToastPosition : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.ToastPosition : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.SelectionSheetController.SelectionMode : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.SelectionSheetController.SelectionMode : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.SheetActionStyle : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.SheetActionStyle : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.AlertStyle : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension LensCustomerSDK.AlertStyle : Swift.Hashable {}
extension LensCustomerSDK.AnimatedSwitch.CancelBehavior : Swift.Equatable {}
extension LensCustomerSDK.AnimatedSwitch.CancelBehavior : Swift.Hashable {}
extension UIKit.UIScrollView.ATViewSide : Swift.Equatable {}
extension UIKit.UIScrollView.ATViewSide : Swift.Hashable {}
extension LensCustomerSDK.ColorValueProvider : LensCustomerSDK.AnyValueProvider {}
extension LensCustomerSDK.FreeStyleState : Swift.Equatable {}
extension LensCustomerSDK.FreeStyleState : Swift.Hashable {}
extension LensCustomerSDK.ARFrameMode : Swift.Equatable {}
extension LensCustomerSDK.ARFrameMode : Swift.Hashable {}
extension LensCustomerSDK.ARFrameMode : Swift.RawRepresentable {}
extension LensCustomerSDK.ARVideoOrientation : Swift.Equatable {}
extension LensCustomerSDK.ARVideoOrientation : Swift.Hashable {}
extension LensCustomerSDK.ARVideoOrientation : Swift.RawRepresentable {}
extension LensCustomerSDK.RecordARMicrophonePermission : Swift.Equatable {}
extension LensCustomerSDK.RecordARMicrophonePermission : Swift.Hashable {}
extension LensCustomerSDK.RecordARMicrophonePermission : Swift.RawRepresentable {}
extension LensCustomerSDK.RecordARStatus : Swift.Equatable {}
extension LensCustomerSDK.RecordARStatus : Swift.Hashable {}
extension LensCustomerSDK.RecordARStatus : Swift.RawRepresentable {}
extension LensCustomerSDK.RecordARMicrophoneStatus : Swift.Equatable {}
extension LensCustomerSDK.RecordARMicrophoneStatus : Swift.Hashable {}
extension LensCustomerSDK.RecordARMicrophoneStatus : Swift.RawRepresentable {}
extension LensCustomerSDK.VideoResolution : Swift.Equatable {}
extension LensCustomerSDK.VideoResolution : Swift.Hashable {}
extension LensCustomerSDK.VideoResolution : Swift.RawRepresentable {}
extension LensCustomerSDK.StreamingType : Swift.Equatable {}
extension LensCustomerSDK.StreamingType : Swift.Hashable {}
extension LensCustomerSDK.StreamingType : Swift.RawRepresentable {}
extension LensCustomerSDK.QRRetryMode : Swift.Equatable {}
extension LensCustomerSDK.QRRetryMode : Swift.Hashable {}
@available(*, unavailable, renamed: "Connection")
extension LensCustomerSDK.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension LensCustomerSDK.Reachability.NetworkStatus : Swift.Hashable {}
extension LensCustomerSDK.Reachability.Connection : Swift.Equatable {}
extension LensCustomerSDK.Reachability.Connection : Swift.Hashable {}
extension LensCustomerSDK.FlashActionType : Swift.Equatable {}
extension LensCustomerSDK.FlashActionType : Swift.Hashable {}
extension LensCustomerSDK.FlashActionType : Swift.RawRepresentable {}
extension LensCustomerSDK.Participant.Role : Swift.Equatable {}
extension LensCustomerSDK.Participant.Role : Swift.Hashable {}
extension LensCustomerSDK.Participant.Role : Swift.RawRepresentable {}
extension LensCustomerSDK.Participant.Status : Swift.Equatable {}
extension LensCustomerSDK.Participant.Status : Swift.Hashable {}
extension LensCustomerSDK.Participant.Status : Swift.RawRepresentable {}
extension LensCustomerSDK.Participant.ParticpantOSType : Swift.Equatable {}
extension LensCustomerSDK.Participant.ParticpantOSType : Swift.Hashable {}
extension LensCustomerSDK.Participant.ParticpantOSType : Swift.RawRepresentable {}
